/// <reference types="react" />
import { PropsWithChildren, ReactNode, ComponentType } from 'react';
import PropTypes from 'prop-types';
import { BackstageTheme } from '@backstage/theme';
import { SvgIconProps } from '@material-ui/core';
import { Config, AppConfig } from '@backstage/config';
export { ConfigReader } from '@backstage/config';
import { Observable as Observable$1 } from '@backstage/core';

declare type ApiRef<T> = {
    id: string;
    description?: string;
    T: T;
};
declare type AnyApiRef = ApiRef<unknown>;
declare type ApiRefType<T> = T extends ApiRef<infer U> ? U : never;
declare type TypesToApiRefs<T> = {
    [key in keyof T]: ApiRef<T[key]>;
};
declare type ApiRefsToTypes<T extends {
    [key in string]: ApiRef<unknown>;
}> = {
    [key in keyof T]: ApiRefType<T[key]>;
};
declare type ApiHolder = {
    get<T>(api: ApiRef<T>): T | undefined;
};
declare type ApiFactory<Api, Impl extends Api, Deps extends {
    [name in string]: unknown;
}> = {
    api: ApiRef<Api>;
    deps: TypesToApiRefs<Deps>;
    factory(deps: Deps): Impl;
};
declare type AnyApiFactory = ApiFactory<unknown, unknown, {
    [key in string]: unknown;
}>;
declare type ApiFactoryHolder = {
    get<T>(api: ApiRef<T>): ApiFactory<T, T, {
        [key in string]: unknown;
    }> | undefined;
};

declare type ApiProviderProps = {
    apis: ApiHolder;
    children: ReactNode;
};
declare const ApiProvider: {
    ({ apis, children, }: PropsWithChildren<ApiProviderProps>): JSX.Element;
    propTypes: {
        apis: PropTypes.Validator<PropTypes.InferProps<{
            get: PropTypes.Validator<(...args: any[]) => any>;
        }>>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
    };
};
declare function useApiHolder(): ApiHolder;
declare function useApi<T>(apiRef: ApiRef<T>): T;

declare type ApiImpl<T = unknown> = readonly [ApiRef<T>, T];
declare class ApiRegistryBuilder {
    private apis;
    add<T, I extends T>(api: ApiRef<T>, impl: I): I;
    build(): ApiRegistry;
}
declare class ApiRegistry implements ApiHolder {
    private readonly apis;
    static builder(): ApiRegistryBuilder;
    static from(apis: ApiImpl[]): ApiRegistry;
    /**
     * Creates a new ApiRegistry with a single API implementation.
     *
     * @param api ApiRef for the API to add
     * @param impl Implementation of the API to add
     */
    static with<T>(api: ApiRef<T>, impl: T): ApiRegistry;
    constructor(apis: Map<string, unknown>);
    /**
     * Returns a new ApiRegistry with the provided API added to the existing ones.
     *
     * @param api ApiRef for the API to add
     * @param impl Implementation of the API to add
     */
    with<T>(api: ApiRef<T>, impl: T): ApiRegistry;
    get<T>(api: ApiRef<T>): T | undefined;
}

declare class ApiResolver implements ApiHolder {
    private readonly factories;
    /**
     * Validate factories by making sure that each of the apis can be created
     * without hitting any circular dependencies.
     */
    static validateFactories(factories: ApiFactoryHolder, apis: Iterable<AnyApiRef>): void;
    private readonly apis;
    constructor(factories: ApiFactoryHolder);
    get<T>(ref: ApiRef<T>): T | undefined;
    private load;
    private loadDeps;
}

declare type ApiFactoryScope = 'default' | 'app' | 'static';
/**
 * ApiFactoryRegistry is an ApiFactoryHolder implementation that enables
 * registration of API Factories with different scope.
 *
 * Each scope has an assigned priority, where factories registered with
 * higher priority scopes override ones with lower priority.
 */
declare class ApiFactoryRegistry implements ApiFactoryHolder {
    private readonly factories;
    /**
     * Register a new API factory. Returns true if the factory was added
     * to the registry.
     *
     * A factory will not be added to the registry if there is already
     * an existing factory with the same or higher priority.
     */
    register<Api, Impl extends Api, Deps extends {
        [name in string]: unknown;
    }>(scope: ApiFactoryScope, factory: ApiFactory<Api, Impl, Deps>): boolean;
    get<T>(api: ApiRef<T>): ApiFactory<T, T, {
        [x: string]: unknown;
    }> | undefined;
    getAllApis(): Set<AnyApiRef>;
}

declare type ApiRefConfig = {
    id: string;
    description?: string;
};
declare function createApiRef<T>(config: ApiRefConfig): ApiRef<T>;

/**
 * Used to infer types for a standalone ApiFactory that isn't immediately passed
 * to another function.
 * This function doesn't actually do anything, it's only used to infer types.
 */
declare function createApiFactory<Api, Impl extends Api, Deps extends {
    [name in string]: unknown;
}>(factory: ApiFactory<Api, Impl, Deps>): ApiFactory<Api, Impl, Deps>;
declare function createApiFactory<Api, Impl extends Api>(api: ApiRef<Api>, instance: Impl): ApiFactory<Api, Impl, {}>;

/**
 * This file contains non-react related core types used throughout Backstage.
 */
/**
 * Observer interface for consuming an Observer, see TC39.
 */
declare type Observer<T> = {
    next?(value: T): void;
    error?(error: Error): void;
    complete?(): void;
};
/**
 * Subscription returned when subscribing to an Observable, see TC39.
 */
declare type Subscription = {
    /**
     * Cancels the subscription
     */
    unsubscribe(): void;
    /**
     * Value indicating whether the subscription is closed.
     */
    readonly closed: boolean;
};
declare global {
    interface SymbolConstructor {
        readonly observable: symbol;
    }
}
/**
 * Observable sequence of values and errors, see TC39.
 *
 * https://github.com/tc39/proposal-observable
 *
 * This is used as a common return type for observable values and can be created
 * using many different observable implementations, such as zen-observable or RxJS 5.
 */
declare type Observable<T> = {
    [Symbol.observable](): Observable<T>;
    /**
     * Subscribes to this observable to start receiving new values.
     */
    subscribe(observer: Observer<T>): Subscription;
    subscribe(onNext?: (value: T) => void, onError?: (error: Error) => void, onComplete?: () => void): Subscription;
};

/**
 * This file contains declarations for common interfaces of auth-related APIs.
 * The declarations should be used to signal which type of authentication and
 * authorization methods each separate auth provider supports.
 *
 * For example, a Google OAuth provider that supports OAuth 2 and OpenID Connect,
 * would be declared as follows:
 *
 * const googleAuthApiRef = createApiRef<OAuthApi & OpenIDConnectApi>({ ... })
 */
/**
 * An array of scopes, or a scope string formatted according to the
 * auth provider, which is typically a space separated list.
 *
 * See the documentation for each auth provider for the list of scopes
 * supported by each provider.
 */
declare type OAuthScope = string | string[];
declare type AuthRequestOptions = {
    /**
     * If this is set to true, the user will not be prompted to log in,
     * and an empty response will be returned if there is no existing session.
     *
     * This can be used to perform a check whether the user is logged in, or if you don't
     * want to force a user to be logged in, but provide functionality if they already are.
     *
     * @default false
     */
    optional?: boolean;
    /**
     * If this is set to true, the request will bypass the regular oauth login modal
     * and open the login popup directly.
     *
     * The method must be called synchronously from a user action for this to work in all browsers.
     *
     * @default false
     */
    instantPopup?: boolean;
};
/**
 * This API provides access to OAuth 2 credentials. It lets you request access tokens,
 * which can be used to act on behalf of the user when talking to APIs.
 */
declare type OAuthApi = {
    /**
     * Requests an OAuth 2 Access Token, optionally with a set of scopes. The access token allows
     * you to make requests on behalf of the user, and the copes may grant you broader access, depending
     * on the auth provider.
     *
     * Each auth provider has separate handling of scope, so you need to look at the documentation
     * for each one to know what scope you need to request.
     *
     * This method is cheap and should be called each time an access token is used. Do not for example
     * store the access token in React component state, as that could cause the token to expire. Instead
     * fetch a new access token for each request.
     *
     * Be sure to include all required scopes when requesting an access token. When testing your implementation
     * it is best to log out the Backstage session and then visit your plugin page directly, as
     * you might already have some required scopes in your existing session. Not requesting the correct
     * scopes can lead to 403 or other authorization errors, which can be tricky to debug.
     *
     * If the user has not yet granted access to the provider and the set of requested scopes, the user
     * will be prompted to log in. The returned promise will not resolve until the user has
     * successfully logged in. The returned promise can be rejected, but only if the user rejects the login request.
     */
    getAccessToken(scope?: OAuthScope, options?: AuthRequestOptions): Promise<string>;
};
/**
 * This API provides access to OpenID Connect credentials. It lets you request ID tokens,
 * which can be passed to backend services to prove the user's identity.
 */
declare type OpenIdConnectApi = {
    /**
     * Requests an OpenID Connect ID Token.
     *
     * This method is cheap and should be called each time an ID token is used. Do not for example
     * store the id token in React component state, as that could cause the token to expire. Instead
     * fetch a new id token for each request.
     *
     * If the user has not yet logged in to Google inside Backstage, the user will be prompted
     * to log in. The returned promise will not resolve until the user has successfully logged in.
     * The returned promise can be rejected, but only if the user rejects the login request.
     */
    getIdToken(options?: AuthRequestOptions): Promise<string>;
};
/**
 * This API provides access to profile information of the user from an auth provider.
 */
declare type ProfileInfoApi = {
    /**
     * Get profile information for the user as supplied by this auth provider.
     *
     * If the optional flag is not set, a session is guaranteed to be returned, while if
     * the optional flag is set, the session may be undefined. See @AuthRequestOptions for more details.
     */
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
};
/**
 * This API provides access to the user's identity within Backstage.
 *
 * An auth provider that implements this interface can be used to sign-in to backstage. It is
 * not intended to be used directly from a plugin, but instead serves as a connection between
 * this authentication method and the app's @IdentityApi
 */
declare type BackstageIdentityApi = {
    /**
     * Get the user's identity within Backstage. This should normally not be called directly,
     * use the @IdentityApi instead.
     *
     * If the optional flag is not set, a session is guaranteed to be returned, while if
     * the optional flag is set, the session may be undefined. See @AuthRequestOptions for more details.
     */
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
};
declare type BackstageIdentity = {
    /**
     * The backstage user ID.
     */
    id: string;
    /**
     * An ID token that can be used to authenticate the user within Backstage.
     */
    idToken: string;
};
/**
 * Profile information of the user.
 */
declare type ProfileInfo = {
    /**
     * Email ID.
     */
    email?: string;
    /**
     * Display name that can be presented to the user.
     */
    displayName?: string;
    /**
     * URL to an avatar image of the user.
     */
    picture?: string;
};
/**
 * Session state values passed to subscribers of the SessionApi.
 */
declare enum SessionState {
    SignedIn = "SignedIn",
    SignedOut = "SignedOut"
}
/**
 * The SessionApi provides basic controls for any auth provider that is tied to a persistent session.
 */
declare type SessionApi = {
    /**
     * Sign in with a minimum set of permissions.
     */
    signIn(): Promise<void>;
    /**
     * Sign out from the current session. This will reload the page.
     */
    signOut(): Promise<void>;
    /**
     * Observe the current state of the auth session. Emits the current state on subscription.
     */
    sessionState$(): Observable<SessionState>;
};
/**
 * Provides authentication towards Google APIs and identities.
 *
 * See https://developers.google.com/identity/protocols/googlescopes for a full list of supported scopes.
 *
 * Note that the ID token payload is only guaranteed to contain the user's numerical Google ID,
 * email and expiration information. Do not rely on any other fields, as they might not be present.
 */
declare const googleAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards GitHub APIs.
 *
 * See https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/
 * for a full list of supported scopes.
 */
declare const githubAuthApiRef: ApiRef<OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards Okta APIs.
 *
 * See https://developer.okta.com/docs/guides/implement-oauth-for-okta/scopes/
 * for a full list of supported scopes.
 */
declare const oktaAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards GitLab APIs.
 *
 * See https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html#limiting-scopes-of-a-personal-access-token
 * for a full list of supported scopes.
 */
declare const gitlabAuthApiRef: ApiRef<OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards Auth0 APIs.
 *
 * See https://auth0.com/docs/scopes/current/oidc-scopes
 * for a full list of supported scopes.
 */
declare const auth0AuthApiRef: ApiRef<OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards Microsoft APIs and identities.
 *
 * For more info and a full list of supported scopes, see:
 * - https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent
 * - https://docs.microsoft.com/en-us/graph/permissions-reference
 */
declare const microsoftAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication for custom identity providers.
 */
declare const oauth2ApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication for custom OpenID Connect identity providers.
 */
declare const oidcAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication for saml based identity providers
 */
declare const samlAuthApiRef: ApiRef<ProfileInfoApi & BackstageIdentityApi & SessionApi>;
declare const oneloginAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;

declare type AlertMessage = {
    message: string;
    severity?: 'success' | 'info' | 'warning' | 'error';
};
/**
 * The alert API is used to report alerts to the app, and display them to the user.
 */
declare type AlertApi = {
    /**
     * Post an alert for handling by the application.
     */
    post(alert: AlertMessage): void;
    /**
     * Observe alerts posted by other parts of the application.
     */
    alert$(): Observable<AlertMessage>;
};
declare const alertApiRef: ApiRef<AlertApi>;

/**
 * Describes a theme provided by the app.
 */
declare type AppTheme = {
    /**
     * ID used to remember theme selections.
     */
    id: string;
    /**
     * Title of the theme
     */
    title: string;
    /**
     * Theme variant
     */
    variant: 'light' | 'dark';
    /**
     * The specialized MaterialUI theme instance.
     */
    theme: BackstageTheme;
    /**
     * An Icon for the theme mode setting.
     */
    icon?: React.ReactElement<SvgIconProps>;
};
/**
 * The AppThemeApi gives access to the current app theme, and allows switching
 * to other options that have been registered as a part of the App.
 */
declare type AppThemeApi = {
    /**
     * Get a list of available themes.
     */
    getInstalledThemes(): AppTheme[];
    /**
     * Observe the currently selected theme. A value of undefined means no specific theme has been selected.
     */
    activeThemeId$(): Observable<string | undefined>;
    /**
     * Get the current theme ID. Returns undefined if no specific theme is selected.
     */
    getActiveThemeId(): string | undefined;
    /**
     * Set a specific theme to use in the app, overriding the default theme selection.
     *
     * Clear the selection by passing in undefined.
     */
    setActiveThemeId(themeId?: string): void;
};
declare const appThemeApiRef: ApiRef<AppThemeApi>;

/**
 * The Config API is used to provide a mechanism to access the
 * runtime configuration of the system.
 */
declare type ConfigApi = Config;
declare const configApiRef: ApiRef<ConfigApi>;

/**
 * The discovery API is used to provide a mechanism for plugins to
 * discover the endpoint to use to talk to their backend counterpart.
 *
 * The purpose of the discovery API is to allow for many different deployment
 * setups and routing methods through a central configuration, instead
 * of letting each individual plugin manage that configuration.
 *
 * Implementations of the discovery API can be a simple as a URL pattern
 * using the pluginId, but could also have overrides for individual plugins,
 * or query a separate discovery service.
 */
declare type DiscoveryApi = {
    /**
     * Returns the HTTP base backend URL for a given plugin, without a trailing slash.
     *
     * This method must always be called just before making a request, as opposed to
     * fetching the URL when constructing an API client. That is to ensure that more
     * flexible routing patterns can be supported.
     *
     * For example, asking for the URL for `auth` may return something
     * like `https://backstage.example.com/api/auth`
     */
    getBaseUrl(pluginId: string): Promise<string>;
};
declare const discoveryApiRef: ApiRef<DiscoveryApi>;

/**
 * Mirrors the JavaScript Error class, for the purpose of
 * providing documentation and optional fields.
 */
declare type Error$1 = {
    name: string;
    message: string;
    stack?: string;
};
/**
 * Provides additional information about an error that was posted to the application.
 */
declare type ErrorContext = {
    hidden?: boolean;
};
/**
 * The error API is used to report errors to the app, and display them to the user.
 *
 * Plugins can use this API as a method of displaying errors to the user, but also
 * to report errors for collection by error reporting services.
 *
 * If an error can be displayed inline, e.g. as feedback in a form, that should be
 * preferred over relying on this API to display the error. The main use of this API
 * for displaying errors should be for asynchronous errors, such as a failing background process.
 *
 * Even if an error is displayed inline, it should still be reported through this API
 * if it would be useful to collect or log it for debugging purposes, but with
 * the hidden flag set. For example, an error arising from form field validation
 * should probably not be reported, while a failed REST call would be useful to report.
 */
declare type ErrorApi = {
    /**
     * Post an error for handling by the application.
     */
    post(error: Error$1, context?: ErrorContext): void;
    /**
     * Observe errors posted by other parts of the application.
     */
    error$(): Observable<{
        error: Error$1;
        context?: ErrorContext;
    }>;
};
declare const errorApiRef: ApiRef<ErrorApi>;

/**
 * The feature flags API is used to toggle functionality to users across plugins and Backstage.
 *
 * Plugins can use this API to register feature flags that they have available
 * for users to enable/disable, and this API will centralize the current user's
 * state of which feature flags they would like to enable.
 *
 * This is ideal for Backstage plugins, as well as your own App, to trial incomplete
 * or unstable upcoming features. Although there will be a common interface for users
 * to enable and disable feature flags, this API acts as another way to enable/disable.
 */
declare type FeatureFlag = {
    name: string;
    pluginId: string;
};
declare enum FeatureFlagState {
    None = 0,
    Active = 1
}
/**
 * Options to use when saving feature flags.
 */
declare type FeatureFlagsSaveOptions = {
    /**
     * The new feature flag states to save.
     */
    states: Record<string, FeatureFlagState>;
    /**
     * Whether the saves states should be merged into the existing ones, or replace them.
     *
     * Defaults to false.
     */
    merge?: boolean;
};
declare type UserFlags = {};
interface FeatureFlagsApi {
    /**
     * Registers a new feature flag. Once a feature flag has been registered it
     * can be toggled by users, and read back to enable or disable features.
     */
    registerFlag(flag: FeatureFlag): void;
    /**
     * Get a list of all registered flags.
     */
    getRegisteredFlags(): FeatureFlag[];
    /**
     * Whether the feature flag with the given name is currently activated for the user.
     */
    isActive(name: string): boolean;
    /**
     * Save the user's choice of feature flag states.
     */
    save(options: FeatureFlagsSaveOptions): void;
}
declare const featureFlagsApiRef: ApiRef<FeatureFlagsApi>;

/**
 * The Identity API used to identify and get information about the signed in user.
 */
declare type IdentityApi = {
    /**
     * The ID of the signed in user. This ID is not meant to be presented to the user, but used
     * as an opaque string to pass on to backends or use in frontend logic.
     *
     * TODO: The intention of the user ID is to be able to tie the user to an identity
     *       that is known by the catalog and/or identity backend. It should for example
     *       be possible to fetch all owned components using this ID.
     */
    getUserId(): string;
    /**
     * The profile of the signed in user.
     */
    getProfile(): ProfileInfo;
    /**
     * An OpenID Connect ID Token which proves the identity of the signed in user.
     *
     * The ID token will be undefined if the signed in user does not have a verified
     * identity, such as a demo user or mocked user for e2e tests.
     */
    getIdToken(): Promise<string | undefined>;
    /**
     * Sign out the current user
     */
    signOut(): Promise<void>;
};
declare const identityApiRef: ApiRef<IdentityApi>;

declare type SystemIconKey = 'brokenImage' | 'chat' | 'dashboard' | 'email' | 'github' | 'group' | 'help' | 'user' | 'warning' | 'docs';
declare type IconComponent = ComponentType<SvgIconProps>;
declare type IconKey = SystemIconKey | string;
declare type IconComponentMap = {
    [key in IconKey]: IconComponent;
};

/**
 * Information about the auth provider that we're requesting a login towards.
 *
 * This should be shown to the user so that they can be informed about what login is being requested
 * before a popup is shown.
 */
declare type AuthProvider = {
    /**
     * Title for the auth provider, for example "GitHub"
     */
    title: string;
    /**
     * Icon for the auth provider.
     */
    icon: IconComponent;
};
/**
 * Describes how to handle auth requests. Both how to show them to the user, and what to do when
 * the user accesses the auth request.
 */
declare type AuthRequesterOptions<AuthResponse> = {
    /**
     * Information about the auth provider, which will be forwarded to auth requests.
     */
    provider: AuthProvider;
    /**
     * Implementation of the auth flow, which will be called synchronously when
     * trigger() is called on an auth requests.
     */
    onAuthRequest(scopes: Set<string>): Promise<AuthResponse>;
};
/**
 * Function used to trigger new auth requests for a set of scopes.
 *
 * The returned promise will resolve to the same value returned by the onAuthRequest in the
 * AuthRequesterOptions. Or rejected, if the request is rejected.
 *
 * This function can be called multiple times before the promise resolves. All calls
 * will be merged into one request, and the scopes forwarded to the onAuthRequest will be the
 * union of all requested scopes.
 */
declare type AuthRequester<AuthResponse> = (scopes: Set<string>) => Promise<AuthResponse>;
/**
 * An pending auth request for a single auth provider. The request will remain in this pending
 * state until either reject() or trigger() is called.
 *
 * Any new requests for the same provider are merged into the existing pending request, meaning
 * there will only ever be a single pending request for a given provider.
 */
declare type PendingAuthRequest = {
    /**
     * Information about the auth provider, as given in the AuthRequesterOptions
     */
    provider: AuthProvider;
    /**
     * Rejects the request, causing all pending AuthRequester calls to fail with "RejectedError".
     */
    reject: () => void;
    /**
     * Trigger the auth request to continue the auth flow, by for example showing a popup.
     *
     * Synchronously calls onAuthRequest with all scope currently in the request.
     */
    trigger(): Promise<void>;
};
/**
 * Provides helpers for implemented OAuth login flows within Backstage.
 */
declare type OAuthRequestApi = {
    /**
     * A utility for showing login popups or similar things, and merging together multiple requests for
     * different scopes into one request that includes all scopes.
     *
     * The passed in options provide information about the login provider, and how to handle auth requests.
     *
     * The returned AuthRequester function is used to request login with new scopes. These requests
     * are merged together and forwarded to the auth handler, as soon as a consumer of auth requests
     * triggers an auth flow.
     *
     * See AuthRequesterOptions, AuthRequester, and handleAuthRequests for more info.
     */
    createAuthRequester<AuthResponse>(options: AuthRequesterOptions<AuthResponse>): AuthRequester<AuthResponse>;
    /**
     * Observers pending auth requests. The returned observable will emit all
     * current active auth request, at most one for each created auth requester.
     *
     * Each request has its own info about the login provider, forwarded from the auth requester options.
     *
     * Depending on user interaction, the request should either be rejected, or used to trigger the auth handler.
     * If the request is rejected, all pending AuthRequester calls will fail with a "RejectedError".
     * If a auth is triggered, and the auth handler resolves successfully, then all currently pending
     * AuthRequester calls will resolve to the value returned by the onAuthRequest call.
     */
    authRequest$(): Observable<PendingAuthRequest[]>;
};
declare const oauthRequestApiRef: ApiRef<OAuthRequestApi>;

declare type StorageValueChange<T = any> = {
    key: string;
    newValue?: T;
};
declare type CreateStorageApiOptions = {
    errorApi: ErrorApi;
    namespace?: string;
};
interface StorageApi {
    /**
     * Create a bucket to store data in.
     * @param {String} name Namespace for the storage to be stored under,
     *                      will inherit previous namespaces too
     */
    forBucket(name: string): StorageApi;
    /**
     * Get the current value for persistent data, use observe$ to be notified of updates.
     *
     * @param {String} key Unique key associated with the data.
     * @return {Object} data The data that should is stored.
     */
    get<T>(key: string): T | undefined;
    /**
     * Remove persistent data.
     *
     * @param {String} key Unique key associated with the data.
     */
    remove(key: string): Promise<void>;
    /**
     * Save persistent data, and emit messages to anyone that is using observe$ for this key
     *
     * @param {String} key Unique key associated with the data.
     */
    set(key: string, data: any): Promise<void>;
    /**
     * Observe changes on a particular key in the bucket
     * @param {String} key Unique key associated with the data
     */
    observe$<T>(key: string): Observable<StorageValueChange<T>>;
}
declare const storageApiRef: ApiRef<StorageApi>;

declare type GithubSession = {
    providerInfo: {
        accessToken: string;
        scopes: Set<string>;
        expiresAt: Date;
    };
    profile: ProfileInfo;
    backstageIdentity: BackstageIdentity;
};

declare type GetSessionOptions = {
    optional?: boolean;
    instantPopup?: boolean;
    scopes?: Set<string>;
};
/**
 * A sessions manager keeps track of the current session and makes sure that
 * multiple simultaneous requests for sessions with different scope are handled
 * in a correct way.
 */
declare type SessionManager<T> = {
    getSession(options: GetSessionOptions): Promise<T | undefined>;
    removeSession(): Promise<void>;
    sessionState$(): Observable<SessionState>;
};

declare type OAuthApiCreateOptions = AuthApiCreateOptions & {
    oauthRequestApi: OAuthRequestApi;
    defaultScopes?: string[];
};
declare type AuthApiCreateOptions = {
    discoveryApi: DiscoveryApi;
    environment?: string;
    provider?: AuthProvider & {
        id: string;
    };
};

declare class GithubAuth implements OAuthApi, SessionApi {
    private readonly sessionManager;
    static create({ discoveryApi, environment, provider, oauthRequestApi, defaultScopes, }: OAuthApiCreateOptions): GithubAuth;
    constructor(sessionManager: SessionManager<GithubSession>);
    signIn(): Promise<void>;
    signOut(): Promise<void>;
    sessionState$(): Observable<SessionState>;
    getAccessToken(scope?: string, options?: AuthRequestOptions): Promise<string>;
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
    static normalizeScope(scope?: string): Set<string>;
}

declare class GitlabAuth {
    static create({ discoveryApi, environment, provider, oauthRequestApi, defaultScopes, }: OAuthApiCreateOptions): typeof gitlabAuthApiRef.T;
}

declare class GoogleAuth {
    static create({ discoveryApi, oauthRequestApi, environment, provider, defaultScopes, }: OAuthApiCreateOptions): typeof googleAuthApiRef.T;
}

declare type OAuth2Session = {
    providerInfo: {
        idToken: string;
        accessToken: string;
        scopes: Set<string>;
        expiresAt: Date;
    };
    profile: ProfileInfo;
    backstageIdentity: BackstageIdentity;
};

declare type Options = {
    sessionManager: SessionManager<OAuth2Session>;
    scopeTransform: (scopes: string[]) => string[];
};
declare type CreateOptions = OAuthApiCreateOptions & {
    scopeTransform?: (scopes: string[]) => string[];
};
declare class OAuth2 implements OAuthApi, OpenIdConnectApi, ProfileInfoApi, BackstageIdentityApi, SessionApi {
    static create({ discoveryApi, environment, provider, oauthRequestApi, defaultScopes, scopeTransform, }: CreateOptions): OAuth2;
    private readonly sessionManager;
    private readonly scopeTransform;
    constructor(options: Options);
    signIn(): Promise<void>;
    signOut(): Promise<void>;
    sessionState$(): Observable<SessionState>;
    getAccessToken(scope?: string | string[], options?: AuthRequestOptions): Promise<string>;
    getIdToken(options?: AuthRequestOptions): Promise<string>;
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
    private static normalizeScopes;
}

declare class OktaAuth {
    static create({ discoveryApi, environment, provider, oauthRequestApi, defaultScopes, }: OAuthApiCreateOptions): typeof oktaAuthApiRef.T;
}

declare type SamlSession = {
    userId: string;
    profile: ProfileInfo;
    backstageIdentity: BackstageIdentity;
};

declare class SamlAuth implements ProfileInfoApi, BackstageIdentityApi, SessionApi {
    private readonly sessionManager;
    static create({ discoveryApi, environment, provider, }: AuthApiCreateOptions): SamlAuth;
    sessionState$(): Observable<SessionState>;
    constructor(sessionManager: SessionManager<SamlSession>);
    signIn(): Promise<void>;
    signOut(): Promise<void>;
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
}

declare class Auth0Auth {
    static create({ discoveryApi, environment, provider, oauthRequestApi, defaultScopes, }: OAuthApiCreateOptions): typeof auth0AuthApiRef.T;
}

declare class MicrosoftAuth {
    static create({ environment, provider, oauthRequestApi, discoveryApi, defaultScopes, }: OAuthApiCreateOptions): typeof microsoftAuthApiRef.T;
}

declare type CreateOptions$1 = {
    discoveryApi: DiscoveryApi;
    oauthRequestApi: OAuthRequestApi;
    environment?: string;
    provider?: AuthProvider & {
        id: string;
    };
};
declare class OneLoginAuth {
    static create({ discoveryApi, environment, provider, oauthRequestApi, }: CreateOptions$1): typeof oneloginAuthApiRef.T;
}

/**
 * Base implementation for the AlertApi that simply forwards alerts to consumers.
 */
declare class AlertApiForwarder implements AlertApi {
    private readonly subject;
    post(alert: AlertMessage): void;
    alert$(): Observable<AlertMessage>;
}

declare class AppThemeSelector implements AppThemeApi {
    private readonly themes;
    static createWithStorage(themes: AppTheme[]): AppThemeSelector;
    private activeThemeId;
    private readonly subject;
    constructor(themes: AppTheme[]);
    getInstalledThemes(): AppTheme[];
    activeThemeId$(): Observable<string | undefined>;
    getActiveThemeId(): string | undefined;
    setActiveThemeId(themeId?: string): void;
}

/**
 * UrlPatternDiscovery is a lightweight DiscoveryApi implementation.
 * It uses a single template string to construct URLs for each plugin.
 */
declare class UrlPatternDiscovery implements DiscoveryApi {
    private readonly parts;
    /**
     * Creates a new UrlPatternDiscovery given a template. The the only
     * interpolation done for the template is to replace instances of `{{pluginId}}`
     * with the ID of the plugin being requested.
     *
     * Example pattern: `http://localhost:7000/api/{{ pluginId }}`
     */
    static compile(pattern: string): UrlPatternDiscovery;
    private constructor();
    getBaseUrl(pluginId: string): Promise<string>;
}

/**
 * Decorates an ErrorApi by also forwarding error messages
 * to the alertApi with an 'error' severity.
 */
declare class ErrorAlerter implements ErrorApi {
    private readonly alertApi;
    private readonly errorApi;
    constructor(alertApi: AlertApi, errorApi: ErrorApi);
    post(error: Error, context?: ErrorContext): void;
    error$(): Observable$1<{
        error: {
            name: string;
            message: string;
            stack?: string | undefined;
        };
        context?: ErrorContext | undefined;
    }>;
}

/**
 * Base implementation for the ErrorApi that simply forwards errors to consumers.
 */
declare class ErrorApiForwarder implements ErrorApi {
    private readonly subject;
    post(error: Error, context?: ErrorContext): void;
    error$(): Observable<{
        error: Error;
        context?: ErrorContext;
    }>;
}

/**
 * Create the FeatureFlags implementation based on the API.
 */
declare class LocalStorageFeatureFlags implements FeatureFlagsApi {
    private registeredFeatureFlags;
    private flags?;
    registerFlag(flag: FeatureFlag): void;
    getRegisteredFlags(): FeatureFlag[];
    isActive(name: string): boolean;
    save(options: FeatureFlagsSaveOptions): void;
    private load;
}

/**
 * The OAuthRequestManager is an implementation of the OAuthRequestApi.
 *
 * The purpose of this class and the API is to read a stream of incoming requests
 * of OAuth access tokens from different providers with varying scope, and funnel
 * them all together into a single request for each OAuth provider.
 */
declare class OAuthRequestManager implements OAuthRequestApi {
    private readonly subject;
    private currentRequests;
    private handlerCount;
    createAuthRequester<T>(options: AuthRequesterOptions<T>): AuthRequester<T>;
    private makeAuthRequest;
    authRequest$(): Observable<PendingAuthRequest[]>;
}

declare class WebStorage implements StorageApi {
    private readonly namespace;
    private readonly errorApi;
    constructor(namespace: string, errorApi: ErrorApi);
    static create(options: CreateStorageApiOptions): WebStorage;
    get<T>(key: string): T | undefined;
    forBucket(name: string): WebStorage;
    set<T>(key: string, data: T): Promise<void>;
    remove(key: string): Promise<void>;
    observe$<T>(key: string): Observable<StorageValueChange<T>>;
    private getKeyName;
    private notifyChanges;
    private subscribers;
    private readonly observable;
}

declare type AnyParams = {
    [param in string]: string;
} | undefined;
declare type ParamKeys<Params extends AnyParams> = keyof Params extends never ? [] : (keyof Params)[];
declare type OptionalParams<Params extends {
    [param in string]: string;
}> = Params[keyof Params] extends never ? undefined : Params;
declare type RouteFunc<Params extends AnyParams> = (...[params]: Params extends undefined ? readonly [] : readonly [Params]) => string;
declare const routeRefType: unique symbol;
declare type RouteRef<Params extends AnyParams = any> = {
    readonly [routeRefType]: 'absolute';
    params: ParamKeys<Params>;
    /** @deprecated paths are no longer accessed directly from RouteRefs, use useRouteRef instead */
    path: string;
    /** @deprecated icons are no longer accessed via RouteRefs */
    icon?: IconComponent;
    /** @deprecated titles are no longer accessed via RouteRefs */
    title?: string;
};
declare type SubRouteRef<Params extends AnyParams = any> = {
    readonly [routeRefType]: 'sub';
    parent: RouteRef;
    path: string;
    params: ParamKeys<Params>;
};
declare type ExternalRouteRef<Params extends AnyParams = any, Optional extends boolean = any> = {
    readonly [routeRefType]: 'external';
    params: ParamKeys<Params>;
    optional?: Optional;
};
/** @deprecated */
declare type ConcreteRoute = {};
/** @deprecated */
declare type AbsoluteRouteRef = RouteRef<{}>;
/** @deprecated */
declare type MutableRouteRef = RouteRef<{}>;

declare function createExternalRouteRef<Params extends {
    [param in ParamKey]: string;
}, Optional extends boolean = false, ParamKey extends string = never>(options: {
    /**
     * An identifier for this route, used to identify it in error messages
     */
    id: string;
    /**
     * The parameters that will be provided to the external route reference.
     */
    params?: ParamKey[];
    /**
     * Whether or not this route is optional, defaults to false.
     *
     * Optional external routes are not required to be bound in the app, and
     * if they aren't, `useRouteRef` will return `undefined`.
     */
    optional?: Optional;
}): ExternalRouteRef<OptionalParams<Params>, Optional>;

declare type FlatRoutesProps = {
    children: ReactNode;
};
declare const FlatRoutes: (props: FlatRoutesProps) => JSX.Element | null;

declare function useRouteRef<Optional extends boolean, Params extends AnyParams>(routeRef: ExternalRouteRef<Params, Optional>): Optional extends true ? RouteFunc<Params> | undefined : RouteFunc<Params>;
declare function useRouteRef<Params extends AnyParams>(routeRef: RouteRef<Params> | SubRouteRef<Params>): RouteFunc<Params>;
declare function useRouteRefParams<Params extends AnyParams>(_routeRef: RouteRef<Params> | SubRouteRef<Params>): Params;

declare type RouteRefConfig<Params extends AnyParams> = {
    params?: ParamKeys<Params>;
    path?: string;
    icon?: IconComponent;
    title: string;
};
declare function createRouteRef<Params extends {
    [param in ParamKey]: string;
}, ParamKey extends string = never>(config: {
    /** The id of the route ref, used to identify it when printed */
    id?: string;
    /** A list of parameter names that the path that this route ref is bound to must contain */
    params?: ParamKey[];
    /** @deprecated Route refs no longer decide their own path */
    path?: string;
    /** @deprecated Route refs no longer decide their own icon */
    icon?: IconComponent;
    /** @deprecated Route refs no longer decide their own title */
    title?: string;
}): RouteRef<OptionalParams<Params>>;

declare type ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;
declare type ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}` ? ParamPart<Part> | ParamNames<Rest> : ParamPart<S>;
declare type PathParams<S extends string> = {
    [name in ParamNames<S>]: string;
};
/**
 * Merges a param object type with with an optional params type into a params object
 */
declare type MergeParams<P1 extends {
    [param in string]: string;
}, P2 extends AnyParams> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);
/**
 * Creates a SubRouteRef type given the desired parameters and parent route parameters.
 * The parameters types are merged together while ensuring that there is no overlap between the two.
 */
declare type MakeSubRouteRef<Params extends {
    [param in string]: string;
}, ParentParams extends AnyParams> = keyof Params & keyof ParentParams extends never ? SubRouteRef<OptionalParams<MergeParams<Params, ParentParams>>> : never;
declare function createSubRouteRef<Path extends string, ParentParams extends AnyParams = never>(config: {
    id: string;
    path: Path;
    parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

declare type RouteOptions = {
    exact?: boolean;
};
declare type RoutePath = string;
declare type LegacyRouteOutput = {
    type: 'legacy-route';
    path: RoutePath;
    component: ComponentType<{}>;
    options?: RouteOptions;
};
declare type RouteOutput = {
    type: 'route';
    target: RouteRef;
    component: ComponentType<{}>;
    options?: RouteOptions;
};
declare type RedirectRouteOutput = {
    type: 'redirect-route';
    from: RouteRef;
    to: RouteRef;
    options?: RouteOptions;
};
declare type LegacyRedirectRouteOutput = {
    type: 'legacy-redirect-route';
    path: RoutePath;
    target: RoutePath;
    options?: RouteOptions;
};
declare type FeatureFlagOutput = {
    type: 'feature-flag';
    name: string;
};
declare type PluginOutput = LegacyRouteOutput | RouteOutput | LegacyRedirectRouteOutput | RedirectRouteOutput | FeatureFlagOutput;
declare type Extension<T> = {
    expose(plugin: BackstagePlugin<any, any>): T;
};
declare type AnyRoutes = {
    [name: string]: RouteRef | SubRouteRef;
};
declare type AnyExternalRoutes = {
    [name: string]: ExternalRouteRef;
};
declare type BackstagePlugin<Routes extends AnyRoutes = {}, ExternalRoutes extends AnyExternalRoutes = {}> = {
    getId(): string;
    output(): PluginOutput[];
    getApis(): Iterable<AnyApiFactory>;
    provide<T>(extension: Extension<T>): T;
    routes: Routes;
    externalRoutes: ExternalRoutes;
};
declare type PluginConfig<Routes extends AnyRoutes, ExternalRoutes extends AnyExternalRoutes> = {
    id: string;
    apis?: Iterable<AnyApiFactory>;
    register?(hooks: PluginHooks): void;
    routes?: Routes;
    externalRoutes?: ExternalRoutes;
};
declare type PluginHooks = {
    /**
     * @deprecated All router hooks have been deprecated
     */
    router: RouterHooks;
    featureFlags: FeatureFlagsHooks;
};
declare type RouterHooks = {
    /**
     * @deprecated Use a routable extension instead, see https://backstage.io/docs/plugins/composability#porting-existing-plugins
     */
    addRoute(target: RouteRef, Component: ComponentType<any>, options?: RouteOptions): void;
};
declare type FeatureFlagsHooks = {
    register(name: string): void;
};

declare type BootErrorPageProps = {
    step: 'load-config' | 'load-chunk';
    error: Error;
};
declare type SignInResult = {
    /**
     * User ID that will be returned by the IdentityApi
     */
    userId: string;
    profile: ProfileInfo;
    /**
     * Function used to retrieve an ID token for the signed in user.
     */
    getIdToken?: () => Promise<string>;
    /**
     * Sign out handler that will be called if the user requests to sign out.
     */
    signOut?: () => Promise<void>;
};
declare type SignInPageProps = {
    /**
     * Set the sign-in result for the app. This should only be called once.
     */
    onResult(result: SignInResult): void;
};
declare type AppComponents = {
    NotFoundErrorPage: ComponentType<{}>;
    BootErrorPage: ComponentType<BootErrorPageProps>;
    Progress: ComponentType<{}>;
    Router: ComponentType<{}>;
    /**
     * An optional sign-in page that will be rendered instead of the AppRouter at startup.
     *
     * If a sign-in page is set, it will always be shown before the app, and it is up
     * to the sign-in page to handle e.g. saving of login methods for subsequent visits.
     *
     * The sign-in page will be displayed until it has passed up a result to the parent,
     * and which point the AppRouter and all of its children will be rendered instead.
     */
    SignInPage?: ComponentType<SignInPageProps>;
};
/**
 * A function that loads in the App config that will be accessible via the ConfigApi.
 *
 * If multiple config objects are returned in the array, values in the earlier configs
 * will override later ones.
 */
declare type AppConfigLoader = () => Promise<AppConfig[]>;
/**
 * Extracts a union of the keys in a map whose value extends the given type
 */
declare type KeysWithType<Obj extends {
    [key in string]: any;
}, Type> = {
    [key in keyof Obj]: Obj[key] extends Type ? key : never;
}[keyof Obj];
/**
 * Takes a map Map required values and makes all keys matching Keys optional
 */
declare type PartialKeys<Map extends {
    [name in string]: any;
}, Keys extends keyof Map> = Partial<Pick<Map, Keys>> & Required<Omit<Map, Keys>>;
/**
 * Creates a map of target routes with matching parameters based on a map of external routes.
 */
declare type TargetRouteMap<ExternalRoutes extends AnyExternalRoutes> = {
    [name in keyof ExternalRoutes]: ExternalRoutes[name] extends ExternalRouteRef<infer Params, any> ? RouteRef<Params> | SubRouteRef<Params> : never;
};
declare type AppRouteBinder = <ExternalRoutes extends AnyExternalRoutes>(externalRoutes: ExternalRoutes, targetRoutes: PartialKeys<TargetRouteMap<ExternalRoutes>, KeysWithType<ExternalRoutes, ExternalRouteRef<any, true>>>) => void;
declare type AppOptions = {
    /**
     * A collection of ApiFactories to register in the application to either
     * add add new ones, or override factories provided by default or by plugins.
     */
    apis?: Iterable<AnyApiFactory>;
    /**
     * Supply icons to override the default ones.
     */
    icons?: IconComponentMap;
    /**
     * A list of all plugins to include in the app.
     */
    plugins?: BackstagePlugin<any, any>[];
    /**
     * Supply components to the app to override the default ones.
     */
    components?: Partial<AppComponents>;
    /**
     * Themes provided as a part of the app. By default two themes are included, one
     * light variant of the default backstage theme, and one dark.
     *
     * This is the default config:
     *
     * ```
     * [{
     *   id: 'light',
     *   title: 'Light Theme',
     *   variant: 'light',
     *   theme: lightTheme,
     *   icon: <LightIcon />,
     * }, {
     *   id: 'dark',
     *   title: 'Dark Theme',
     *   variant: 'dark',
     *   theme: darkTheme,
     *   icon: <DarkIcon />,
     * }]
     * ```
     */
    themes?: AppTheme[];
    /**
     * A function that loads in App configuration that will be accessible via
     * the ConfigApi.
     *
     * Defaults to an empty config.
     *
     * TODO(Rugvip): Omitting this should instead default to loading in configuration
     *  that was packaged by the backstage-cli and default docker container boot script.
     */
    configLoader?: AppConfigLoader;
    /**
     * A function that is used to register associations between cross-plugin route
     * references, enabling plugins to navigate between each other.
     *
     * The `bind` function that is passed in should be used to bind all external
     * routes of all used plugins.
     *
     * ```ts
     * bindRoutes({ bind }) {
     *   bind(docsPlugin.externalRoutes, {
     *     homePage: managePlugin.routes.managePage,
     *   })
     *   bind(homePagePlugin.externalRoutes, {
     *     settingsPage: settingsPlugin.routes.settingsPage,
     *   })
     * }
     * ```
     */
    bindRoutes?(context: {
        bind: AppRouteBinder;
    }): void;
};
declare type BackstageApp = {
    /**
     * Returns all plugins registered for the app.
     */
    getPlugins(): BackstagePlugin<any, any>[];
    /**
     * Get a common or custom icon for this app.
     */
    getSystemIcon(key: IconKey): IconComponent | undefined;
    /**
     * Provider component that should wrap the Router created with getRouter()
     * and any other components that need to be within the app context.
     */
    getProvider(): ComponentType<{}>;
    /**
     * Router component that should wrap the App Routes create with getRoutes()
     * and any other components that should only be available while signed in.
     */
    getRouter(): ComponentType<{}>;
    /**
     * Routes component that contains all routes for plugin pages in the app.
     *
     * @deprecated Registering routes in plugins is deprecated and this method will be removed.
     */
    getRoutes(): JSX.Element[];
};
declare type AppContext = {
    /**
     * @deprecated Will be removed
     */
    getPlugins(): BackstagePlugin<any, any>[];
    /**
     * Get a common or custom icon for this app.
     */
    getSystemIcon(key: IconKey): IconComponent | undefined;
    /**
     * Get the components registered for various purposes in the app.
     */
    getComponents(): AppComponents;
    /**
     * @deprecated Will be removed
     */
    getProvider(): ComponentType<{}>;
    /**
     * @deprecated Will be removed
     */
    getRouter(): ComponentType<{}>;
    /**
     * @deprecated Will be removed
     */
    getRoutes(): JSX.Element[];
};

declare const useApp: () => AppContext;

declare function attachComponentData<P>(component: ComponentType<P>, type: string, data: unknown): void;
declare function getComponentData<T>(node: ReactNode, type: string): T | undefined;

declare type ComponentLoader<T> = {
    lazy: () => Promise<T>;
} | {
    sync: T;
};
declare function createRoutableExtension<T extends (props: any) => JSX.Element | null>(options: {
    component: () => Promise<T>;
    mountPoint: RouteRef;
}): Extension<T>;
declare function createComponentExtension<T extends (props: any) => JSX.Element | null>(options: {
    component: ComponentLoader<T>;
}): Extension<T>;
declare function createReactExtension<T extends (props: any) => JSX.Element | null>(options: {
    component: ComponentLoader<T>;
    data?: Record<string, unknown>;
}): Extension<T>;

declare const defaultSystemIcons: IconComponentMap;
declare const BrokenImageIcon: IconComponent;
declare const ChatIcon: IconComponent;
declare const DashboardIcon: IconComponent;
declare const EmailIcon: IconComponent;
declare const GitHubIcon: IconComponent;
declare const GroupIcon: IconComponent;
declare const HelpIcon: IconComponent;
declare const UserIcon: IconComponent;
declare const WarningIcon: IconComponent;
declare const DocsIcon: IconComponent;

declare function createPlugin<Routes extends AnyRoutes = {}, ExternalRoutes extends AnyExternalRoutes = {}>(config: PluginConfig<Routes, ExternalRoutes>): BackstagePlugin<Routes, ExternalRoutes>;

declare type FullAppOptions = {
    apis: Iterable<AnyApiFactory>;
    icons: IconComponentMap;
    plugins: BackstagePlugin<any, any>[];
    components: AppComponents;
    themes: AppTheme[];
    configLoader?: AppConfigLoader;
    defaultApis: Iterable<AnyApiFactory>;
    bindRoutes?: AppOptions['bindRoutes'];
};
declare class PrivateAppImpl implements BackstageApp {
    private apiHolder?;
    private configApi?;
    private readonly apis;
    private readonly icons;
    private readonly plugins;
    private readonly components;
    private readonly themes;
    private readonly configLoader?;
    private readonly defaultApis;
    private readonly bindRoutes;
    private readonly identityApi;
    constructor(options: FullAppOptions);
    getPlugins(): BackstagePlugin<any, any>[];
    getSystemIcon(key: IconKey): IconComponent | undefined;
    getComponents(): AppComponents;
    getRoutes(): JSX.Element[];
    getProvider(): ComponentType<{}>;
    getRouter(): ComponentType<{}>;
    private getApiHolder;
    /**
     * @deprecated
     */
    verify(): void;
    private verifyPlugins;
}

type privateExports_PrivateAppImpl = PrivateAppImpl;
declare const privateExports_PrivateAppImpl: typeof PrivateAppImpl;
declare namespace privateExports {
  export {
    privateExports_PrivateAppImpl as PrivateAppImpl,
  };
}

export default privateExports;
export { AbsoluteRouteRef, AlertApi, AlertApiForwarder, AlertMessage, AnyApiFactory, AnyApiRef, ApiFactory, ApiFactoryHolder, ApiFactoryRegistry, ApiHolder, ApiProvider, ApiRef, ApiRefType, ApiRefsToTypes, ApiRegistry, ApiResolver, AppComponents, AppConfigLoader, AppContext, AppOptions, AppRouteBinder, AppTheme, AppThemeApi, AppThemeSelector, Auth0Auth, AuthProvider, AuthRequestOptions, AuthRequester, AuthRequesterOptions, BackstageApp, BackstageIdentity, BackstageIdentityApi, BackstagePlugin, BootErrorPageProps, BrokenImageIcon, ChatIcon, ConcreteRoute, ConfigApi, CreateStorageApiOptions, DashboardIcon, DiscoveryApi, DocsIcon, EmailIcon, ErrorAlerter, ErrorApi, ErrorApiForwarder, ErrorContext, Extension, ExternalRouteRef, FeatureFlag, FeatureFlagOutput, FeatureFlagState, FeatureFlagsApi, FeatureFlagsHooks, FeatureFlagsSaveOptions, FlatRoutes, GitHubIcon, GithubAuth, GithubSession, GitlabAuth, GoogleAuth, GroupIcon, HelpIcon, IconComponent, IconComponentMap, IconKey, IdentityApi, LegacyRedirectRouteOutput, LegacyRouteOutput, LocalStorageFeatureFlags, MicrosoftAuth, MutableRouteRef, OAuth2, OAuth2Session, OAuthApi, OAuthRequestApi, OAuthRequestManager, OAuthScope, Observable, Observer, OktaAuth, OneLoginAuth, OpenIdConnectApi, PendingAuthRequest, PluginConfig, PluginHooks, PluginOutput, ProfileInfo, ProfileInfoApi, RedirectRouteOutput, RouteOptions, RouteOutput, RoutePath, RouteRef, RouteRefConfig, RouterHooks, SamlAuth, SessionApi, SessionState, SignInPageProps, SignInResult, StorageApi, StorageValueChange, SubRouteRef, Subscription, SystemIconKey, TypesToApiRefs, UrlPatternDiscovery, UserFlags, UserIcon, WarningIcon, WebStorage, alertApiRef, appThemeApiRef, attachComponentData, auth0AuthApiRef, configApiRef, createApiFactory, createApiRef, createComponentExtension, createExternalRouteRef, createPlugin, createReactExtension, createRoutableExtension, createRouteRef, createSubRouteRef, defaultSystemIcons, discoveryApiRef, errorApiRef, featureFlagsApiRef, getComponentData, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauth2ApiRef, oauthRequestApiRef, oidcAuthApiRef, oktaAuthApiRef, oneloginAuthApiRef, samlAuthApiRef, storageApiRef, useApi, useApiHolder, useApp, useRouteRef, useRouteRefParams };
