{"version":3,"file":"index.esm.js","sources":["../src/entity/constants.ts","../src/entity/policies/DefaultNamespaceEntityPolicy.ts","../src/validation/CommonValidatorFunctions.ts","../src/validation/ajv.ts","../src/validation/entityEnvelopeSchemaValidator.ts","../src/validation/entityKindSchemaValidator.ts","../src/validation/entitySchemaValidator.ts","../src/validation/KubernetesValidatorFunctions.ts","../src/validation/makeValidator.ts","../src/entity/policies/FieldFormatEntityPolicy.ts","../src/entity/policies/NoForeignRootFieldsEntityPolicy.ts","../src/entity/policies/SchemaValidEntityPolicy.ts","../src/entity/ref.ts","../src/entity/util.ts","../src/EntityPolicies.ts","../src/kinds/util.ts","../src/kinds/ApiEntityV1alpha1.ts","../src/kinds/ComponentEntityV1alpha1.ts","../src/kinds/DomainEntityV1alpha1.ts","../src/kinds/GroupEntityV1alpha1.ts","../src/kinds/LocationEntityV1alpha1.ts","../src/kinds/relations.ts","../src/kinds/ResourceEntityV1alpha1.ts","../src/kinds/SystemEntityV1alpha1.ts","../src/kinds/TemplateEntityV1alpha1.ts","../src/kinds/TemplateEntityV1beta2.ts","../src/kinds/UserEntityV1alpha1.ts","../src/location/annotation.ts","../src/location/helpers.ts","../src/location/validation.ts"],"sourcesContent":["/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The namespace that entities without an explicit namespace fall into.\n */\nexport const ENTITY_DEFAULT_NAMESPACE = 'default';\n\n/**\n * The keys of EntityMeta that are auto-generated.\n */\nexport const ENTITY_META_GENERATED_FIELDS = [\n  'uid',\n  'etag',\n  'generation',\n] as const;\n\n/**\n * Annotations for linking to entity from catalog pages.\n */\nexport const VIEW_URL_ANNOTATION = 'backstage.io/view-url';\nexport const EDIT_URL_ANNOTATION = 'backstage.io/edit-url';\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport lodash from 'lodash';\nimport { EntityPolicy } from './types';\nimport { ENTITY_DEFAULT_NAMESPACE } from '../constants';\nimport { Entity } from '../Entity';\n\n/**\n * Sets a default namespace if none was set.\n */\nexport class DefaultNamespaceEntityPolicy implements EntityPolicy {\n  private readonly namespace: string;\n\n  constructor(namespace: string = ENTITY_DEFAULT_NAMESPACE) {\n    this.namespace = namespace;\n  }\n\n  async enforce(entity: Entity): Promise<Entity> {\n    if (entity.metadata.namespace) {\n      return entity;\n    }\n\n    return lodash.merge({ metadata: { namespace: this.namespace } }, entity);\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport lodash from 'lodash';\n\n/**\n * Contains various helper validation and normalization functions that can be\n * composed to form a Validator.\n */\nexport class CommonValidatorFunctions {\n  /**\n   * Checks that the value is on the form <suffix> or <prefix><separator><suffix>, and validates\n   * those parts separately.\n   *\n   * @param value The value to check\n   * @param separator The separator between parts\n   * @param isValidPrefix Checks that the part before the separator is valid, if present\n   * @param isValidSuffix Checks that the part after the separator (or the entire value if there is no separator) is valid\n   */\n  static isValidPrefixAndOrSuffix(\n    value: unknown,\n    separator: string,\n    isValidPrefix: (value: string) => boolean,\n    isValidSuffix: (value: string) => boolean,\n  ): boolean {\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    const parts = value.split(separator);\n    if (parts.length === 1) {\n      return isValidSuffix(parts[0]);\n    } else if (parts.length === 2) {\n      return isValidPrefix(parts[0]) && isValidSuffix(parts[1]);\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks that the value can be safely transferred as JSON.\n   *\n   * @param value The value to check\n   */\n  static isJsonSafe(value: unknown): boolean {\n    try {\n      return lodash.isEqual(value, JSON.parse(JSON.stringify(value)));\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Checks that the value is a valid DNS subdomain name.\n   *\n   * @param value The value to check\n   * @see https://tools.ietf.org/html/rfc1123\n   */\n  static isValidDnsSubdomain(value: unknown): boolean {\n    return (\n      typeof value === 'string' &&\n      value.length >= 1 &&\n      value.length <= 253 &&\n      value.split('.').every(CommonValidatorFunctions.isValidDnsLabel)\n    );\n  }\n\n  /**\n   * Checks that the value is a valid DNS label.\n   *\n   * @param value The value to check\n   * @see https://tools.ietf.org/html/rfc1123\n   */\n  static isValidDnsLabel(value: unknown): boolean {\n    return (\n      typeof value === 'string' &&\n      value.length >= 1 &&\n      value.length <= 63 &&\n      /^[a-z0-9]+(\\-[a-z0-9]+)*$/.test(value)\n    );\n  }\n\n  /**\n   * Checks that the value is a valid URL.\n   *\n   * @param value The value to check\n   */\n  static isValidUrl(value: unknown): boolean {\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    try {\n      // eslint-disable-next-line no-new\n      new URL(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Checks that the value is a non empty string value.\n   *\n   * @param value The value to check\n   */\n  static isValidString(value: unknown): boolean {\n    return typeof value === 'string' && value?.trim()?.length >= 1;\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Ajv, { Schema, ValidateFunction } from 'ajv';\nimport entitySchema from '../schema/Entity.schema.json';\nimport entityEnvelopeSchema from '../schema/EntityEnvelope.schema.json';\nimport entityMetaSchema from '../schema/EntityMeta.schema.json';\nimport commonSchema from '../schema/shared/common.schema.json';\n\n// A local cache of compiled schemas, to avoid duplicate work.\n// The keys are JSON stringified versions of the schema\nconst compiledSchemaCache = new Map<string, ValidateFunction<unknown>>();\n\n// The core schemas that others can depend on\nconst refDependencyCandidates = [\n  entityEnvelopeSchema,\n  entitySchema,\n  entityMetaSchema,\n  commonSchema,\n];\n\nexport function throwAjvError(\n  errors: ValidateFunction<unknown>['errors'],\n): never {\n  if (!errors?.length) {\n    throw new TypeError('Unknown error');\n  }\n\n  const error = errors[0];\n  throw new TypeError(\n    `${error.dataPath || '<root>'} ${error.message}${\n      error.params\n        ? ` - ${Object.entries(error.params)\n            .map(([key, val]) => `${key}: ${val}`)\n            .join(', ')}`\n        : ''\n    }`,\n  );\n}\n\n// Compiles the given schema, and makes sure to also grab any core dependencies\n// that it depends on\nexport function compileAjvSchema(\n  schema: Schema,\n  options: { disableCache?: boolean } = {},\n): ValidateFunction<unknown> {\n  const disableCache = options?.disableCache ?? false;\n  const cacheKey = disableCache ? '' : JSON.stringify(schema);\n\n  if (!disableCache) {\n    const cached = compiledSchemaCache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n  }\n\n  const extraSchemas = getExtraSchemas(schema);\n  const ajv = new Ajv({\n    allowUnionTypes: true,\n    allErrors: true,\n    validateSchema: true,\n  });\n  if (extraSchemas.length) {\n    ajv.addSchema(extraSchemas, undefined, undefined, true);\n  }\n  const compiled = ajv.compile(schema);\n\n  if (!disableCache) {\n    compiledSchemaCache.set(cacheKey, compiled);\n  }\n\n  return compiled;\n}\n\n// Find refs in the given schema and recursively in all known schemas it\n// targets, collecting that list of schemas as we go\nfunction getExtraSchemas(schema: Schema): Schema[] {\n  if (typeof schema !== 'object') {\n    return [];\n  }\n\n  const seen = new Set<string>();\n  if (schema.$id) {\n    seen.add(schema.$id);\n  }\n\n  const selected = new Array<Schema>();\n\n  const todo: Schema[] = [schema];\n  while (todo.length) {\n    const current = todo.pop()!;\n\n    for (const ref of getAllRefs(current)) {\n      if (!seen.has(ref)) {\n        seen.add(ref);\n\n        const match = refDependencyCandidates.find(c => c.$id === ref);\n        if (match) {\n          selected.push(match);\n          todo.push(match);\n        }\n      }\n    }\n  }\n\n  return selected;\n}\n\n// Naively step through the entire schema looking for \"$ref\": \"x\" pairs. The\n// resulting iterator may contain duplicates. Ignores fragments, i.e. for a ref\n// of \"a#b\", it will just yield \"a\".\nfunction* getAllRefs(schema: Schema): Iterable<string> {\n  const todo: any[] = [schema];\n  while (todo.length) {\n    const current = todo.pop()!;\n    if (typeof current === 'object' && current) {\n      for (const [key, value] of Object.entries(current)) {\n        if (key === '$ref' && typeof value === 'string') {\n          yield value.split('#')[0];\n        } else {\n          todo.push(value);\n        }\n      }\n    }\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Schema } from 'ajv';\nimport { EntityEnvelope } from '../entity/EntityEnvelope';\nimport entityEnvelopeSchema from '../schema/EntityEnvelope.schema.json';\nimport { compileAjvSchema, throwAjvError } from './ajv';\n\n/**\n * Creates a validation function that takes some arbitrary data, and either\n * returns that data cast to an {@link EntityEnvelope} (or the given subtype)\n * if it matches that schema, or throws a {@link TypeError} describing the\n * errors.\n *\n * Note that this validator is only meant for applying the base schema checks;\n * it does not take custom policies or additional processor based validation\n * into account.\n *\n * By default, the plain `EntityEnvelope` schema is used. If you pass in your\n * own, it may contain `$ref` references to the following, which are resolved\n * automatically for you:\n *\n * - EntityEnvelope\n * - Entity\n * - EntityMeta\n * - common#<id>\n *\n * @see https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema\n */\nexport function entityEnvelopeSchemaValidator<\n  T extends EntityEnvelope = EntityEnvelope\n>(schema?: unknown): (data: unknown) => T {\n  const validate = compileAjvSchema(\n    schema ? (schema as Schema) : entityEnvelopeSchema,\n  );\n\n  return data => {\n    const result = validate(data);\n    if (result === true) {\n      return data as T;\n    }\n\n    throw throwAjvError(validate.errors);\n  };\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Schema } from 'ajv';\nimport { Entity } from '../entity';\nimport { compileAjvSchema, throwAjvError } from './ajv';\n\n/**\n * Creates a validation function that takes some arbitrary data, and either\n * returns that data cast to a `T` if it matches that schema, or `false` if the\n * schema apiVersion/kind didn't apply to that data, or throws a\n * {@link TypeError} describing actual errors.\n *\n * This validator is highly specialized, in that it has special treatment of\n * the `kind` and `apiVersion` root keys. This only works if your schema has\n * their rule set to `\"enum\"`:\n *\n * <pre>\n *   \"apiVersion\": {\n *      \"enum\": [\"backstage.io/v1alpha1\", \"backstage.io/v1beta1\"]\n *   },\n *   \"kind\": {\n *     \"enum\": [\"Group\"]\n *   },\n * </pre>\n *\n * In the above example, the created validator will return `false` if and only\n * if the kind and/or apiVersion mismatch.\n *\n * Note that this validator is only meant for applying the base schema checks;\n * it does not take custom policies or additional processor based validation\n * into account.\n *\n * The given schema may contain `$ref` references to the following, which are\n * resolved automatically for you:\n *\n * - EntityEnvelope\n * - Entity\n * - EntityMeta\n * - common#<id>\n *\n * @see https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema\n */\nexport function entityKindSchemaValidator<T extends Entity>(\n  schema: unknown,\n): (data: unknown) => T | false {\n  const validate = compileAjvSchema(schema as Schema);\n\n  return data => {\n    const result = validate(data);\n    if (result === true) {\n      return data as T;\n    }\n\n    // Only in the case where kind and/or apiVersion have enum mismatches AND\n    // have NO other errors, we call it a soft error.\n    const softCandidates = validate.errors?.filter(e =>\n      ['/kind', '/apiVersion'].includes(e.dataPath),\n    );\n    if (\n      softCandidates?.length &&\n      softCandidates.every(e => e.keyword === 'enum')\n    ) {\n      return false;\n    }\n\n    throw throwAjvError(validate.errors);\n  };\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Schema } from 'ajv';\nimport { Entity } from '../entity/Entity';\nimport entitySchema from '../schema/Entity.schema.json';\nimport { compileAjvSchema, throwAjvError } from './ajv';\n\n/**\n * Creates a validation function that takes some arbitrary data, and either\n * returns that data cast to an {@link Entity} (or the given subtype) if it\n * matches that schema, or throws a {@link TypeError} describing the errors.\n *\n * Note that this validator is only meant for applying the base schema checks;\n * it does not take custom policies or additional processor based validation\n * into account.\n *\n * By default, the plain `Entity` schema is used. If you pass in your own, it\n * may contain `$ref` references to the following, which are resolved\n * automatically for you:\n *\n * - EntityEnvelope\n * - Entity\n * - EntityMeta\n * - common#<id>\n *\n * @see https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema\n */\nexport function entitySchemaValidator<T extends Entity = Entity>(\n  schema?: unknown,\n): (data: unknown) => T {\n  const validate = compileAjvSchema(schema ? (schema as Schema) : entitySchema);\n\n  return data => {\n    const result = validate(data);\n    if (result === true) {\n      return data as T;\n    }\n\n    throw throwAjvError(validate.errors);\n  };\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CommonValidatorFunctions } from './CommonValidatorFunctions';\n\n/**\n * Contains validation functions that match the Kubernetes spec, usable to\n * build a catalog that is compatible with those rule sets.\n *\n * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/names/\n * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set\n * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set\n */\nexport class KubernetesValidatorFunctions {\n  static isValidApiVersion(value: unknown): boolean {\n    return CommonValidatorFunctions.isValidPrefixAndOrSuffix(\n      value,\n      '/',\n      CommonValidatorFunctions.isValidDnsSubdomain,\n      n => n.length >= 1 && n.length <= 63 && /^[a-z0-9A-Z]+$/.test(n),\n    );\n  }\n\n  static isValidKind(value: unknown): boolean {\n    return (\n      typeof value === 'string' &&\n      value.length >= 1 &&\n      value.length <= 63 &&\n      /^[a-zA-Z][a-z0-9A-Z]*$/.test(value)\n    );\n  }\n\n  static isValidObjectName(value: unknown): boolean {\n    return (\n      typeof value === 'string' &&\n      value.length >= 1 &&\n      value.length <= 63 &&\n      /^[a-z0-9A-Z]+([-_.][a-z0-9A-Z]+)*$/.test(value)\n    );\n  }\n\n  static isValidNamespace(value: unknown): boolean {\n    return CommonValidatorFunctions.isValidDnsLabel(value);\n  }\n\n  static isValidLabelKey(value: unknown): boolean {\n    return CommonValidatorFunctions.isValidPrefixAndOrSuffix(\n      value,\n      '/',\n      CommonValidatorFunctions.isValidDnsSubdomain,\n      KubernetesValidatorFunctions.isValidObjectName,\n    );\n  }\n\n  static isValidLabelValue(value: unknown): boolean {\n    return (\n      value === '' || KubernetesValidatorFunctions.isValidObjectName(value)\n    );\n  }\n\n  static isValidAnnotationKey(value: unknown): boolean {\n    return CommonValidatorFunctions.isValidPrefixAndOrSuffix(\n      value,\n      '/',\n      CommonValidatorFunctions.isValidDnsSubdomain,\n      KubernetesValidatorFunctions.isValidObjectName,\n    );\n  }\n\n  static isValidAnnotationValue(value: unknown): boolean {\n    return typeof value === 'string';\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CommonValidatorFunctions } from './CommonValidatorFunctions';\nimport { KubernetesValidatorFunctions } from './KubernetesValidatorFunctions';\nimport { Validators } from './types';\n\nconst defaultValidators: Validators = {\n  isValidApiVersion: KubernetesValidatorFunctions.isValidApiVersion,\n  isValidKind: KubernetesValidatorFunctions.isValidKind,\n  isValidEntityName: KubernetesValidatorFunctions.isValidObjectName,\n  isValidNamespace: KubernetesValidatorFunctions.isValidNamespace,\n  isValidLabelKey: KubernetesValidatorFunctions.isValidLabelKey,\n  isValidLabelValue: KubernetesValidatorFunctions.isValidLabelValue,\n  isValidAnnotationKey: KubernetesValidatorFunctions.isValidAnnotationKey,\n  isValidAnnotationValue: KubernetesValidatorFunctions.isValidAnnotationValue,\n  isValidTag: CommonValidatorFunctions.isValidDnsLabel,\n};\n\nexport function makeValidator(overrides: Partial<Validators> = {}): Validators {\n  return {\n    ...defaultValidators,\n    ...overrides,\n  };\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EntityPolicy } from './types';\nimport {\n  CommonValidatorFunctions,\n  KubernetesValidatorFunctions,\n  makeValidator,\n  Validators,\n} from '../../validation';\nimport { Entity } from '../Entity';\n\n/**\n * Ensures that the format of individual fields of the entity envelope\n * is valid.\n *\n * This does not take into account machine generated fields such as uid, etag\n * and generation.\n */\nexport class FieldFormatEntityPolicy implements EntityPolicy {\n  private readonly validators: Validators;\n\n  constructor(validators: Validators = makeValidator()) {\n    this.validators = validators;\n  }\n\n  async enforce(entity: Entity): Promise<Entity> {\n    function require(\n      field: string,\n      value: any,\n      validator: (value: any) => boolean,\n    ) {\n      if (value === undefined || value === null) {\n        throw new Error(`${field} must have a value`);\n      }\n\n      let isValid: boolean;\n      try {\n        isValid = validator(value);\n      } catch (e) {\n        throw new Error(`${field} could not be validated, ${e}`);\n      }\n\n      if (!isValid) {\n        let expectation;\n        switch (\n          validator.name as\n            | keyof typeof KubernetesValidatorFunctions\n            | keyof typeof CommonValidatorFunctions\n        ) {\n          case 'isValidLabelValue':\n          case 'isValidObjectName':\n            expectation =\n              'a string that is sequences of [a-zA-Z0-9] separated by any of [-_.], at most 63 characters in total';\n            break;\n          case 'isValidLabelKey':\n          case 'isValidApiVersion':\n          case 'isValidAnnotationKey':\n            expectation = 'a valid prefix and/or suffix';\n            break;\n          case 'isValidNamespace':\n          case 'isValidDnsLabel':\n            expectation =\n              'a string that is sequences of [a-z0-9] separated by [-], at most 63 characters in total';\n            break;\n          case 'isValidAnnotationValue':\n            expectation = 'a string';\n            break;\n          case 'isValidKind':\n            expectation =\n              'a string that is a sequence of [a-zA-Z][a-z0-9A-Z], at most 63 characters in total';\n            break;\n          case 'isValidUrl':\n            expectation = 'a string that is a valid url';\n            break;\n          case 'isValidString':\n            expectation = 'a non empty string';\n            break;\n          default:\n            expectation = undefined;\n            break;\n        }\n\n        // ensure that if there are other/future validators, the error message defaults to a general \"is not valid, visit link\"\n        const message = expectation\n          ? ` expected ${expectation} but found \"${value}\".`\n          : '';\n\n        throw new Error(\n          `\"${field}\" is not valid;${message} To learn more about catalog file format, visit: https://github.com/backstage/backstage/blob/master/docs/architecture-decisions/adr002-default-catalog-file-format.md`,\n        );\n      }\n    }\n\n    function optional(\n      field: string,\n      value: any,\n      validator: (value: any) => boolean,\n    ) {\n      return value === undefined || require(field, value, validator);\n    }\n\n    require('apiVersion', entity.apiVersion, this.validators.isValidApiVersion);\n    require('kind', entity.kind, this.validators.isValidKind);\n\n    require('metadata.name', entity.metadata.name, this.validators\n      .isValidEntityName);\n    optional(\n      'metadata.namespace',\n      entity.metadata.namespace,\n      this.validators.isValidNamespace,\n    );\n\n    for (const [k, v] of Object.entries(entity.metadata.labels ?? [])) {\n      require(`labels.${k}`, k, this.validators.isValidLabelKey);\n      require(`labels.${k}`, v, this.validators.isValidLabelValue);\n    }\n\n    for (const [k, v] of Object.entries(entity.metadata.annotations ?? [])) {\n      require(`annotations.${k}`, k, this.validators.isValidAnnotationKey);\n      require(`annotations.${k}`, v, this.validators.isValidAnnotationValue);\n    }\n\n    const tags = entity.metadata.tags ?? [];\n\n    for (let i = 0; i < tags.length; ++i) {\n      require(`tags.${i}`, tags[i], this.validators.isValidTag);\n    }\n\n    const links = entity.metadata.links ?? [];\n\n    for (let i = 0; i < links.length; ++i) {\n      require(`links.${i}.url`, links[i]\n        ?.url, CommonValidatorFunctions.isValidUrl);\n      optional(\n        `links.${i}.title`,\n        links[i]?.title,\n        CommonValidatorFunctions.isValidString,\n      );\n      optional(\n        `links.${i}.icon`,\n        links[i]?.icon,\n        KubernetesValidatorFunctions.isValidObjectName,\n      );\n    }\n\n    return entity;\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EntityPolicy } from './types';\nimport { Entity } from '../Entity';\n\nconst defaultKnownFields = ['apiVersion', 'kind', 'metadata', 'spec'];\n\n/**\n * Ensures that there are no foreign root fields in the entity.\n */\nexport class NoForeignRootFieldsEntityPolicy implements EntityPolicy {\n  private readonly knownFields: string[];\n\n  constructor(knownFields: string[] = defaultKnownFields) {\n    this.knownFields = knownFields;\n  }\n\n  async enforce(entity: Entity): Promise<Entity> {\n    for (const field of Object.keys(entity)) {\n      if (!this.knownFields.includes(field)) {\n        throw new Error(`Unknown field ${field}`);\n      }\n    }\n    return entity;\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Ajv, { ValidateFunction } from 'ajv';\nimport entitySchema from '../../schema/Entity.schema.json';\nimport entityMetaSchema from '../../schema/EntityMeta.schema.json';\nimport commonSchema from '../../schema/shared/common.schema.json';\nimport { Entity } from '../Entity';\nimport { EntityPolicy } from './types';\n\n/**\n * Ensures that the entity spec is valid according to a schema.\n *\n * This should be the first policy in the list, to ensure that other downstream\n * policies can work with a structure that is at least valid in therms of the\n * typescript type.\n */\nexport class SchemaValidEntityPolicy implements EntityPolicy {\n  private validate: ValidateFunction<Entity> | undefined;\n\n  async enforce(entity: Entity): Promise<Entity> {\n    if (!this.validate) {\n      const ajv = new Ajv({ allowUnionTypes: true });\n      this.validate = ajv\n        .addSchema([commonSchema, entityMetaSchema], undefined, undefined, true)\n        .compile<Entity>(entitySchema);\n    }\n\n    const result = this.validate(entity);\n    if (result === true) {\n      return entity;\n    }\n\n    const [error] = this.validate.errors || [];\n    if (!error) {\n      throw new Error(`Malformed envelope, Unknown error`);\n    }\n\n    throw new Error(\n      `Malformed envelope, ${error.dataPath || '<root>'} ${error.message}`,\n    );\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EntityName, EntityRef } from '../types';\nimport { ENTITY_DEFAULT_NAMESPACE } from './constants';\nimport { Entity } from './Entity';\n\nfunction parseRefString(\n  ref: string,\n): {\n  kind?: string;\n  namespace?: string;\n  name: string;\n} {\n  const match = /^([^:/]+:)?([^:/]+\\/)?([^:/]+)$/.exec(ref.trim());\n  if (!match) {\n    throw new TypeError(\n      `Entity reference \"${ref}\" was not on the form [<kind>:][<namespace>/]<name>`,\n    );\n  }\n\n  return {\n    kind: match[1]?.slice(0, -1),\n    namespace: match[2]?.slice(0, -1),\n    name: match[3],\n  };\n}\n\n/**\n * Extracts the kind, namespace and name that form the name triplet of the\n * given entity.\n *\n * @param entity An entity\n * @returns The complete entity name\n */\nexport function getEntityName(entity: Entity): EntityName {\n  return {\n    kind: entity.kind,\n    namespace: entity.metadata.namespace || ENTITY_DEFAULT_NAMESPACE,\n    name: entity.metadata.name,\n  };\n}\n\n/**\n * The context of defaults that entity reference parsing happens within.\n */\ntype EntityRefContext = {\n  /** The default kind, if none is given in the reference */\n  defaultKind?: string;\n  /** The default namespace, if none is given in the reference */\n  defaultNamespace?: string;\n};\n\n/**\n * Parses an entity reference, either on string or compound form, and always\n * returns a complete entity name including kind, namespace and name.\n *\n * This function automatically assumes the default namespace \"default\" unless\n * otherwise specified as part of the options, and will throw an error if no\n * kind was specified in the input reference and no default kind was given.\n *\n * @param ref The reference to parse\n * @param context The context of defaults that the parsing happens within\n * @returns A complete entity name\n */\nexport function parseEntityName(\n  ref: EntityRef,\n  context: EntityRefContext = {},\n): EntityName {\n  const { kind, namespace, name } = parseEntityRef(ref, {\n    defaultNamespace: ENTITY_DEFAULT_NAMESPACE,\n    ...context,\n  });\n\n  if (!kind) {\n    throw new Error(\n      `Entity reference ${namespace}/${name} did not contain a kind`,\n    );\n  }\n\n  return { kind, namespace, name };\n}\n\n/**\n * Parses an entity reference, either on string or compound form, and returns\n * a structure with a name, and optional kind and namespace.\n *\n * The options object can contain default values for the kind and namespace,\n * that will be used if the input reference did not specify any.\n *\n * @param ref The reference to parse\n * @param context The context of defaults that the parsing happens within\n * @returns The compound form of the reference\n */\nexport function parseEntityRef(\n  ref: EntityRef,\n  context?: { defaultKind: string; defaultNamespace: string },\n): {\n  kind: string;\n  namespace: string;\n  name: string;\n};\nexport function parseEntityRef(\n  ref: EntityRef,\n  context?: { defaultKind: string },\n): {\n  kind: string;\n  namespace?: string;\n  name: string;\n};\nexport function parseEntityRef(\n  ref: EntityRef,\n  context?: { defaultNamespace: string },\n): {\n  kind?: string;\n  namespace: string;\n  name: string;\n};\nexport function parseEntityRef(\n  ref: EntityRef,\n  context: EntityRefContext = {},\n): {\n  kind?: string;\n  namespace?: string;\n  name: string;\n} {\n  if (!ref) {\n    throw new Error(`Entity reference must not be empty`);\n  }\n\n  if (typeof ref === 'string') {\n    const parsed = parseRefString(ref);\n    return {\n      kind: parsed.kind ?? context.defaultKind,\n      namespace: parsed.namespace ?? context.defaultNamespace,\n      name: parsed.name,\n    };\n  }\n\n  const { kind, namespace, name } = ref;\n  if (kind === '') {\n    throw new Error('Entity reference kinds must not be empty');\n  } else if (namespace === '') {\n    throw new Error('Entity reference namespaces must not be empty');\n  } else if (!name) {\n    throw new Error('Entity references must contain a name');\n  }\n\n  return {\n    kind: kind ?? context.defaultKind,\n    namespace: namespace ?? context.defaultNamespace,\n    name,\n  };\n}\n\n/**\n * Takes an entity reference or name, and outputs an entity reference on the\n * most compact form possible. I.e. if the parts do not contain any\n * special/reserved characters, it outputs the string form, otherwise it\n * outputs the compound form.\n *\n * @deprecated Use `stringifyEntityRef` instead\n * @param ref The reference to serialize\n * @returns The same reference on either string or compound form\n */\nexport function serializeEntityRef(\n  ref:\n    | Entity\n    | {\n        kind?: string;\n        namespace?: string;\n        name: string;\n      },\n): EntityRef {\n  let kind;\n  let namespace;\n  let name;\n\n  if ('metadata' in ref) {\n    kind = ref.kind;\n    namespace = ref.metadata.namespace;\n    name = ref.metadata.name;\n  } else {\n    kind = ref.kind;\n    namespace = ref.namespace;\n    name = ref.name;\n  }\n\n  if (\n    kind?.includes(':') ||\n    kind?.includes('/') ||\n    namespace?.includes(':') ||\n    namespace?.includes('/') ||\n    name.includes(':') ||\n    name.includes('/')\n  ) {\n    return { kind, namespace, name };\n  }\n\n  return `${kind ? `${kind}:` : ''}${namespace ? `${namespace}/` : ''}${name}`;\n}\n\n/**\n * Takes an entity or entity name/reference, and returns the string form of an\n * entity ref.\n *\n * This function creates a canonical and unique reference to the entity, converting\n * all parts of the name to lowercase and inserts the default namespace if needed.\n * It is typically not the best way to represent the entity reference to the user.\n *\n * @param ref The reference to serialize\n * @returns The same reference on either string or compound form\n */\nexport function stringifyEntityRef(\n  ref: Entity | { kind: string; namespace?: string; name: string },\n): string {\n  let kind;\n  let namespace;\n  let name;\n\n  if ('metadata' in ref) {\n    kind = ref.kind;\n    namespace = ref.metadata.namespace ?? ENTITY_DEFAULT_NAMESPACE;\n    name = ref.metadata.name;\n  } else {\n    kind = ref.kind;\n    namespace = ref.namespace ?? ENTITY_DEFAULT_NAMESPACE;\n    name = ref.name;\n  }\n\n  return `${kind.toLowerCase()}:${namespace.toLowerCase()}/${name.toLowerCase()}`;\n}\n\n/**\n * Compares an entity to either a string reference or a compound reference.\n *\n * The comparison is case insensitive, and all of kind, namespace, and name\n * must match (after applying the optional context to the ref).\n *\n * @param entity The entity to match\n * @param ref A string or compound entity ref\n * @param context An optional context of default kind and namespace, that apply\n *                to the ref if given\n * @returns True if matching, false otherwise\n */\nexport function compareEntityToRef(\n  entity: Entity,\n  ref: EntityRef | EntityName,\n  context?: EntityRefContext,\n): boolean {\n  const entityKind = entity.kind;\n  const entityNamespace = entity.metadata.namespace || ENTITY_DEFAULT_NAMESPACE;\n  const entityName = entity.metadata.name;\n\n  let refKind: string | undefined;\n  let refNamespace: string | undefined;\n  let refName: string;\n  if (typeof ref === 'string') {\n    const parsed = parseRefString(ref);\n    refKind = parsed.kind || context?.defaultKind;\n    refNamespace =\n      parsed.namespace || context?.defaultNamespace || ENTITY_DEFAULT_NAMESPACE;\n    refName = parsed.name;\n  } else {\n    refKind = ref.kind || context?.defaultKind;\n    refNamespace =\n      ref.namespace || context?.defaultNamespace || ENTITY_DEFAULT_NAMESPACE;\n    refName = ref.name;\n  }\n\n  if (!refKind || !refNamespace) {\n    throw new Error(\n      `Entity reference or context did not contain kind and namespace`,\n    );\n  }\n\n  return (\n    entityKind.toLowerCase() === refKind.toLowerCase() &&\n    entityNamespace.toLowerCase() === refNamespace.toLowerCase() &&\n    entityName.toLowerCase() === refName.toLowerCase()\n  );\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport lodash from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Entity } from './Entity';\n\n/**\n * Generates a new random UID for an entity.\n *\n * @returns A string with enough randomness to uniquely identify an entity\n */\nexport function generateEntityUid(): string {\n  return uuidv4();\n}\n\n/**\n * Generates a new random Etag for an entity.\n *\n * @returns A string with enough randomness to uniquely identify an entity\n *          revision\n */\nexport function generateEntityEtag(): string {\n  return Buffer.from(uuidv4(), 'utf8').toString('base64').replace(/[^\\w]/g, '');\n}\n\n/**\n * Checks whether there are any significant changes going from the previous to\n * the next version of this entity.\n *\n * Significance, in this case, means that we do not compare generated fields\n * such as uid, etag and generation.\n *\n * Note that this comparison does NOT take status, relations or similar into\n * account. It only compares the actual input entity data, i.e. metadata and\n * spec.\n *\n * @param previous The old state of the entity\n * @param next The new state of the entity\n */\nexport function entityHasChanges(previous: Entity, next: Entity): boolean {\n  const e1 = lodash.cloneDeep(previous);\n  const e2 = lodash.cloneDeep(next);\n\n  if (!e1.metadata.labels) {\n    e1.metadata.labels = {};\n  }\n  if (!e2.metadata.labels) {\n    e2.metadata.labels = {};\n  }\n  if (!e1.metadata.annotations) {\n    e1.metadata.annotations = {};\n  }\n  if (!e2.metadata.annotations) {\n    e2.metadata.annotations = {};\n  }\n  if (!e1.metadata.tags) {\n    e1.metadata.tags = [];\n  }\n  if (!e2.metadata.tags) {\n    e2.metadata.tags = [];\n  }\n\n  // Remove generated fields\n  delete e1.metadata.uid;\n  delete e1.metadata.etag;\n  delete e1.metadata.generation;\n  delete e2.metadata.uid;\n  delete e2.metadata.etag;\n  delete e2.metadata.generation;\n\n  // Remove things that we explicitly do not compare\n  delete e1.relations;\n  delete e1.status;\n  delete e2.relations;\n  delete e2.status;\n\n  return !lodash.isEqual(e1, e2);\n}\n\n/**\n * Takes an old revision of an entity and a new desired state, and merges\n * them into a complete new state.\n *\n * The previous revision is expected to be a complete model loaded from the\n * catalog, including the uid, etag and generation fields.\n *\n * @param previous The old state of the entity\n * @param next The new state of the entity\n * @returns An entity with the merged state of both\n */\nexport function generateUpdatedEntity(previous: Entity, next: Entity): Entity {\n  const { uid, etag, generation } = previous.metadata;\n  if (!uid || !etag || !generation) {\n    throw new Error('Previous entity must have uid, etag and generation');\n  }\n\n  const result = lodash.cloneDeep(next);\n\n  // Generated fields are copied and updated\n  const bumpEtag = entityHasChanges(previous, result);\n  const bumpGeneration = !lodash.isEqual(previous.spec, result.spec);\n  result.metadata.uid = uid;\n  result.metadata.etag = bumpEtag ? generateEntityEtag() : etag;\n  result.metadata.generation = bumpGeneration ? generation + 1 : generation;\n\n  return result;\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity, EntityPolicy } from './entity';\n\n// Helper that requires that all of a set of policies can be successfully\n// applied\nclass AllEntityPolicies implements EntityPolicy {\n  constructor(private readonly policies: EntityPolicy[]) {}\n\n  async enforce(entity: Entity): Promise<Entity> {\n    let result = entity;\n    for (const policy of this.policies) {\n      const output = await policy.enforce(result);\n      if (!output) {\n        throw new Error(\n          `Policy ${policy.constructor.name} did not return a result`,\n        );\n      }\n      result = output;\n    }\n    return result;\n  }\n}\n\n// Helper that requires that at least one of a set of policies can be\n// successfully applied\nclass AnyEntityPolicy implements EntityPolicy {\n  constructor(private readonly policies: EntityPolicy[]) {}\n\n  async enforce(entity: Entity): Promise<Entity> {\n    for (const policy of this.policies) {\n      const output = await policy.enforce(entity);\n      if (output) {\n        return output;\n      }\n    }\n    throw new Error(`The entity did not match any known policy`);\n  }\n}\n\nexport const EntityPolicies = {\n  allOf(policies: EntityPolicy[]) {\n    return new AllEntityPolicies(policies);\n  },\n  oneOf(policies: EntityPolicy[]) {\n    return new AnyEntityPolicy(policies);\n  },\n};\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { entityKindSchemaValidator } from '../validation';\nimport { KindValidator } from './types';\n\n// TODO(freben): Left here as a compatibility helper. It would be nicer to\n// just export the inner validator directly. However, all of the already\n// exported kind validators have the `KindValidator` signature which is\n// different. So let's postpone that change until a later time.\nexport function ajvCompiledJsonSchemaValidator(schema: unknown): KindValidator {\n  const validator = entityKindSchemaValidator(schema);\n  return {\n    async check(data) {\n      return validator(data) === data;\n    },\n  };\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/API.v1alpha1.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface ApiEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'API';\n  spec: {\n    type: string;\n    lifecycle: string;\n    owner: string;\n    definition: string;\n    system?: string;\n  };\n}\n\nexport const apiEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/Component.v1alpha1.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface ComponentEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'Component';\n  spec: {\n    type: string;\n    lifecycle: string;\n    owner: string;\n    subcomponentOf?: string;\n    providesApis?: string[];\n    consumesApis?: string[];\n    dependsOn?: string[];\n    system?: string;\n  };\n}\n\nexport const componentEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/Domain.v1alpha1.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface DomainEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'Domain';\n  spec: {\n    owner: string;\n  };\n}\n\nexport const domainEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/Group.v1alpha1.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface GroupEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'Group';\n  spec: {\n    type: string;\n    profile?: {\n      displayName?: string;\n      email?: string;\n      picture?: string;\n    };\n    parent?: string;\n    children: string[];\n    members?: string[];\n  };\n}\n\nexport const groupEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/Location.v1alpha1.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface LocationEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'Location';\n  spec: {\n    type?: string;\n    target?: string;\n    targets?: string[];\n  };\n}\n\nexport const locationEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\nNaming rules for relations in priority order:\n\n1. Use at most two words. One main verb and a specifier, e.g. \"ownerOf\"\n2. Reading out \"<source-kind> <type> <target-kind>\" should make sense in English.\n3. Maintain symmetry between pairs, e.g. \"ownedBy\" and \"ownerOf\" rather than \"owns\".\n*/\n\n/**\n * An ownership relation where the owner is usually an organizational\n * entity (user or group), and the other entity can be anything.\n */\nexport const RELATION_OWNED_BY = 'ownedBy';\nexport const RELATION_OWNER_OF = 'ownerOf';\n\n/**\n * A relation with an API entity, typically from a component\n */\nexport const RELATION_CONSUMES_API = 'consumesApi';\nexport const RELATION_API_CONSUMED_BY = 'apiConsumedBy';\nexport const RELATION_PROVIDES_API = 'providesApi';\nexport const RELATION_API_PROVIDED_BY = 'apiProvidedBy';\n\n/**\n * A relation denoting a dependency on another entity.\n */\nexport const RELATION_DEPENDS_ON = 'dependsOn';\nexport const RELATION_DEPENDENCY_OF = 'dependencyOf';\n\n/**\n * A parent/child relation to build up a tree, used for example to describe\n * the organizational structure between groups.\n */\nexport const RELATION_PARENT_OF = 'parentOf';\nexport const RELATION_CHILD_OF = 'childOf';\n\n/**\n * A membership relation, typically for users in a group.\n */\nexport const RELATION_MEMBER_OF = 'memberOf';\nexport const RELATION_HAS_MEMBER = 'hasMember';\n\n/**\n * A part/whole relation, typically for components in a system and systems\n * in a domain.\n */\nexport const RELATION_PART_OF = 'partOf';\nexport const RELATION_HAS_PART = 'hasPart';\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/Resource.v1alpha1.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface ResourceEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'Resource';\n  spec: {\n    type: string;\n    owner: string;\n    dependsOn?: string[];\n    system?: string;\n  };\n}\n\nexport const resourceEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/System.v1alpha1.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface SystemEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'System';\n  spec: {\n    owner: string;\n    domain?: string;\n  };\n}\n\nexport const systemEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/Template.v1alpha1.schema.json';\nimport type { JSONSchema } from '../types';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface TemplateEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'Template';\n  spec: {\n    type: string;\n    templater: string;\n    path?: string;\n    schema: JSONSchema;\n    owner?: string;\n  };\n}\n\nexport const templateEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject } from '@backstage/config';\nimport type { Entity, EntityMeta } from '../entity/Entity';\nimport schema from '../schema/kinds/Template.v1beta2.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface TemplateEntityV1beta2 extends Entity {\n  apiVersion: 'backstage.io/v1beta2';\n  kind: 'Template';\n  metadata: EntityMeta & {\n    title?: string;\n  };\n  spec: {\n    type: string;\n    parameters?: JsonObject | JsonObject[];\n    steps: Array<{\n      id?: string;\n      name?: string;\n      action: string;\n      input?: JsonObject;\n    }>;\n    output?: { [name: string]: string };\n    owner?: string;\n  };\n}\n\nexport const templateEntityV1beta2Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Entity } from '../entity/Entity';\nimport schema from '../schema/kinds/User.v1alpha1.schema.json';\nimport { ajvCompiledJsonSchemaValidator } from './util';\n\nexport interface UserEntityV1alpha1 extends Entity {\n  apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';\n  kind: 'User';\n  spec: {\n    profile?: {\n      displayName?: string;\n      email?: string;\n      picture?: string;\n    };\n    memberOf: string[];\n  };\n}\n\nexport const userEntityV1alpha1Validator = ajvCompiledJsonSchemaValidator(\n  schema,\n);\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const LOCATION_ANNOTATION = 'backstage.io/managed-by-location';\nexport const ORIGIN_LOCATION_ANNOTATION =\n  'backstage.io/managed-by-origin-location';\n\nexport const SOURCE_LOCATION_ANNOTATION = 'backstage.io/source-location';\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity, stringifyEntityRef } from '../entity';\nimport { LOCATION_ANNOTATION, SOURCE_LOCATION_ANNOTATION } from './annotation';\n\n/**\n * Parses a string form location reference.\n *\n * Note that the return type is not `LocationSpec`, because we do not want to\n * conflate the string form with the additional properties of that type.\n *\n * @param ref A string-form location reference, e.g. 'url:https://host'\n * @returns A location reference, e.g. { type: 'url', target: 'https://host' }\n */\nexport function parseLocationReference(\n  ref: string,\n): { type: string; target: string } {\n  if (typeof ref !== 'string') {\n    throw new TypeError(\n      `Unable to parse location reference '${ref}', unexpected argument ${typeof ref}`,\n    );\n  }\n\n  const splitIndex = ref.indexOf(':');\n  if (splitIndex < 0) {\n    throw new TypeError(\n      `Unable to parse location reference '${ref}', expected '<type>:<target>', e.g. 'url:https://host/path'`,\n    );\n  }\n\n  const type = ref.substr(0, splitIndex).trim();\n  const target = ref.substr(splitIndex + 1).trim();\n\n  if (!type || !target) {\n    throw new TypeError(\n      `Unable to parse location reference '${ref}', expected '<type>:<target>', e.g. 'url:https://host/path'`,\n    );\n  }\n\n  if (type === 'http' || type === 'https') {\n    throw new TypeError(\n      `Invalid location reference '${ref}', please prefix it with 'url:', e.g. 'url:${ref}'`,\n    );\n  }\n\n  return { type, target };\n}\n\n/**\n * Turns a location reference into its string form.\n *\n * Note that the input type is not `LocationSpec`, because we do not want to\n * conflate the string form with the additional properties of that type.\n *\n * @param ref A location reference, e.g. { type: 'url', target: 'https://host' }\n * @returns A string-form location reference, e.g. 'url:https://host'\n */\nexport function stringifyLocationReference(ref: {\n  type: string;\n  target: string;\n}): string {\n  const { type, target } = ref;\n\n  if (!type) {\n    throw new TypeError(`Unable to stringify location reference, empty type`);\n  } else if (!target) {\n    throw new TypeError(`Unable to stringify location reference, empty target`);\n  }\n\n  return `${type}:${target}`;\n}\n\n/**\n * Returns the source code location of the Entity, to the extent that one exists.\n *\n * If the returned location type is of type 'url', the target should be readable at least\n * using the UrlReader from @backstage/backend-common. If it is not of type 'url', the caller\n * needs to have explicit handling of each location type or signal that it is not supported.\n */\nexport function getEntitySourceLocation(\n  entity: Entity,\n): { type: string; target: string } {\n  const locationRef =\n    entity.metadata?.annotations?.[SOURCE_LOCATION_ANNOTATION] ??\n    entity.metadata?.annotations?.[LOCATION_ANNOTATION];\n\n  if (!locationRef) {\n    throw new Error(\n      `Entity '${stringifyEntityRef(entity)}' is missing location`,\n    );\n  }\n\n  return parseLocationReference(locationRef);\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as yup from 'yup';\nimport { LocationSpec, Location } from './types';\n\nexport const locationSpecSchema = yup\n  .object<LocationSpec>({\n    type: yup.string().required(),\n    target: yup.string().required(),\n    presence: yup.string(),\n  })\n  .noUnknown()\n  .required();\n\nexport const locationSchema = yup\n  .object<Location>({\n    id: yup.string().required(),\n    type: yup.string().required(),\n    target: yup.string().required(),\n  })\n  .noUnknown()\n  .required();\n\nexport const analyzeLocationSchema = yup\n  .object<{ location: LocationSpec }>({\n    location: locationSpecSchema,\n  })\n  .noUnknown()\n  .required();\n"],"names":["uuidv4","schema","yup.object","yup.string"],"mappings":"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"}