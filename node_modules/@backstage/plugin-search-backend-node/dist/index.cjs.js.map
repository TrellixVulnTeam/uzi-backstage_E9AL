{"version":3,"file":"index.cjs.js","sources":["../src/IndexBuilder.ts","../src/Scheduler.ts","../src/engines/LunrSearchEngine.ts"],"sourcesContent":["/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DocumentCollator, DocumentDecorator } from '@backstage/search-common';\nimport { Logger } from 'winston';\nimport { Scheduler } from './index';\nimport {\n  RegisterCollatorParameters,\n  RegisterDecoratorParameters,\n  SearchEngine,\n} from './types';\n\ninterface CollatorEnvelope {\n  collate: DocumentCollator;\n  refreshInterval: number;\n}\n\ntype IndexBuilderOptions = {\n  searchEngine: SearchEngine;\n  logger: Logger;\n};\n\nexport class IndexBuilder {\n  private collators: Record<string, CollatorEnvelope>;\n  private decorators: Record<string, DocumentDecorator[]>;\n  private searchEngine: SearchEngine;\n  private logger: Logger;\n\n  constructor({ logger, searchEngine }: IndexBuilderOptions) {\n    this.collators = {};\n    this.decorators = {};\n    this.logger = logger;\n    this.searchEngine = searchEngine;\n  }\n\n  getSearchEngine(): SearchEngine {\n    return this.searchEngine;\n  }\n\n  /**\n   * Makes the index builder aware of a collator that should be executed at the\n   * given refresh interval.\n   */\n  addCollator({\n    type,\n    collator,\n    defaultRefreshIntervalSeconds,\n  }: RegisterCollatorParameters): void {\n    this.logger.info(\n      `Added ${collator.constructor.name} collator for type ${type}`,\n    );\n    this.collators[type] = {\n      refreshInterval: defaultRefreshIntervalSeconds,\n      collate: collator,\n    };\n  }\n\n  /**\n   * Makes the index builder aware of a decorator. If no types are provided, it\n   * will be applied to documents from all known collators, otherwise it will\n   * only be applied to documents of the given types.\n   */\n  addDecorator({\n    types = ['*'],\n    decorator,\n  }: RegisterDecoratorParameters): void {\n    this.logger.info(\n      `Added decorator ${decorator.constructor.name} to types ${types.join(\n        ', ',\n      )}`,\n    );\n    types.forEach(type => {\n      if (this.decorators.hasOwnProperty(type)) {\n        this.decorators[type].push(decorator);\n      } else {\n        this.decorators[type] = [decorator];\n      }\n    });\n  }\n\n  /**\n   * Compiles collators and decorators into tasks, which are added to a\n   * scheduler returned to the caller.\n   */\n  async build(): Promise<{ scheduler: Scheduler }> {\n    const scheduler = new Scheduler({ logger: this.logger });\n\n    Object.keys(this.collators).forEach(type => {\n      scheduler.addToSchedule(async () => {\n        // Collate, Decorate, Index.\n        const decorators: DocumentDecorator[] = (\n          this.decorators['*'] || []\n        ).concat(this.decorators[type] || []);\n\n        this.logger.debug(\n          `Collating documents for ${type} via ${this.collators[type].collate.constructor.name}`,\n        );\n        let documents = await this.collators[type].collate.execute();\n        for (let i = 0; i < decorators.length; i++) {\n          this.logger.debug(\n            `Decorating ${type} documents via ${decorators[i].constructor.name}`,\n          );\n          documents = await decorators[i].execute(documents);\n        }\n\n        if (!documents || documents.length === 0) {\n          this.logger.debug(`No documents for type \"${type}\" to index`);\n          return;\n        }\n\n        // pushing documents to index to a configured search engine.\n        this.searchEngine.index(type, documents);\n      }, this.collators[type].refreshInterval * 1000);\n    });\n\n    return {\n      scheduler,\n    };\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from 'winston';\n\ntype TaskEnvelope = {\n  task: Function;\n  interval: number;\n};\n\n/**\n * TODO: coordination, error handling\n */\n\nexport class Scheduler {\n  private logger: Logger;\n  private schedule: TaskEnvelope[];\n  private intervalTimeouts: NodeJS.Timeout[] = [];\n\n  constructor({ logger }: { logger: Logger }) {\n    this.logger = logger;\n    this.schedule = [];\n  }\n\n  /**\n   * Adds each task and interval to the schedule\n   *\n   */\n  addToSchedule(task: Function, interval: number) {\n    if (this.intervalTimeouts.length) {\n      throw new Error(\n        'Cannot add task to schedule that has already been started.',\n      );\n    }\n    this.schedule.push({ task, interval });\n  }\n\n  /**\n   * Starts the scheduling process for each task\n   */\n  start() {\n    this.logger.info('Starting all scheduled search tasks.');\n    this.schedule.forEach(({ task, interval }) => {\n      this.intervalTimeouts.push(\n        setInterval(() => {\n          task();\n        }, interval),\n      );\n    });\n  }\n\n  /**\n   * Stop all scheduled tasks.\n   */\n  stop() {\n    this.logger.info('Stopping all scheduled search tasks.');\n    this.intervalTimeouts.forEach(timeout => {\n      clearInterval(timeout);\n    });\n    this.intervalTimeouts = [];\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  SearchQuery,\n  IndexableDocument,\n  SearchResultSet,\n} from '@backstage/search-common';\nimport lunr from 'lunr';\nimport { Logger } from 'winston';\nimport { SearchEngine, QueryTranslator } from '../types';\n\ntype ConcreteLunrQuery = {\n  lunrQueryString: string;\n  documentTypes: string[];\n};\n\nexport class LunrSearchEngine implements SearchEngine {\n  protected lunrIndices: Record<string, lunr.Index> = {};\n  protected docStore: Record<string, IndexableDocument>;\n  protected logger: Logger;\n\n  constructor({ logger }: { logger: Logger }) {\n    this.logger = logger;\n    this.docStore = {};\n  }\n\n  translator: QueryTranslator = ({\n    term,\n    filters,\n    types,\n  }: SearchQuery): ConcreteLunrQuery => {\n    let lunrQueryFilters;\n    if (filters) {\n      lunrQueryFilters = Object.entries(filters)\n        .map(([key, value]) => ` +${key}:${value}`)\n        .join('');\n    }\n\n    return {\n      lunrQueryString: `${term}${lunrQueryFilters || ''}`,\n      documentTypes: types || ['*'],\n    };\n  };\n\n  index(type: string, documents: IndexableDocument[]): void {\n    const lunrBuilder = new lunr.Builder();\n    // Make this lunr index aware of all relevant fields.\n    Object.keys(documents[0]).forEach(field => {\n      lunrBuilder.field(field);\n    });\n\n    // Set \"location\" field as reference field\n    lunrBuilder.ref('location');\n\n    documents.forEach((document: IndexableDocument) => {\n      // Add document to Lunar index\n      lunrBuilder.add(document);\n      // Store documents in memory to be able to look up document using the ref during query time\n      // This is not how you should implement your SearchEngine implementation! Do not copy!\n      this.docStore[document.location] = document;\n    });\n\n    // \"Rotate\" the index by simply overwriting any existing index of the same name.\n    this.lunrIndices[type] = lunrBuilder.build();\n  }\n\n  query(query: SearchQuery): Promise<SearchResultSet> {\n    const { lunrQueryString, documentTypes } = this.translator(\n      query,\n    ) as ConcreteLunrQuery;\n\n    const results: lunr.Index.Result[] = [];\n\n    if (documentTypes.length === 1 && documentTypes[0] === '*') {\n      // Iterate over all this.lunrIndex values.\n      Object.values(this.lunrIndices).forEach(i => {\n        try {\n          results.push(...i.search(lunrQueryString));\n        } catch (err) {\n          // if a field does not exist on a index, we can see that as a no-match\n          if (\n            err instanceof lunr.QueryParseError &&\n            err.message.startsWith('unrecognised field')\n          )\n            return;\n        }\n      });\n    } else {\n      // Iterate over the filtered list of this.lunrIndex keys.\n      Object.keys(this.lunrIndices)\n        .filter(d => documentTypes.includes(d))\n        .forEach(d => {\n          try {\n            results.push(...this.lunrIndices[d].search(lunrQueryString));\n          } catch (err) {\n            // if a field does not exist on a index, we can see that as a no-match\n            if (\n              err instanceof lunr.QueryParseError &&\n              err.message.startsWith('unrecognised field')\n            )\n              return;\n          }\n        });\n    }\n\n    // Sort results.\n    results.sort((doc1, doc2) => {\n      return doc2.score - doc1.score;\n    });\n\n    // Translate results into SearchResultSet\n    const resultSet: SearchResultSet = {\n      results: results.map(d => {\n        return { document: this.docStore[d.ref] };\n      }),\n    };\n\n    return Promise.resolve(resultSet);\n  }\n}\n"],"names":["lunr"],"mappings":"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"}