import { ORIGIN_LOCATION_ANNOTATION, stringifyLocationReference, LOCATION_ANNOTATION } from '@backstage/catalog-model';
import { ResponseError } from '@backstage/errors';
import fetch from 'cross-fetch';

class CatalogClient {
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
  }
  async getLocationById(id, options) {
    return await this.requestOptional("GET", `/locations/${encodeURIComponent(id)}`, options);
  }
  async getEntities(request, options) {
    const {filter = [], fields = []} = request != null ? request : {};
    const filterItems = [filter].flat();
    const params = [];
    for (const filterItem of filterItems) {
      const filterParts = [];
      for (const [key, value] of Object.entries(filterItem)) {
        for (const v of [value].flat()) {
          filterParts.push(`${encodeURIComponent(key)}=${encodeURIComponent(v)}`);
        }
      }
      if (filterParts.length) {
        params.push(`filter=${filterParts.join(",")}`);
      }
    }
    if (fields.length) {
      params.push(`fields=${fields.map(encodeURIComponent).join(",")}`);
    }
    const query = params.length ? `?${params.join("&")}` : "";
    const entities = await this.requestRequired("GET", `/entities${query}`, options);
    return {items: entities};
  }
  async getEntityByName(compoundName, options) {
    const {kind, namespace = "default", name} = compoundName;
    return this.requestOptional("GET", `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(namespace)}/${encodeURIComponent(name)}`, options);
  }
  async addLocation({type = "url", target, dryRun, presence}, options) {
    const response = await fetch(`${await this.discoveryApi.getBaseUrl("catalog")}/locations${dryRun ? "?dryRun=true" : ""}`, {
      headers: {
        "Content-Type": "application/json",
        ...(options == null ? void 0 : options.token) && {Authorization: `Bearer ${options == null ? void 0 : options.token}`}
      },
      method: "POST",
      body: JSON.stringify({type, target, presence})
    });
    if (response.status !== 201) {
      throw new Error(await response.text());
    }
    const {location, entities} = await response.json();
    if (!location) {
      throw new Error(`Location wasn't added: ${target}`);
    }
    if (entities.length === 0) {
      throw new Error(`Location was added but has no entities specified yet: ${target}`);
    }
    return {
      location,
      entities
    };
  }
  async getOriginLocationByEntity(entity, options) {
    var _a;
    const locationCompound = (_a = entity.metadata.annotations) == null ? void 0 : _a[ORIGIN_LOCATION_ANNOTATION];
    if (!locationCompound) {
      return void 0;
    }
    const all = await this.requestRequired("GET", "/locations", options);
    return all.map((r) => r.data).find((l) => locationCompound === stringifyLocationReference(l));
  }
  async getLocationByEntity(entity, options) {
    var _a;
    const locationCompound = (_a = entity.metadata.annotations) == null ? void 0 : _a[LOCATION_ANNOTATION];
    if (!locationCompound) {
      return void 0;
    }
    const all = await this.requestRequired("GET", "/locations", options);
    return all.map((r) => r.data).find((l) => locationCompound === stringifyLocationReference(l));
  }
  async removeLocationById(id, options) {
    await this.requestIgnored("DELETE", `/locations/${encodeURIComponent(id)}`, options);
  }
  async removeEntityByUid(uid, options) {
    await this.requestIgnored("DELETE", `/entities/by-uid/${encodeURIComponent(uid)}`, options);
  }
  async requestIgnored(method, path, options) {
    const url = `${await this.discoveryApi.getBaseUrl("catalog")}${path}`;
    const headers = (options == null ? void 0 : options.token) ? {Authorization: `Bearer ${options.token}`} : {};
    const response = await fetch(url, {method, headers});
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
  }
  async requestRequired(method, path, options) {
    const url = `${await this.discoveryApi.getBaseUrl("catalog")}${path}`;
    const headers = (options == null ? void 0 : options.token) ? {Authorization: `Bearer ${options.token}`} : {};
    const response = await fetch(url, {method, headers});
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async requestOptional(method, path, options) {
    const url = `${await this.discoveryApi.getBaseUrl("catalog")}${path}`;
    const headers = (options == null ? void 0 : options.token) ? {Authorization: `Bearer ${options.token}`} : {};
    const response = await fetch(url, {method, headers});
    if (!response.ok) {
      if (response.status === 404) {
        return void 0;
      }
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
}

const ENTITY_STATUS_CATALOG_PROCESSING_TYPE = "backstage.io/catalog-processing";

export { CatalogClient, ENTITY_STATUS_CATALOG_PROCESSING_TYPE };
//# sourceMappingURL=index.esm.js.map
