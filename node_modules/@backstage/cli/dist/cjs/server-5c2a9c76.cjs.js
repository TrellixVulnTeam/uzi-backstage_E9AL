'use strict';

var fs = require('fs-extra');
var webpack = require('webpack');
var config = require('./config-ead78a79.cjs.js');
var WebpackDevServer = require('webpack-dev-server');
var openBrowser = require('react-dev-utils/openBrowser');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var webpack__default = /*#__PURE__*/_interopDefaultLegacy(webpack);
var WebpackDevServer__default = /*#__PURE__*/_interopDefaultLegacy(WebpackDevServer);
var openBrowser__default = /*#__PURE__*/_interopDefaultLegacy(openBrowser);

async function serveBundle(options) {
  var _a, _b;
  const url = config.resolveBaseUrl(options.frontendConfig);
  const host = options.frontendConfig.getOptionalString("app.listen.host") || url.hostname;
  const port = options.frontendConfig.getOptionalNumber("app.listen.port") || Number(url.port) || (url.protocol === "https:" ? 443 : 80);
  const paths = config.resolveBundlingPaths(options);
  const pkgPath = paths.targetPackageJson;
  const pkg = await fs__default['default'].readJson(pkgPath);
  const config$1 = await config.createConfig(paths, {
    ...options,
    isDev: true,
    baseUrl: url
  });
  const compiler = webpack__default['default'](config$1);
  const server = new WebpackDevServer__default['default'](compiler, {
    hot: !process.env.CI,
    contentBase: paths.targetPublic,
    contentBasePublicPath: (_a = config$1.output) == null ? void 0 : _a.publicPath,
    publicPath: (_b = config$1.output) == null ? void 0 : _b.publicPath,
    historyApiFallback: {
      disableDotRule: true
    },
    clientLogLevel: "warning",
    stats: "errors-warnings",
    https: url.protocol === "https:",
    host,
    port,
    proxy: pkg.proxy,
    allowedHosts: [url.hostname]
  });
  await new Promise((resolve, reject) => {
    server.listen(port, host, (err) => {
      if (err) {
        reject(err);
        return;
      }
      openBrowser__default['default'](url.href);
      resolve();
    });
  });
  const waitForExit = async () => {
    for (const signal of ["SIGINT", "SIGTERM"]) {
      process.on(signal, () => {
        server.close();
        process.exit();
      });
    }
    return new Promise(() => {
    });
  };
  return waitForExit;
}

exports.serveBundle = serveBundle;
//# sourceMappingURL=server-5c2a9c76.cjs.js.map
