/// <reference types="react" />
import privateExports__default, { AppConfigLoader, AppOptions, IconComponent, ApiRef, ProfileInfoApi, BackstageIdentityApi, SessionApi, SignInPageProps } from '@backstage/core-api';
export * from '@backstage/core-api';
import React$1, { CSSProperties, ComponentProps, ReactNode, PropsWithChildren, ElementType, ComponentType, ComponentClass, ErrorInfo, Context, ReactElement } from 'react';
import { Button as Button$1, LinkProps as LinkProps$1, TooltipProps, LinearProgressProps, CardHeaderProps, TabProps as TabProps$1, WithStyles, Theme, StyledComponentProps, Breadcrumbs as Breadcrumbs$1 } from '@material-ui/core';
import { Link as Link$1, LinkProps as LinkProps$2, NavLinkProps } from 'react-router-dom';
import PropTypes from 'prop-types';
import dagre from 'dagre';
import CSS from 'csstype';
import { TextTruncateProps } from 'react-text-truncate';
import { Column, MaterialTableProps } from 'material-table';
import { SparklinesProps, SparklinesLineProps } from 'react-sparklines';
import { StyleRules } from '@material-ui/styles';

/**
 * The default config loader, which expects that config is available at compile-time
 * in `process.env.APP_CONFIG`. APP_CONFIG should be an array of config objects as
 * returned by the config loader.
 *
 * It will also load runtime config from the __APP_INJECTED_RUNTIME_CONFIG__ string,
 * which can be rewritten at runtime to contain an additional JSON config object.
 * If runtime config is present, it will be placed first in the config array, overriding
 * other config values.
 */
declare const defaultConfigLoader: AppConfigLoader;
/**
 * Creates a new Backstage App.
 */
declare function createApp(options?: AppOptions): privateExports__default.PrivateAppImpl;

declare const AlertDisplay: () => JSX.Element | null;

declare type AvatarProps = {
    displayName?: string;
    picture?: string;
    customStyles?: CSSProperties;
};
declare const Avatar: ({ displayName, picture, customStyles }: AvatarProps) => JSX.Element;

declare type Props = ComponentProps<typeof Button$1> & ComponentProps<typeof Link$1>;
/**
 * Thin wrapper on top of material-ui's Button component
 * Makes the Button to utilise react-router
 */
declare const Button: React$1.ForwardRefExoticComponent<Pick<Props, "replace" | "disabled" | "media" | "hidden" | "dir" | "form" | "slot" | "style" | "title" | "color" | "size" | "children" | "key" | "value" | "id" | "translate" | "prefix" | "name" | "action" | "classes" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "className" | "contentEditable" | "contextMenu" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "variant" | "innerRef" | "download" | "href" | "hrefLang" | "ping" | "rel" | "target" | "type" | "referrerPolicy" | "disableElevation" | "fullWidth" | "startIcon" | "endIcon" | "autoFocus" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "disableFocusRipple" | "buttonRef" | "centerRipple" | "disableRipple" | "disableTouchRipple" | "focusRipple" | "focusVisibleClassName" | "onFocusVisible" | "TouchRippleProps" | "to" | "state"> & React$1.RefAttributes<any>>;

declare type Props$1 = {
    text: string;
    language: string;
    showLineNumbers?: boolean;
    showCopyCodeButton?: boolean;
    highlightedNumbers?: number[];
    customStyle?: any;
};
declare const CodeSnippet: ({ text, language, showLineNumbers, showCopyCodeButton, highlightedNumbers, customStyle, }: Props$1) => JSX.Element;

/**
 * Copy text button with visual feedback in the form of
 *  - a hover color
 *  - click ripple
 *  - Tooltip shown when user has clicked
 *
 *  Properties:
 *  - text: the text to be copied
 *  - tooltipDelay: Number os ms to show the tooltip, default: 1000ms
 *  - tooltipText: Text to show in the tooltip when user has clicked the button, default: "Text
 * copied to clipboard"
 *
 * Example:
 *    <CopyTextButton text="My text that I want to be copied to the clipboard" />
 */
declare type Props$2 = {
    text: string;
    tooltipDelay?: number;
    tooltipText?: string;
};
declare const CopyTextButton: {
    (props: Props$2): JSX.Element;
    propTypes: {
        text: PropTypes.Validator<string>;
        tooltipDelay: PropTypes.Requireable<number>;
        tooltipText: PropTypes.Requireable<string>;
    };
};

declare type CustomType = {
    [customKey: string]: any;
};
declare type DependencyEdge<T = CustomType> = T & {
    from: string;
    to: string;
    label?: string;
};
declare type GraphEdge<T = CustomType> = DependencyEdge<T> & dagre.GraphEdge & EdgeProperties;
declare type RenderLabelProps<T = CustomType> = {
    edge: DependencyEdge<T>;
};
declare type RenderLabelFunction = (props: RenderLabelProps<any>) => React.ReactNode;
declare type DependencyNode<T = CustomType> = T & {
    id: string;
};
declare type GraphNode<T = CustomType> = dagre.Node<DependencyNode<T>>;
declare type RenderNodeProps<T = CustomType> = {
    node: DependencyNode<T>;
};
declare type RenderNodeFunction = (props: RenderNodeProps<any>) => React.ReactNode;
declare type EdgeProperties = {
    label?: string;
    width?: number;
    height?: number;
    labeloffset?: number;
    labelpos?: LabelPosition;
    minlen?: number;
    weight?: number;
    [customKey: string]: any;
};
declare enum Direction {
    TOP_BOTTOM = "TB",
    BOTTOM_TOP = "BT",
    LEFT_RIGHT = "LR",
    RIGHT_LEFT = "RL"
}
declare enum Alignment {
    UP_LEFT = "UL",
    UP_RIGHT = "UR",
    DOWN_LEFT = "DL",
    DOWN_RIGHT = "DR"
}
declare enum Ranker {
    NETWORK_SIMPLEX = "network-simplex",
    TIGHT_TREE = "tight-tree",
    LONGEST_PATH = "longest-path"
}
declare enum LabelPosition {
    LEFT = "l",
    RIGHT = "r",
    CENTER = "c"
}

type types_d_DependencyEdge<_0> = DependencyEdge<_0>;
type types_d_GraphEdge<_0> = GraphEdge<_0>;
type types_d_RenderLabelProps<_0> = RenderLabelProps<_0>;
type types_d_RenderLabelFunction = RenderLabelFunction;
type types_d_DependencyNode<_0> = DependencyNode<_0>;
type types_d_GraphNode<_0> = GraphNode<_0>;
type types_d_RenderNodeProps<_0> = RenderNodeProps<_0>;
type types_d_RenderNodeFunction = RenderNodeFunction;
type types_d_EdgeProperties = EdgeProperties;
type types_d_Direction = Direction;
declare const types_d_Direction: typeof Direction;
type types_d_Alignment = Alignment;
declare const types_d_Alignment: typeof Alignment;
type types_d_Ranker = Ranker;
declare const types_d_Ranker: typeof Ranker;
type types_d_LabelPosition = LabelPosition;
declare const types_d_LabelPosition: typeof LabelPosition;
declare namespace types_d {
  export {
    types_d_DependencyEdge as DependencyEdge,
    types_d_GraphEdge as GraphEdge,
    types_d_RenderLabelProps as RenderLabelProps,
    types_d_RenderLabelFunction as RenderLabelFunction,
    types_d_DependencyNode as DependencyNode,
    types_d_GraphNode as GraphNode,
    types_d_RenderNodeProps as RenderNodeProps,
    types_d_RenderNodeFunction as RenderNodeFunction,
    types_d_EdgeProperties as EdgeProperties,
    types_d_Direction as Direction,
    types_d_Alignment as Alignment,
    types_d_Ranker as Ranker,
    types_d_LabelPosition as LabelPosition,
  };
}

declare type DependencyGraphProps = React$1.SVGProps<SVGSVGElement> & {
    edges: DependencyEdge[];
    nodes: DependencyNode[];
    direction?: Direction;
    align?: Alignment;
    nodeMargin?: number;
    edgeMargin?: number;
    rankMargin?: number;
    paddingX?: number;
    paddingY?: number;
    acyclicer?: 'greedy';
    ranker?: Ranker;
    labelPosition?: LabelPosition;
    labelOffset?: number;
    edgeRanks?: number;
    edgeWeight?: number;
    renderNode?: RenderNodeFunction;
    renderLabel?: RenderLabelFunction;
    defs?: SVGDefsElement | SVGDefsElement[];
};
declare function DependencyGraph({ edges, nodes, renderNode, direction, align, nodeMargin, edgeMargin, rankMargin, paddingX, paddingY, acyclicer, ranker, labelPosition, labelOffset, edgeRanks, edgeWeight, renderLabel, defs, ...svgProps }: DependencyGraphProps): JSX.Element;

declare type Props$3 = {
    variant: 'info' | 'error';
    message: ReactNode;
    id: string;
    fixed?: boolean;
};
declare const DismissableBanner: ({ variant, message, id, fixed, }: Props$3) => JSX.Element;

declare type Props$4 = {
    title: string;
    description?: string | JSX.Element;
    missing: 'field' | 'info' | 'content' | 'data';
    action?: JSX.Element;
};
declare const EmptyState: ({ title, description, missing, action }: Props$4) => JSX.Element;

declare type Props$5 = {
    annotation: string;
};
declare const MissingAnnotationEmptyState: ({ annotation }: Props$5) => JSX.Element;

declare type Props$6 = {
    error: Error;
};
/**
 * Renders details about a failed server request.
 *
 * Has special treatment for ResponseError errors, to display rich
 * server-provided information about what happened.
 */
declare const ResponseErrorDetails: ({ error }: Props$6) => JSX.Element;
/**
 * Renders a warning panel as the effect of a failed server request.
 *
 * Has special treatment for ResponseError errors, to display rich
 * server-provided information about what happened.
 */
declare const ResponseErrorPanel: ({ error }: Props$6) => JSX.Element;

declare type Props$7 = {
    featureId: string;
    title: string;
    description: string;
};
declare const FeatureCalloutCircular: ({ featureId, title, description, children, }: PropsWithChildren<Props$7>) => JSX.Element;

declare type IconLinkVerticalProps = {
    color?: 'primary' | 'secondary';
    disabled?: boolean;
    href?: string;
    icon?: React$1.ReactNode;
    label: string;
    onClick?: React$1.MouseEventHandler<HTMLAnchorElement>;
    title?: string;
};

declare type Props$8 = {
    links: IconLinkVerticalProps[];
};
declare const HeaderIconLinkRow: ({ links }: Props$8) => JSX.Element;

declare type Props$9 = {
    scrollStep?: number;
    scrollSpeed?: number;
    minScrollDistance?: number;
};
declare const HorizontalScrollGrid: (props: PropsWithChildren<Props$9>) => JSX.Element;

declare type Props$a = CSS.Properties & {
    shorthand?: boolean;
    alpha?: boolean;
};
declare const Lifecycle: (props: Props$a) => JSX.Element;

declare type LinkProps = LinkProps$1 & LinkProps$2 & {
    component?: ElementType<any>;
};
/**
 * Thin wrapper on top of material-ui's Link component
 * Makes the Link to utilise react-router
 */
declare const Link: React$1.ForwardRefExoticComponent<Pick<LinkProps, "replace" | "media" | "hidden" | "dir" | "slot" | "style" | "title" | "color" | "underline" | "children" | "key" | "id" | "display" | "translate" | "prefix" | "classes" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "className" | "contentEditable" | "contextMenu" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "component" | "variant" | "innerRef" | "download" | "href" | "hrefLang" | "ping" | "rel" | "target" | "type" | "referrerPolicy" | "noWrap" | "gutterBottom" | "paragraph" | "align" | "variantMapping" | "to" | "state" | "TypographyClasses"> & React$1.RefAttributes<any>>;

declare type Props$b = {
    content: string;
    dialect?: 'gfm' | 'common-mark';
};
/**
 * MarkdownContent
 * --
 * Renders markdown with the default dialect [gfm - GitHub flavored Markdown](https://github.github.com/gfm/) to backstage theme styled HTML.
 * If you just want to render to plain [CommonMark](https://commonmark.org/), set the dialect to `'common-mark'`
 */
declare const MarkdownContent: ({ content, dialect }: Props$b) => JSX.Element;

declare const OAuthRequestDialog: () => JSX.Element;

declare type Props$c = {
    text: TextTruncateProps['text'];
    line?: TextTruncateProps['line'];
    element?: TextTruncateProps['element'];
    title?: TooltipProps['title'];
    placement?: TooltipProps['placement'];
};
declare const OverflowTooltip: (props: Props$c) => JSX.Element;

declare const Progress: (props: PropsWithChildren<LinearProgressProps>) => JSX.Element;

declare type BottomLinkProps = {
    link: string;
    title: string;
    onClick?: (event: React$1.MouseEvent<HTMLAnchorElement>) => void;
};

declare type InfoCardVariants = 'flex' | 'fullHeight' | 'gridItem';
/**
 * InfoCard is used to display a paper-styled block on the screen, similar to a panel.
 *
 * You can custom style an InfoCard with the 'style' (outer container) and 'cardStyle' (inner container)
 * styles.
 *
 * The InfoCard serves as an error boundary. As a result, if you provide a 'slackChannel' property this
 * specifies the channel to display in the error component that is displayed if an error occurs
 * in any descendent components.
 *
 * By default the InfoCard has no custom layout of its children, but is treated as a block element. A
 * couple common variants are provided and can be specified via the variant property:
 *
 * When the InfoCard is displayed as a grid item within a grid, you may want items to have the same height for all items.
 * Set to the 'gridItem' variant to display the InfoCard with full height suitable for Grid:
 *
 *   <InfoCard variant="gridItem">...</InfoCard>
 */
declare type Props$d = {
    title?: ReactNode;
    subheader?: ReactNode;
    divider?: boolean;
    deepLink?: BottomLinkProps;
    slackChannel?: string;
    variant?: InfoCardVariants;
    style?: object;
    cardStyle?: object;
    children?: ReactNode;
    headerStyle?: object;
    headerProps?: CardHeaderProps;
    actionsClassName?: string;
    actions?: ReactNode;
    cardClassName?: string;
    actionsTopRight?: ReactNode;
    className?: string;
    noPadding?: boolean;
    titleTypographyProps?: object;
};
declare const InfoCard: ({ title, subheader, divider, deepLink, slackChannel, variant, children, headerStyle, headerProps, actionsClassName, actions, cardClassName, actionsTopRight, className, noPadding, titleTypographyProps, }: Props$d) => JSX.Element;

declare type Props$e = {
    title: string;
    subheader?: string;
    variant?: InfoCardVariants;
    /** Progress in % specified as decimal, e.g. "0.23" */
    progress: number;
    inverse?: boolean;
    deepLink?: BottomLinkProps;
};
declare const GaugeCard: (props: Props$e) => JSX.Element;

declare type Props$f = {
    value: number;
    fractional?: boolean;
    inverse?: boolean;
    unit?: string;
    max?: number;
};
declare const Gauge: (props: Props$f) => JSX.Element;

declare type Props$g = {
    /**
     * Progress value between 0.0 - 1.0.
     */
    value: number;
};
declare const LinearGauge: ({ value }: Props$g) => JSX.Element | null;

declare type Item = {
    label: string;
    value: string | number;
};
declare type Selection = string | string[] | number | number[];
declare type SelectProps = {
    multiple?: boolean;
    items: Item[];
    label: string;
    placeholder?: string;
    selected?: Selection;
    onChange: (arg: Selection) => void;
    triggerReset?: boolean;
};
declare const SelectComponent: ({ multiple, items, label, placeholder, selected, onChange, triggerReset, }: SelectProps) => JSX.Element;

interface StepperProps {
    elevated?: boolean;
    onStepChange?: (prevIndex: number, nextIndex: number) => void;
    activeStep?: number;
}
declare const SimpleStepper: ({ children, elevated, onStepChange, activeStep, }: PropsWithChildren<StepperProps>) => JSX.Element;

declare type StepActions = {
    showNext?: boolean;
    canNext?: () => boolean;
    onNext?: () => void;
    nextStep?: (current: number, last: number) => number;
    nextText?: string;
    showBack?: boolean;
    backText?: string;
    onBack?: () => void;
    showRestart?: boolean;
    canRestart?: () => boolean;
    onRestart?: () => void;
    restartText?: string;
};
declare type StepProps = {
    title: string;
    children: React$1.ReactElement;
    end?: boolean;
    actions?: StepActions;
};

declare const SimpleStepperStep: ({ title, children, end, actions, ...muiProps }: PropsWithChildren<StepProps>) => JSX.Element;

declare const StatusOK: (props: PropsWithChildren<{}>) => JSX.Element;
declare const StatusWarning: (props: PropsWithChildren<{}>) => JSX.Element;
declare const StatusError: (props: PropsWithChildren<{}>) => JSX.Element;
declare const StatusPending: (props: PropsWithChildren<{}>) => JSX.Element;
declare const StatusRunning: (props: PropsWithChildren<{}>) => JSX.Element;
declare const StatusAborted: (props: PropsWithChildren<{}>) => JSX.Element;

declare type Props$h = {
    metadata: {
        [key: string]: any;
    };
    dense?: boolean;
    options?: any;
};
declare const StructuredMetadataTable: ({ metadata, dense, options, }: Props$h) => JSX.Element;

declare type Props$i = {};
declare const SupportButton: ({ children }: PropsWithChildren<Props$i>) => JSX.Element;

declare type SubRoute = {
    path: string;
    title: string;
    children: JSX.Element;
    tabProps?: TabProps$1<React$1.ElementType, {
        component?: React$1.ElementType;
    }>;
};
/**
 * TabbedLayout is a compound component, which allows you to define a layout for
 * pages using a sub-navigation mechanism.
 *
 * Consists of two parts: TabbedLayout and TabbedLayout.Route
 *
 * @example
 * ```jsx
 * <TabbedLayout>
 *   <TabbedLayout.Route path="/example" title="Example tab">
 *     <div>This is rendered under /example/anything-here route</div>
 *   </TabbedLayout.Route>
 * </TabbedLayout>
 * ```
 */
declare const TabbedLayout: {
    ({ children }: PropsWithChildren<{}>): JSX.Element;
    Route: (props: SubRoute) => null;
};

declare type SubRoute$1 = {
    path: string;
    title: string;
    children: JSX.Element;
    tabProps?: TabProps$1<ElementType, {
        component?: ElementType;
    }>;
};

declare const RoutedTabs: ({ routes }: {
    routes: SubRoute$1[];
}) => JSX.Element;

declare type SubvalueCellProps = {
    value: React$1.ReactNode;
    subvalue: React$1.ReactNode;
};
declare const SubvalueCell: ({ value, subvalue }: SubvalueCellProps) => JSX.Element;

declare type SelectedFilters = {
    [key: string]: string | string[];
};

interface TableColumn<T extends object = {}> extends Column<T> {
    highlight?: boolean;
    width?: string;
}
declare type TableFilter = {
    column: string;
    type: 'select' | 'multiple-select' | 'checkbox-tree';
};
declare type TableState = {
    search?: string;
    filtersOpen?: boolean;
    filters?: SelectedFilters;
};
interface TableProps<T extends object = {}> extends MaterialTableProps<T> {
    columns: TableColumn<T>[];
    subtitle?: string;
    filters?: TableFilter[];
    initialState?: TableState;
    emptyContent?: ReactNode;
    onStateChange?: (state: TableState) => any;
}
declare function Table<T extends object = {}>({ columns, options, title, subtitle, filters, initialState, emptyContent, onStateChange, ...props }: TableProps<T>): JSX.Element;

interface TabProps {
    content: any;
    label?: string;
    icon?: any;
}
interface TabsProps {
    tabs: TabProps[];
}
declare const Tabs: ({ tabs }: TabsProps) => JSX.Element;

declare const TrendLine: (props: SparklinesProps & Pick<SparklinesLineProps, 'color'> & {
    title?: string;
}) => JSX.Element | null;

declare type Props$j = {
    title?: string;
    severity?: 'warning' | 'error' | 'info';
    message?: React$1.ReactNode;
    children?: React$1.ReactNode;
};
/**
 * WarningPanel. Show a user friendly error message to a user similar to ErrorPanel except that the warning panel
 * only shows the warning message to the user.
 *
 * @param {string} [severity=warning] Ability to change the severity of the alert. Not fully implemented. (error, warning, info)
 * @param {string} [title] A title for the warning. If not supplied, "Warning" will be used.
 * @param {Object} [message] Optional more detailed user-friendly message elaborating on the cause of the error.
 * @param {Object} [children] Objects to provide context, such as a stack trace or detailed error reporting.
 *  Will be available inside an unfolded accordion.
 */
declare const WarningPanel: (props: Props$j) => JSX.Element;

declare type Props$k = {
    stretch?: boolean;
    noPadding?: boolean;
    className?: string;
};
declare const Content: ({ className, stretch, noPadding, children, ...props }: PropsWithChildren<Props$k>) => JSX.Element;

/**
 * TODO favoriteable capability
 */

declare type DefaultTitleProps = {
    title?: string;
    className: string;
};
declare type ContentHeaderProps = {
    title?: DefaultTitleProps['title'];
    titleComponent?: ComponentType;
    description?: string;
    textAlign?: 'left' | 'right' | 'center';
};
declare const ContentHeader: ({ description, title, titleComponent: TitleComponent, children, textAlign, }: PropsWithChildren<ContentHeaderProps>) => JSX.Element;

declare type Props$l = {
    slackChannel?: string;
    onError?: (error: Error, errorInfo: string) => null;
};
declare type State = {
    error?: Error;
    errorInfo?: ErrorInfo;
};
declare const ErrorBoundary: ComponentClass<Props$l, State>;

interface IErrorPageProps {
    status: string;
    statusMessage: string;
    additionalInfo?: string;
}
declare const ErrorPage: ({ status, statusMessage, additionalInfo, }: IErrorPageProps) => JSX.Element;

declare type Props$m = {
    component?: ReactNode;
    pageTitleOverride?: string;
    style?: CSSProperties;
    subtitle?: ReactNode;
    title: ReactNode;
    tooltip?: string;
    type?: string;
    typeLink?: string;
};
declare const Header: ({ children, pageTitleOverride, style, subtitle, title, tooltip, type, typeLink, }: PropsWithChildren<Props$m>) => JSX.Element;

declare type HeaderLabelContentProps = {
    value: React$1.ReactNode;
    className: string;
};
declare type HeaderLabelProps = {
    label: string;
    value?: HeaderLabelContentProps['value'];
    url?: string;
};
declare const HeaderLabel: ({ label, value, url }: HeaderLabelProps) => JSX.Element;

declare type Tab = {
    id: string;
    label: string;
    tabProps?: TabProps$1<React$1.ElementType, {
        component?: React$1.ElementType;
    }>;
};
declare type HeaderTabsProps = {
    tabs: Tab[];
    onChange?: (index: number) => void;
    selectedIndex?: number;
};
declare const HeaderTabs: ({ tabs, onChange, selectedIndex, }: HeaderTabsProps) => JSX.Element;

declare const HomepageTimer: () => JSX.Element | null;

declare type ItemCardProps = {
    description?: string;
    tags?: string[];
    title: string;
    /** @deprecated Use subtitle instead */
    type?: string;
    subtitle?: ReactNode;
    label: string;
    onClick?: () => void;
    href?: string;
};
/**
 * This card type has been deprecated. Instead use plain MUI Card and helpers
 * where appropriate.
 *
 * <code>
 * <!--
 *   <Card>
 *     <CardMedia>
 *       <ItemCardHeader title="My Card" subtitle="neat!" />
 *     </CardMedia>
 *     <CardContent>
 *        Some text
 *     </CardContent>
 *     <CardActions>
 *       <Button color="primary" to="https://backstage.io">
 *         Get Started
 *       </Button>
 *     </CardActions>
 *   </Card>
 * -->
 * </code>
 *
 * @deprecated Use plain MUI <Card> and composable helpers instead.
 * @see https://material-ui.com/components/cards/
 */
declare const ItemCard: ({ description, tags, title, type, subtitle, label, onClick, href, }: ItemCardProps) => JSX.Element;

declare const styles: (theme: Theme) => StyleRules<{}, "root">;
declare type ItemCardGridProps = Partial<WithStyles<typeof styles>> & {
    /**
     * The Card items of the grid.
     */
    children?: React$1.ReactNode;
};
/**
 * A default grid to use when arranging "item cards" - cards that let users
 * select among several options.
 *
 * The immediate children are expected to be MUI Card components.
 *
 * Styles for the grid can be overridden using the `classes` prop, e.g.:
 *
 * <code>
 *   <ItemCardGrid title="Hello" classes={{ root: myClassName }} />
 * </code>
 *
 * This can be useful for e.g. overriding gridTemplateColumns to adapt the
 * minimum size of the cells to fit the content better.
 */
declare const ItemCardGrid: (props: ItemCardGridProps) => JSX.Element;

declare const styles$1: (theme: Theme) => StyleRules<{}, "root">;
declare type ItemCardHeaderProps = Partial<WithStyles<typeof styles$1>> & {
    /**
     * A large title to show in the header, providing the main heading.
     *
     * Use this if you want to have the default styling and placement of a title.
     */
    title?: React$1.ReactNode;
    /**
     * A slightly smaller title to show in the header, providing additional
     * details.
     *
     * Use this if you want to have the default styling and placement of a
     * subtitle.
     */
    subtitle?: React$1.ReactNode;
    /**
     * Custom children to draw in the header.
     *
     * If the title and/or subtitle were specified, the children are drawn below
     * those.
     */
    children?: React$1.ReactNode;
};
/**
 * A simple card header, rendering a default look for "item cards" - cards that
 * are arranged in a grid for users to select among several options.
 *
 * This component expects to be placed within a MUI <CardMedia>.
 *
 * Styles for the header can be overridden using the `classes` prop, e.g.:
 *
 * <code>
 *   <ItemCardHeader title="Hello" classes={{ root: myClassName }} />
 * </code>
 */
declare const ItemCardHeader: (props: ItemCardHeaderProps) => JSX.Element;

declare type Props$n = {
    themeId: string;
};
declare const Page: ({ themeId, children }: PropsWithChildren<Props$n>) => JSX.Element;

declare type Props$o = {
    openDelayMs?: number;
    closeDelayMs?: number;
};
declare const Sidebar: ({ openDelayMs, closeDelayMs, children, }: PropsWithChildren<Props$o>) => JSX.Element;

declare type SidebarPinStateContextType = {
    isPinned: boolean;
    toggleSidebarPinState: () => any;
};
declare const SidebarPinStateContext: React$1.Context<SidebarPinStateContextType>;
declare const SidebarPage: (props: PropsWithChildren<{}>) => JSX.Element;

declare type SidebarItemBaseProps = {
    icon: IconComponent;
    text?: string;
    hasNotifications?: boolean;
    children?: ReactNode;
    className?: string;
};
declare type SidebarItemButtonProps = SidebarItemBaseProps & {
    onClick: (ev: React$1.MouseEvent) => void;
};
declare type SidebarItemLinkProps = SidebarItemBaseProps & {
    to: string;
    onClick?: (ev: React$1.MouseEvent) => void;
} & NavLinkProps;
declare type SidebarItemProps = SidebarItemButtonProps | SidebarItemLinkProps;
declare const SidebarItem: React$1.ForwardRefExoticComponent<SidebarItemProps & React$1.RefAttributes<any>>;
declare type SidebarSearchFieldProps = {
    onSearch: (input: string) => void;
    to?: string;
};
declare const SidebarSearchField: (props: SidebarSearchFieldProps) => JSX.Element;
declare const SidebarSpace: React$1.ComponentType<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "hidden" | "dir" | "slot" | "style" | "title" | "color" | "children" | "id" | "translate" | "prefix" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | keyof React$1.ClassAttributes<HTMLDivElement>> & StyledComponentProps<"root"> & {
    className?: string | undefined;
}>;
declare const SidebarSpacer: React$1.ComponentType<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "hidden" | "dir" | "slot" | "style" | "title" | "color" | "children" | "id" | "translate" | "prefix" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | keyof React$1.ClassAttributes<HTMLDivElement>> & StyledComponentProps<"root"> & {
    className?: string | undefined;
}>;
declare const SidebarDivider: React$1.ComponentType<Pick<React$1.DetailedHTMLProps<React$1.HTMLAttributes<HTMLHRElement>, HTMLHRElement>, "hidden" | "dir" | "slot" | "style" | "title" | "color" | "children" | "id" | "translate" | "prefix" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | keyof React$1.ClassAttributes<HTMLHRElement>> & StyledComponentProps<"root"> & {
    className?: string | undefined;
}>;

declare type IntroCardProps = {
    text: string;
    onClose: () => void;
};
declare const IntroCard: (props: IntroCardProps) => JSX.Element;
declare const SidebarIntro: () => JSX.Element | null;

declare const sidebarConfig: {
    drawerWidthClosed: number;
    drawerWidthOpen: number;
    defaultOpenDelayMs: number;
    defaultCloseDelayMs: number;
    defaultFadeDuration: number;
    logoHeight: number;
    iconContainerWidth: number;
    iconSize: number;
    iconPadding: number;
    selectedIndicatorWidth: number;
    userBadgePadding: number;
    userBadgeDiameter: number;
};
declare const SIDEBAR_INTRO_LOCAL_STORAGE = "@backstage/core/sidebar-intro-dismissed";
declare type SidebarContextType = {
    isOpen: boolean;
};
declare const SidebarContext: Context<SidebarContextType>;

declare type SignInProviderConfig = {
    id: string;
    title: string;
    message: string;
    apiRef: ApiRef<ProfileInfoApi & BackstageIdentityApi & SessionApi>;
};
declare type IdentityProviders = ('guest' | 'custom' | SignInProviderConfig)[];

declare type MultiSignInPageProps = SignInPageProps & {
    providers: IdentityProviders;
    title?: string;
    align?: 'center' | 'left';
};
declare type SingleSignInPageProps = SignInPageProps & {
    provider: SignInProviderConfig;
    auto?: boolean;
};
declare type Props$p = MultiSignInPageProps | SingleSignInPageProps;
declare const SignInPage: (props: Props$p) => JSX.Element;

declare type Props$q = {
    slackChannel?: string;
    children?: ReactElement<TabProps$1>[];
    onChange?: (event: React$1.ChangeEvent<{}>, value: number | string) => void;
    title?: string;
    value?: number | string;
    deepLink?: BottomLinkProps;
};
declare const TabbedCard: ({ slackChannel, children, title, deepLink, value, onChange, }: PropsWithChildren<Props$q>) => JSX.Element;
declare type CardTabProps = TabProps$1 & {
    children: ReactNode;
};
declare const CardTab: ({ children, ...props }: PropsWithChildren<CardTabProps>) => JSX.Element;

declare type Props$r = ComponentProps<typeof Breadcrumbs$1>;
declare const Breadcrumbs: ({ children, ...props }: Props$r) => JSX.Element;

declare type SetQueryParams<T> = (params: T) => void;
declare function useQueryParamState<T>(stateName: string, 
/** @deprecated Don't configure a custom debouceTime */
debounceTime?: number): [T | undefined, SetQueryParams<T>];

declare type SupportItemLink = {
    url: string;
    title: string;
};
declare type SupportItem = {
    title: string;
    icon?: string;
    links: SupportItemLink[];
};
declare type SupportConfig = {
    url: string;
    items: SupportItem[];
};
declare function useSupportConfig(): SupportConfig;

export { AlertDisplay, Avatar, Breadcrumbs, Button, CardTab, CodeSnippet, Content, ContentHeader, CopyTextButton, DependencyGraph, types_d as DependencyGraphTypes, DismissableBanner, EmptyState, ErrorBoundary, ErrorPage, FeatureCalloutCircular, Gauge, GaugeCard, Header, HeaderIconLinkRow, HeaderLabel, HeaderTabs, HomepageTimer, HorizontalScrollGrid, IconLinkVerticalProps, InfoCard, InfoCardVariants, IntroCard, ItemCard, ItemCardGrid, ItemCardGridProps, ItemCardHeader, ItemCardHeaderProps, Lifecycle, LinearGauge, Link, LinkProps, MarkdownContent, MissingAnnotationEmptyState, OAuthRequestDialog, OverflowTooltip, Page, Progress, ResponseErrorDetails, ResponseErrorPanel, RoutedTabs, SIDEBAR_INTRO_LOCAL_STORAGE, SelectComponent as Select, Sidebar, SidebarContext, SidebarContextType, SidebarDivider, SidebarIntro, SidebarItem, SidebarPage, SidebarPinStateContext, SidebarPinStateContextType, SidebarSearchField, SidebarSpace, SidebarSpacer, SignInPage, SignInProviderConfig, SimpleStepper, SimpleStepperStep, StatusAborted, StatusError, StatusOK, StatusPending, StatusRunning, StatusWarning, StructuredMetadataTable, SubvalueCell, SupportButton, SupportConfig, SupportItem, SupportItemLink, Tab, TabbedCard, TabbedLayout, Table, TableColumn, TableFilter, TableProps, TableState, Tabs, TrendLine, WarningPanel, createApp, defaultConfigLoader, sidebarConfig, useQueryParamState, useSupportConfig };
