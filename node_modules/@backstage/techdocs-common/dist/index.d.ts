/// <reference types="node" />
import { UrlReader, ContainerRunner, PluginEndpointDiscovery } from '@backstage/backend-common';
import { Config } from '@backstage/config';
import { Logger } from 'winston';
import { Entity, EntityName } from '@backstage/catalog-model';
import { Writable } from 'stream';
import express from 'express';
import { GitHubIntegrationConfig, GitLabIntegrationConfig, AzureIntegrationConfig } from '@backstage/integration';

declare type PreparerResponse = {
    /**
     * The path to directory where the tree is downloaded.
     */
    preparedDir: string;
    /**
     * A unique identifer of the tree blob, usually the commit SHA or etag from the target.
     */
    etag: string;
};
declare type PreparerBase = {
    /**
     * Given an Entity definition from the Service Catalog, go and prepare a directory
     * with contents from the location in temporary storage and return the path.
     *
     * @param entity The entity from the Service Catalog
     * @param options.etag (Optional) If etag is provider, it will be used to check if the target has
     * updated since the last build.
     * @throws {NotModifiedError} when the prepared directory has not been changed since the last build.
     */
    prepare(entity: Entity, options?: {
        logger?: Logger;
        etag?: string;
    }): Promise<PreparerResponse>;
};
declare type PreparerBuilder = {
    register(protocol: RemoteProtocol, preparer: PreparerBase): void;
    get(entity: Entity): PreparerBase;
};
/**
 * Everything except `url` will be deprecated.
 * Read more https://github.com/backstage/backstage/issues/4409
 */
declare type RemoteProtocol = 'url' | 'dir' | 'github' | 'gitlab' | 'file' | 'azure/api';

declare type ParsedLocationAnnotation = {
    type: RemoteProtocol;
    target: string;
};
declare const parseReferenceAnnotation: (annotationName: string, entity: Entity) => ParsedLocationAnnotation;
declare const getLocationForEntity: (entity: Entity) => ParsedLocationAnnotation;
declare const getGitRepositoryTempFolder: (repositoryUrl: string, config: Config) => Promise<string>;
declare const checkoutGitRepository: (repoUrl: string, config: Config, logger: Logger) => Promise<string>;
declare const getLastCommitTimestamp: (repositoryLocation: string, logger: Logger) => Promise<number>;
declare const getDocFilesFromRepository: (reader: UrlReader, entity: Entity, opts?: {
    etag?: string | undefined;
    logger?: Logger | undefined;
} | undefined) => Promise<PreparerResponse>;

/**
 * The values that the generator will receive.
 *
 * @param {string} inputDir The directory of the uncompiled documentation, with the values from the frontend
 * @param {string} outputDir Directory to store generated docs in. Usually - a newly created temporary directory.
 * @param {ParsedLocationAnnotation} parsedLocationAnnotation backstage.io/techdocs-ref annotation of an entity
 * @param {string} etag A unique identifier for the prepared tree e.g. commit SHA. If provided it will be stored in techdocs_metadata.json.
 * @param {Writable} [logStream] A dedicated log stream
 */
declare type GeneratorRunOptions = {
    inputDir: string;
    outputDir: string;
    parsedLocationAnnotation?: ParsedLocationAnnotation;
    etag?: string;
    logStream?: Writable;
};
declare type GeneratorBase = {
    run(opts: GeneratorRunOptions): Promise<void>;
};
/**
 * List of supported generator options
 */
declare type SupportedGeneratorKey = 'techdocs' | string;
/**
 * The generator builder holds the generator ready for run time
 */
declare type GeneratorBuilder = {
    register(protocol: SupportedGeneratorKey, generator: GeneratorBase): void;
    get(entity: Entity): GeneratorBase;
};

declare class TechdocsGenerator implements GeneratorBase {
    private readonly logger;
    private readonly containerRunner;
    private readonly options;
    constructor({ logger, containerRunner, config, }: {
        logger: Logger;
        containerRunner: ContainerRunner;
        config: Config;
    });
    run({ inputDir, outputDir, parsedLocationAnnotation, etag, }: GeneratorRunOptions): Promise<void>;
}

declare class Generators implements GeneratorBuilder {
    private generatorMap;
    static fromConfig(config: Config, { logger, containerRunner, }: {
        logger: Logger;
        containerRunner: ContainerRunner;
    }): Promise<GeneratorBuilder>;
    register(generatorKey: SupportedGeneratorKey, generator: GeneratorBase): void;
    get(entity: Entity): GeneratorBase;
}

declare class DirectoryPreparer implements PreparerBase {
    private readonly config;
    private readonly logger;
    private readonly reader;
    constructor(config: Config, logger: Logger, reader: UrlReader);
    private resolveManagedByLocationToDir;
    prepare(entity: Entity): Promise<PreparerResponse>;
}

declare class CommonGitPreparer implements PreparerBase {
    private readonly config;
    private readonly logger;
    constructor(config: Config, logger: Logger);
    prepare(entity: Entity, options?: {
        etag?: string;
    }): Promise<PreparerResponse>;
}

declare class UrlPreparer implements PreparerBase {
    private readonly logger;
    private readonly reader;
    constructor(reader: UrlReader, logger: Logger);
    prepare(entity: Entity, options?: {
        etag?: string;
    }): Promise<PreparerResponse>;
}

declare type factoryOptions = {
    logger: Logger;
    reader: UrlReader;
};
declare class Preparers implements PreparerBuilder {
    private preparerMap;
    static fromConfig(config: Config, { logger, reader }: factoryOptions): Promise<PreparerBuilder>;
    register(protocol: RemoteProtocol, preparer: PreparerBase): void;
    get(entity: Entity): PreparerBase;
}

/**
 * Key for all the different types of TechDocs publishers that are supported.
 */
declare type PublisherType = 'local' | 'googleGcs' | 'awsS3' | 'azureBlobStorage' | 'openStackSwift';
declare type PublishRequest = {
    entity: Entity;
    directory: string;
};
declare type PublishResponse = {
    remoteUrl?: string;
} | void;
/**
 * Result for the validation check.
 */
declare type ReadinessResponse = {
    /** If true, the publisher is able to interact with the backing storage. */
    isAvailable: boolean;
};
/**
 * Type to hold metadata found in techdocs_metadata.json and associated with each site
 * @param etag ETag of the resource used to generate the site. Usually the latest commit sha of the source repository.
 */
declare type TechDocsMetadata = {
    site_name: string;
    site_description: string;
    etag: string;
};
/**
 * Base class for a TechDocs publisher (e.g. Local, Google GCS Bucket, AWS S3, etc.)
 * The publisher handles publishing of the generated static files after the prepare and generate steps of TechDocs.
 * It also provides APIs to communicate with the storage service.
 */
interface PublisherBase {
    /**
     * Check if the publisher is ready. This check tries to perform certain checks to see if the
     * publisher is configured correctly and can be used to publish or read documentations.
     * The different implementations might e.g. use the provided service credentials to access the
     * target or check if a folder/bucket is available.
     */
    getReadiness(): Promise<ReadinessResponse>;
    /**
     * Store the generated static files onto a storage service (either local filesystem or external service).
     *
     * @param request Object containing the entity from the service
     * catalog, and the directory that contains the generated static files from TechDocs.
     */
    publish(request: PublishRequest): Promise<PublishResponse>;
    /**
     * Retrieve TechDocs Metadata about a site e.g. name, contributors, last updated, etc.
     * This API uses the techdocs_metadata.json file that co-exists along with the generated docs.
     */
    fetchTechDocsMetadata(entityName: EntityName): Promise<TechDocsMetadata>;
    /**
     * Route middleware to serve static documentation files for an entity.
     */
    docsRouter(): express.Handler;
    /**
     * Check if the index.html is present for the Entity at the Storage location.
     */
    hasDocsBeenGenerated(entityName: Entity): Promise<boolean>;
}

declare type factoryOptions$1 = {
    logger: Logger;
    discovery: PluginEndpointDiscovery;
};
/**
 * Factory class to create a TechDocs publisher based on defined publisher type in app config.
 * Uses `techdocs.publisher.type`.
 */
declare class Publisher {
    static fromConfig(config: Config, { logger, discovery }: factoryOptions$1): Promise<PublisherBase>;
}

declare const getDefaultBranch: (repositoryUrl: string, config: Config) => Promise<string>;

declare function getGitHost(url: string): string;
declare function getGitRepoType(url: string): string;
declare const getGitHubIntegrationConfig: (config: Config, host: string) => GitHubIntegrationConfig;
declare const getGitLabIntegrationConfig: (config: Config, host: string) => GitLabIntegrationConfig;
declare const getAzureIntegrationConfig: (config: Config, host: string) => AzureIntegrationConfig;
declare const getTokenForGitRepo: (repositoryUrl: string, config: Config) => Promise<string | undefined>;

export { CommonGitPreparer, DirectoryPreparer, GeneratorBase, GeneratorBuilder, Generators, ParsedLocationAnnotation, PreparerBase, PreparerBuilder, Preparers, Publisher, PublisherBase, PublisherType, RemoteProtocol, TechDocsMetadata, TechdocsGenerator, UrlPreparer, checkoutGitRepository, getAzureIntegrationConfig, getDefaultBranch, getDocFilesFromRepository, getGitHost, getGitHubIntegrationConfig, getGitLabIntegrationConfig, getGitRepoType, getGitRepositoryTempFolder, getLastCommitTimestamp, getLocationForEntity, getTokenForGitRepo, parseReferenceAnnotation };
