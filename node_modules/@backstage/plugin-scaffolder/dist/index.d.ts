/// <reference types="react" />
import { BackstagePlugin, RouteRef, ExternalRouteRef, ApiRef, Observable, DiscoveryApi, IdentityApi } from '@backstage/core';
import { JSONSchema, EntityName } from '@backstage/catalog-model';
import { JsonValue, JsonObject } from '@backstage/config';
import { ScmIntegrationRegistry } from '@backstage/integration';

declare const scaffolderPlugin: BackstagePlugin<{
    root: RouteRef<undefined>;
}, {
    registerComponent: ExternalRouteRef<undefined, true>;
}>;
declare const ScaffolderPage: () => JSX.Element;

declare type Status = 'open' | 'processing' | 'failed' | 'completed';
declare type ScaffolderStep = {
    id: string;
    name: string;
    action: string;
    parameters?: {
        [name: string]: JsonValue;
    };
};
declare type ScaffolderTask = {
    id: string;
    spec: {
        steps: ScaffolderStep[];
    };
    status: 'failed' | 'completed' | 'processing' | 'open' | 'cancelled';
    lastHeartbeatAt: string;
    createdAt: string;
};
declare type ListActionsResponse = Array<{
    id: string;
    description?: string;
    schema?: {
        input?: JSONSchema;
        output?: JSONSchema;
    };
}>;

declare const scaffolderApiRef: ApiRef<ScaffolderApi>;
declare type TemplateParameterSchema = {
    title: string;
    steps: Array<{
        title: string;
        schema: JsonObject;
    }>;
};
declare type LogEvent = {
    type: 'log' | 'completion';
    body: {
        message: string;
        stepId?: string;
        status?: Status;
    };
    createdAt: string;
    id: string;
    taskId: string;
};
interface ScaffolderApi {
    getTemplateParameterSchema(templateName: EntityName): Promise<TemplateParameterSchema>;
    /**
     * Executes the scaffolding of a component, given a template and its
     * parameter values.
     *
     * @param templateName Name of the Template entity for the scaffolder to use. New project is going to be created out of this template.
     * @param values Parameters for the template, e.g. name, description
     */
    scaffold(templateName: string, values: Record<string, any>): Promise<string>;
    getTask(taskId: string): Promise<ScaffolderTask>;
    getIntegrationsList(options: {
        allowedHosts: string[];
    }): Promise<{
        type: string;
        title: string;
        host: string;
    }[]>;
    listActions(): Promise<ListActionsResponse>;
    streamLogs({ taskId, after, }: {
        taskId: string;
        after?: number;
    }): Observable<LogEvent>;
}
declare class ScaffolderClient implements ScaffolderApi {
    private readonly discoveryApi;
    private readonly identityApi;
    private readonly scmIntegrationsApi;
    constructor(options: {
        discoveryApi: DiscoveryApi;
        identityApi: IdentityApi;
        scmIntegrationsApi: ScmIntegrationRegistry;
    });
    getIntegrationsList(options: {
        allowedHosts: string[];
    }): Promise<{
        type: string;
        title: string;
        host: string;
    }[]>;
    getTemplateParameterSchema(templateName: EntityName): Promise<TemplateParameterSchema>;
    /**
     * Executes the scaffolding of a component, given a template and its
     * parameter values.
     *
     * @param templateName Template name for the scaffolder to use. New project is going to be created out of this template.
     * @param values Parameters for the template, e.g. name, description
     */
    scaffold(templateName: string, values: Record<string, any>): Promise<string>;
    getTask(taskId: string): Promise<any>;
    streamLogs({ taskId, after, }: {
        taskId: string;
        after?: number;
    }): Observable<LogEvent>;
    /**
     * @returns ListActionsResponse containing all registered actions.
     */
    listActions(): Promise<ListActionsResponse>;
}

export { ScaffolderApi, ScaffolderClient, ScaffolderPage, scaffolderPlugin as plugin, scaffolderApiRef, scaffolderPlugin };
