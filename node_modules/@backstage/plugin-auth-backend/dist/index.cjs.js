'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var express = require('express');
var Router = require('express-promise-router');
var cookieParser = require('cookie-parser');
var passportGithub2 = require('passport-github2');
var jwtDecoder = require('jwt-decode');
var errors = require('@backstage/errors');
var crypto = require('crypto');
var url = require('url');
var passportGitlab2 = require('passport-gitlab2');
var passportGoogleOauth20 = require('passport-google-oauth20');
var OAuth2Strategy = require('passport-oauth2');
var openidClient = require('openid-client');
var passportOktaOauth = require('passport-okta-oauth');
var passportSaml = require('passport-saml');
var passportMicrosoft = require('passport-microsoft');
var got = require('got');
var passportOneloginOauth = require('passport-onelogin-oauth');
var fetch = require('cross-fetch');
var NodeCache = require('node-cache');
var jose = require('jose');
var catalogClient = require('@backstage/catalog-client');
var uuid = require('uuid');
var luxon = require('luxon');
var backendCommon = require('@backstage/backend-common');
var session = require('express-session');
var passport = require('passport');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var express__default = /*#__PURE__*/_interopDefaultLegacy(express);
var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);
var cookieParser__default = /*#__PURE__*/_interopDefaultLegacy(cookieParser);
var jwtDecoder__default = /*#__PURE__*/_interopDefaultLegacy(jwtDecoder);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var OAuth2Strategy__default = /*#__PURE__*/_interopDefaultLegacy(OAuth2Strategy);
var got__default = /*#__PURE__*/_interopDefaultLegacy(got);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var NodeCache__default = /*#__PURE__*/_interopDefaultLegacy(NodeCache);
var session__default = /*#__PURE__*/_interopDefaultLegacy(session);
var passport__default = /*#__PURE__*/_interopDefaultLegacy(passport);

const makeProfileInfo = (profile, idToken) => {
  let {displayName} = profile;
  let email = void 0;
  if (profile.emails && profile.emails.length > 0) {
    const [firstEmail] = profile.emails;
    email = firstEmail.value;
  }
  let picture = void 0;
  if (profile.photos && profile.photos.length > 0) {
    const [firstPhoto] = profile.photos;
    picture = firstPhoto.value;
  }
  if ((!email || !picture || !displayName) && idToken) {
    try {
      const decoded = jwtDecoder__default['default'](idToken);
      if (!email && decoded.email) {
        email = decoded.email;
      }
      if (!picture && decoded.picture) {
        picture = decoded.picture;
      }
      if (!displayName && decoded.name) {
        displayName = decoded.name;
      }
    } catch (e) {
      throw new Error(`Failed to parse id token and get profile info, ${e}`);
    }
  }
  return {
    email,
    picture,
    displayName
  };
};
const executeRedirectStrategy = async (req, providerStrategy, options) => {
  return new Promise((resolve) => {
    const strategy = Object.create(providerStrategy);
    strategy.redirect = (url, status) => {
      resolve({url, status: status != null ? status : void 0});
    };
    strategy.authenticate(req, {...options});
  });
};
const executeFrameHandlerStrategy = async (req, providerStrategy) => {
  return new Promise((resolve, reject) => {
    const strategy = Object.create(providerStrategy);
    strategy.success = (result, privateInfo) => {
      resolve({result, privateInfo});
    };
    strategy.fail = (info) => {
      var _a;
      reject(new Error(`Authentication rejected, ${(_a = info.message) != null ? _a : ""}`));
    };
    strategy.error = (error) => {
      var _a;
      let message = `Authentication failed, ${error.message}`;
      if ((_a = error.oauthError) == null ? void 0 : _a.data) {
        try {
          const errorData = JSON.parse(error.oauthError.data);
          if (errorData.message) {
            message += ` - ${errorData.message}`;
          }
        } catch (parseError) {
          message += ` - ${error.oauthError}`;
        }
      }
      reject(new Error(message));
    };
    strategy.redirect = () => {
      reject(new Error("Unexpected redirect"));
    };
    strategy.authenticate(req, {});
  });
};
const executeRefreshTokenStrategy = async (providerStrategy, refreshToken, scope) => {
  return new Promise((resolve, reject) => {
    const anyStrategy = providerStrategy;
    const OAuth2 = anyStrategy._oauth2.constructor;
    const oauth2 = new OAuth2(anyStrategy._oauth2._clientId, anyStrategy._oauth2._clientSecret, anyStrategy._oauth2._baseSite, anyStrategy._oauth2._authorizeUrl, anyStrategy._refreshURL || anyStrategy._oauth2._accessTokenUrl, anyStrategy._oauth2._customHeaders);
    oauth2.getOAuthAccessToken(refreshToken, {
      scope,
      grant_type: "refresh_token"
    }, (err, accessToken, newRefreshToken, params) => {
      if (err) {
        reject(new Error(`Failed to refresh access token ${err.toString()}`));
      }
      if (!accessToken) {
        reject(new Error(`Failed to refresh access token, no access token received`));
      }
      resolve({
        accessToken,
        refreshToken: newRefreshToken,
        params
      });
    });
  });
};
const executeFetchUserProfileStrategy = async (providerStrategy, accessToken) => {
  return new Promise((resolve, reject) => {
    const anyStrategy = providerStrategy;
    anyStrategy.userProfile(accessToken, (error, rawProfile) => {
      if (error) {
        reject(error);
      } else {
        resolve(rawProfile);
      }
    });
  });
};

const readState = (stateString) => {
  var _a, _b;
  const state = Object.fromEntries(new URLSearchParams(Buffer.from(stateString, "hex").toString("utf-8")));
  if (!state.nonce || !state.env || ((_a = state.nonce) == null ? void 0 : _a.length) === 0 || ((_b = state.env) == null ? void 0 : _b.length) === 0) {
    throw Error(`Invalid state passed via request`);
  }
  return {
    nonce: state.nonce,
    env: state.env
  };
};
const encodeState = (state) => {
  const searchParams = new URLSearchParams();
  searchParams.append("nonce", state.nonce);
  searchParams.append("env", state.env);
  return Buffer.from(searchParams.toString(), "utf-8").toString("hex");
};
const verifyNonce = (req, providerId) => {
  var _a, _b;
  const cookieNonce = req.cookies[`${providerId}-nonce`];
  const state = readState((_b = (_a = req.query.state) == null ? void 0 : _a.toString()) != null ? _b : "");
  const stateNonce = state.nonce;
  if (!cookieNonce) {
    throw new Error("Auth response is missing cookie nonce");
  }
  if (stateNonce.length === 0) {
    throw new Error("Auth response is missing state nonce");
  }
  if (cookieNonce !== stateNonce) {
    throw new Error("Invalid nonce");
  }
};

class OAuthEnvironmentHandler {
  constructor(handlers) {
    this.handlers = handlers;
  }
  static mapConfig(config, factoryFunc) {
    const envs = config.keys();
    const handlers = new Map();
    for (const env of envs) {
      const envConfig = config.getConfig(env);
      const handler = factoryFunc(envConfig);
      handlers.set(env, handler);
    }
    return new OAuthEnvironmentHandler(handlers);
  }
  async start(req, res) {
    const provider = this.getProviderForEnv(req, res);
    await (provider == null ? void 0 : provider.start(req, res));
  }
  async frameHandler(req, res) {
    const provider = this.getProviderForEnv(req, res);
    await (provider == null ? void 0 : provider.frameHandler(req, res));
  }
  async refresh(req, res) {
    var _a;
    const provider = this.getProviderForEnv(req, res);
    await ((_a = provider == null ? void 0 : provider.refresh) == null ? void 0 : _a.call(provider, req, res));
  }
  async logout(req, res) {
    var _a;
    const provider = this.getProviderForEnv(req, res);
    await ((_a = provider == null ? void 0 : provider.logout) == null ? void 0 : _a.call(provider, req, res));
  }
  getRequestFromEnv(req) {
    var _a, _b;
    const reqEnv = (_a = req.query.env) == null ? void 0 : _a.toString();
    if (reqEnv) {
      return reqEnv;
    }
    const stateParams = (_b = req.query.state) == null ? void 0 : _b.toString();
    if (!stateParams) {
      return void 0;
    }
    const env = readState(stateParams).env;
    return env;
  }
  getProviderForEnv(req, res) {
    const env = this.getRequestFromEnv(req);
    if (!env) {
      throw new errors.InputError(`Must specify 'env' query to select environment`);
    }
    if (!this.handlers.has(env)) {
      res.status(404).send(`Missing configuration.
    <br>
    <br>
    For this flow to work you need to supply a valid configuration for the "${env}" environment of provider.`);
      return void 0;
    }
    return this.handlers.get(env);
  }
}

const safelyEncodeURIComponent = (value) => {
  return encodeURIComponent(value).replace(/'/g, "%27");
};
const postMessageResponse = (res, appOrigin, response) => {
  const jsonData = JSON.stringify(response);
  const base64Data = safelyEncodeURIComponent(jsonData);
  const base64Origin = safelyEncodeURIComponent(appOrigin);
  const script = `
    var authResponse = decodeURIComponent('${base64Data}');
    var origin = decodeURIComponent('${base64Origin}');
    var originInfo = {'type': 'config_info', 'targetOrigin': origin};
    (window.opener || window.parent).postMessage(originInfo, '*');
    (window.opener || window.parent).postMessage(JSON.parse(authResponse), origin);
    setTimeout(() => {
      window.close();
    }, 100); // same as the interval of the core-api lib/loginPopup.ts (to address race conditions)
  `;
  const hash = crypto__default['default'].createHash("sha256").update(script).digest("base64");
  res.setHeader("Content-Type", "text/html");
  res.setHeader("X-Frame-Options", "sameorigin");
  res.setHeader("Content-Security-Policy", `script-src 'sha256-${hash}'`);
  res.end(`<html><body><script>${script}</script></body></html>`);
};
const ensuresXRequestedWith = (req) => {
  const requiredHeader = req.header("X-Requested-With");
  if (!requiredHeader || requiredHeader !== "XMLHttpRequest") {
    return false;
  }
  return true;
};

const THOUSAND_DAYS_MS = 1e3 * 24 * 60 * 60 * 1e3;
const TEN_MINUTES_MS = 600 * 1e3;
class OAuthAdapter {
  constructor(handlers, options) {
    this.handlers = handlers;
    this.options = options;
    this.setNonceCookie = (res, nonce) => {
      res.cookie(`${this.options.providerId}-nonce`, nonce, {
        maxAge: TEN_MINUTES_MS,
        secure: this.options.secure,
        sameSite: "lax",
        domain: this.options.cookieDomain,
        path: `${this.options.cookiePath}/handler`,
        httpOnly: true
      });
    };
    this.setScopesCookie = (res, scope) => {
      res.cookie(`${this.options.providerId}-scope`, scope, {
        maxAge: TEN_MINUTES_MS,
        secure: this.options.secure,
        sameSite: "lax",
        domain: this.options.cookieDomain,
        path: `${this.options.cookiePath}/handler`,
        httpOnly: true
      });
    };
    this.getScopesFromCookie = (req, providerId) => {
      return req.cookies[`${providerId}-scope`];
    };
    this.setRefreshTokenCookie = (res, refreshToken) => {
      res.cookie(`${this.options.providerId}-refresh-token`, refreshToken, {
        maxAge: THOUSAND_DAYS_MS,
        secure: this.options.secure,
        sameSite: "lax",
        domain: this.options.cookieDomain,
        path: this.options.cookiePath,
        httpOnly: true
      });
    };
    this.removeRefreshTokenCookie = (res) => {
      res.cookie(`${this.options.providerId}-refresh-token`, "", {
        maxAge: 0,
        secure: this.options.secure,
        sameSite: "lax",
        domain: this.options.cookieDomain,
        path: this.options.cookiePath,
        httpOnly: true
      });
    };
  }
  static fromConfig(config, handlers, options) {
    const {origin: appOrigin} = new url.URL(config.appUrl);
    const secure = config.baseUrl.startsWith("https://");
    const url$1 = new url.URL(config.baseUrl);
    const cookiePath = `${url$1.pathname}/${options.providerId}`;
    return new OAuthAdapter(handlers, {
      ...options,
      appOrigin,
      cookieDomain: url$1.hostname,
      cookiePath,
      secure
    });
  }
  async start(req, res) {
    var _a, _b, _c;
    const scope = (_b = (_a = req.query.scope) == null ? void 0 : _a.toString()) != null ? _b : "";
    const env = (_c = req.query.env) == null ? void 0 : _c.toString();
    if (!env) {
      throw new errors.InputError("No env provided in request query parameters");
    }
    if (this.options.persistScopes) {
      this.setScopesCookie(res, scope);
    }
    const nonce = crypto__default['default'].randomBytes(16).toString("base64");
    this.setNonceCookie(res, nonce);
    const state = {nonce, env};
    const forwardReq = Object.assign(req, {scope, state});
    const {url, status} = await this.handlers.start(forwardReq);
    res.statusCode = status || 302;
    res.setHeader("Location", url);
    res.setHeader("Content-Length", "0");
    res.end();
  }
  async frameHandler(req, res) {
    try {
      verifyNonce(req, this.options.providerId);
      const {response, refreshToken} = await this.handlers.handler(req);
      if (this.options.persistScopes) {
        const grantedScopes = this.getScopesFromCookie(req, this.options.providerId);
        response.providerInfo.scope = grantedScopes;
      }
      if (!this.options.disableRefresh) {
        if (!refreshToken) {
          throw new errors.InputError("Missing refresh token");
        }
        this.setRefreshTokenCookie(res, refreshToken);
      }
      await this.populateIdentity(response.backstageIdentity);
      return postMessageResponse(res, this.options.appOrigin, {
        type: "authorization_response",
        response
      });
    } catch (error) {
      return postMessageResponse(res, this.options.appOrigin, {
        type: "authorization_response",
        error: {
          name: error.name,
          message: error.message
        }
      });
    }
  }
  async logout(req, res) {
    if (!ensuresXRequestedWith(req)) {
      res.status(401).send("Invalid X-Requested-With header");
      return;
    }
    if (!this.options.disableRefresh) {
      this.removeRefreshTokenCookie(res);
    }
    res.status(200).send("logout!");
  }
  async refresh(req, res) {
    var _a, _b;
    if (!ensuresXRequestedWith(req)) {
      res.status(401).send("Invalid X-Requested-With header");
      return;
    }
    if (!this.handlers.refresh || this.options.disableRefresh) {
      res.status(400).send(`Refresh token not supported for provider: ${this.options.providerId}`);
      return;
    }
    try {
      const refreshToken = req.cookies[`${this.options.providerId}-refresh-token`];
      if (!refreshToken) {
        throw new Error("Missing session cookie");
      }
      const scope = (_b = (_a = req.query.scope) == null ? void 0 : _a.toString()) != null ? _b : "";
      const forwardReq = Object.assign(req, {scope, refreshToken});
      const response = await this.handlers.refresh(forwardReq);
      await this.populateIdentity(response.backstageIdentity);
      if (response.providerInfo.refreshToken && response.providerInfo.refreshToken !== refreshToken) {
        this.setRefreshTokenCookie(res, response.providerInfo.refreshToken);
      }
      res.status(200).json(response);
    } catch (error) {
      res.status(401).send(`${error.message}`);
    }
  }
  async populateIdentity(identity) {
    if (!identity) {
      return;
    }
    if (!identity.idToken) {
      identity.idToken = await this.options.tokenIssuer.issueToken({
        claims: {sub: identity.id}
      });
    }
  }
}

class GithubAuthProvider {
  constructor(options) {
    this._strategy = new passportGithub2.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      tokenURL: options.tokenUrl,
      userProfileURL: options.userProfileUrl,
      authorizationURL: options.authorizationUrl
    }, (accessToken, _refreshToken, params, fullProfile, done) => {
      done(void 0, {fullProfile, params, accessToken});
    });
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const {
      result: {fullProfile, accessToken, params}
    } = await executeFrameHandlerStrategy(req, this._strategy);
    const profile = makeProfileInfo({
      ...fullProfile,
      id: fullProfile.username || fullProfile.id,
      displayName: fullProfile.displayName || fullProfile.username || fullProfile.id
    }, params.id_token);
    return {
      response: {
        profile,
        providerInfo: {
          accessToken,
          scope: params.scope,
          expiresInSeconds: params.expires_in
        },
        backstageIdentity: {
          id: fullProfile.username || fullProfile.id
        }
      }
    };
  }
}
const createGithubProvider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const enterpriseInstanceUrl = envConfig.getOptionalString("enterpriseInstanceUrl");
    const authorizationUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/login/oauth/authorize` : void 0;
    const tokenUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/login/oauth/access_token` : void 0;
    const userProfileUrl = enterpriseInstanceUrl ? `${enterpriseInstanceUrl}/api/v3/user` : void 0;
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const provider = new GithubAuthProvider({
      clientId,
      clientSecret,
      callbackUrl,
      tokenUrl,
      userProfileUrl,
      authorizationUrl
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: true,
      persistScopes: true,
      providerId,
      tokenIssuer
    });
  });
};

class GitlabAuthProvider {
  constructor(options) {
    this._strategy = new passportGitlab2.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      baseURL: options.baseUrl
    }, (accessToken, _refreshToken, params, fullProfile, done) => {
      done(void 0, {fullProfile, params, accessToken});
    });
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    var _a;
    const {result} = await executeFrameHandlerStrategy(req, this._strategy);
    const {accessToken, params} = result;
    const fullProfile = result.fullProfile;
    const profile = makeProfileInfo({
      ...fullProfile,
      photos: [
        ...(_a = fullProfile.photos) != null ? _a : [],
        ...fullProfile.avatarUrl ? [{value: fullProfile.avatarUrl}] : []
      ]
    }, params.id_token);
    let id = fullProfile.id;
    if (profile.email) {
      id = profile.email.split("@")[0];
    }
    return {
      response: {
        profile,
        providerInfo: {
          accessToken,
          scope: params.scope,
          expiresInSeconds: params.expires_in,
          idToken: params.id_token
        },
        backstageIdentity: {
          id
        }
      }
    };
  }
}
const createGitlabProvider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const audience = envConfig.getOptionalString("audience");
    const baseUrl = audience || "https://gitlab.com";
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const provider = new GitlabAuthProvider({
      clientId,
      clientSecret,
      callbackUrl,
      baseUrl
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: true,
      providerId,
      tokenIssuer
    });
  });
};

class CatalogIdentityClient {
  constructor(options) {
    this.catalogApi = options.catalogApi;
  }
  async findUser(query, options) {
    const filter = {
      kind: "user"
    };
    for (const [key, value] of Object.entries(query.annotations)) {
      filter[`metadata.annotations.${key}`] = value;
    }
    const {items} = await this.catalogApi.getEntities({filter}, options);
    if (items.length !== 1) {
      if (items.length > 1) {
        throw new errors.ConflictError("User lookup resulted in multiple matches");
      } else {
        throw new errors.NotFoundError("User not found");
      }
    }
    return items[0];
  }
}

class GoogleAuthProvider {
  constructor(options) {
    this.logger = options.logger;
    this.identityClient = options.identityClient;
    this.tokenIssuer = options.tokenIssuer;
    this._strategy = new passportGoogleOauth20.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      passReqToCallback: false
    }, (accessToken, refreshToken, params, fullProfile, done) => {
      done(void 0, {
        fullProfile,
        params,
        accessToken,
        refreshToken
      }, {
        refreshToken
      });
    });
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const {result, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    const profile = makeProfileInfo(result.fullProfile, result.params.id_token);
    return {
      response: await this.populateIdentity({
        providerInfo: {
          idToken: result.params.id_token,
          accessToken: result.accessToken,
          scope: result.params.scope,
          expiresInSeconds: result.params.expires_in
        },
        profile
      }),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, req.refreshToken, req.scope);
    const fullProfile = await executeFetchUserProfileStrategy(this._strategy, accessToken);
    const profile = makeProfileInfo(fullProfile, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Google profile contained no email");
    }
    try {
      const token = await this.tokenIssuer.issueToken({
        claims: {sub: "backstage.io/auth-backend"}
      });
      const user = await this.identityClient.findUser({
        annotations: {
          "google.com/email": profile.email
        }
      }, {token});
      return {
        ...response,
        backstageIdentity: {
          id: user.metadata.name
        }
      };
    } catch (error) {
      this.logger.warn(`Failed to look up user, ${error}, falling back to allowing login based on email pattern, this will probably break in the future`);
      return {
        ...response,
        backstageIdentity: {id: profile.email.split("@")[0]}
      };
    }
  }
}
const createGoogleProvider = (_options) => {
  return ({
    providerId,
    globalConfig,
    config,
    logger,
    tokenIssuer,
    catalogApi
  }) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const provider = new GoogleAuthProvider({
      clientId,
      clientSecret,
      callbackUrl,
      logger,
      tokenIssuer,
      identityClient: new CatalogIdentityClient({catalogApi})
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: false,
      providerId,
      tokenIssuer
    });
  });
};

class OAuth2AuthProvider {
  constructor(options) {
    this._strategy = new OAuth2Strategy.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      authorizationURL: options.authorizationUrl,
      tokenURL: options.tokenUrl,
      passReqToCallback: false,
      scope: options.scope
    }, (accessToken, refreshToken, params, fullProfile, done) => {
      done(void 0, {
        fullProfile,
        accessToken,
        refreshToken,
        params
      }, {
        refreshToken
      });
    });
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const {result, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    const profile = makeProfileInfo(result.fullProfile, result.params.id_token);
    return {
      response: await this.populateIdentity({
        profile,
        providerInfo: {
          idToken: result.params.id_token,
          accessToken: result.accessToken,
          scope: result.params.scope,
          expiresInSeconds: result.params.expires_in
        }
      }),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const refreshTokenResponse = await executeRefreshTokenStrategy(this._strategy, req.refreshToken, req.scope);
    const {
      accessToken,
      params,
      refreshToken: updatedRefreshToken
    } = refreshTokenResponse;
    const rawProfile = await executeFetchUserProfileStrategy(this._strategy, accessToken);
    const profile = makeProfileInfo(rawProfile, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        refreshToken: updatedRefreshToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Profile does not contain an email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
const createOAuth2Provider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const authorizationUrl = envConfig.getString("authorizationUrl");
    const tokenUrl = envConfig.getString("tokenUrl");
    const scope = envConfig.getOptionalString("scope");
    const provider = new OAuth2AuthProvider({
      clientId,
      clientSecret,
      callbackUrl,
      authorizationUrl,
      tokenUrl,
      scope
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: false,
      providerId,
      tokenIssuer
    });
  });
};

class OidcAuthProvider {
  constructor(options) {
    this.implementation = this.setupStrategy(options);
    this.scope = options.scope;
  }
  async start(req) {
    const {strategy} = await this.implementation;
    return await executeRedirectStrategy(req, strategy, {
      accessType: "offline",
      prompt: "none",
      scope: req.scope || this.scope || "",
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const {strategy} = await this.implementation;
    const strategyResponse = await executeFrameHandlerStrategy(req, strategy);
    const {
      result: {userinfo, tokenset},
      privateInfo
    } = strategyResponse;
    const identityResponse = await this.populateIdentity({
      profile: {
        displayName: userinfo.name,
        email: userinfo.email,
        picture: userinfo.picture
      },
      providerInfo: {
        idToken: tokenset.id_token,
        accessToken: tokenset.access_token || "",
        scope: tokenset.scope || "",
        expiresInSeconds: tokenset.expires_in
      }
    });
    return {
      response: identityResponse,
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const {client} = await this.implementation;
    const tokenset = await client.refresh(req.refreshToken);
    if (!tokenset.access_token) {
      throw new Error("Refresh failed");
    }
    const profile = await client.userinfo(tokenset.access_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken: tokenset.access_token,
        refreshToken: tokenset.refresh_token,
        expiresInSeconds: tokenset.expires_in,
        idToken: tokenset.id_token,
        scope: tokenset.scope || ""
      },
      profile
    });
  }
  async setupStrategy(options) {
    const issuer = await openidClient.Issuer.discover(options.metadataUrl);
    const client = new issuer.Client({
      client_id: options.clientId,
      client_secret: options.clientSecret,
      redirect_uris: [options.callbackUrl],
      response_types: ["code"],
      id_token_signed_response_alg: options.tokenSignedResponseAlg || "RS256",
      scope: options.scope || ""
    });
    const strategy = new openidClient.Strategy({
      client,
      passReqToCallback: false
    }, (tokenset, userinfo, done) => {
      done(void 0, {tokenset, userinfo}, {
        refreshToken: tokenset.refresh_token
      });
    });
    strategy.error = console.error;
    return {strategy, client};
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Profile does not contain an email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
const createOidcProvider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const metadataUrl = envConfig.getString("metadataUrl");
    const tokenSignedResponseAlg = envConfig.getString("tokenSignedResponseAlg");
    const scope = envConfig.getOptionalString("scope");
    const provider = new OidcAuthProvider({
      clientId,
      clientSecret,
      callbackUrl,
      tokenSignedResponseAlg,
      metadataUrl,
      scope
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: false,
      providerId,
      tokenIssuer
    });
  });
};

class OktaAuthProvider {
  constructor(options) {
    this._store = {
      store(_req, cb) {
        cb(null, null);
      },
      verify(_req, _state, cb) {
        cb(null, true);
      }
    };
    this._strategy = new passportOktaOauth.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      audience: options.audience,
      passReqToCallback: false,
      store: this._store,
      response_type: "code"
    }, (accessToken, refreshToken, params, fullProfile, done) => {
      done(void 0, {
        accessToken,
        refreshToken,
        params,
        fullProfile
      }, {
        refreshToken
      });
    });
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const {result, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    const profile = makeProfileInfo(result.fullProfile, result.params.id_token);
    return {
      response: await this.populateIdentity({
        profile,
        providerInfo: {
          idToken: result.params.id_token,
          accessToken: result.accessToken,
          scope: result.params.scope,
          expiresInSeconds: result.params.expires_in
        }
      }),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, req.refreshToken, req.scope);
    const fullProfile = await executeFetchUserProfileStrategy(this._strategy, accessToken);
    const profile = makeProfileInfo(fullProfile, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Okta profile contained no email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
const createOktaProvider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const audience = envConfig.getString("audience");
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const provider = new OktaAuthProvider({
      audience,
      clientId,
      clientSecret,
      callbackUrl
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: false,
      providerId,
      tokenIssuer
    });
  });
};

class SamlAuthProvider {
  constructor(options) {
    this.appUrl = options.appUrl;
    this.tokenIssuer = options.tokenIssuer;
    this.strategy = new passportSaml.Strategy({...options}, (fullProfile, done) => {
      done(void 0, {fullProfile});
    });
  }
  async start(req, res) {
    const {url} = await executeRedirectStrategy(req, this.strategy, {});
    res.redirect(url);
  }
  async frameHandler(req, res) {
    try {
      const {result} = await executeFrameHandlerStrategy(req, this.strategy);
      const id = result.fullProfile.nameID;
      const idToken = await this.tokenIssuer.issueToken({
        claims: {sub: id}
      });
      return postMessageResponse(res, this.appUrl, {
        type: "authorization_response",
        response: {
          profile: {
            email: result.fullProfile.email,
            displayName: result.fullProfile.displayName
          },
          providerInfo: {},
          backstageIdentity: {id, idToken}
        }
      });
    } catch (error) {
      return postMessageResponse(res, this.appUrl, {
        type: "authorization_response",
        error: {
          name: error.name,
          message: error.message
        }
      });
    }
  }
  async logout(_req, res) {
    res.send("noop");
  }
  identifyEnv() {
    return void 0;
  }
}
const createSamlProvider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => {
    const opts = {
      callbackUrl: `${globalConfig.baseUrl}/${providerId}/handler/frame`,
      entryPoint: config.getString("entryPoint"),
      logoutUrl: config.getOptionalString("logoutUrl"),
      issuer: config.getString("issuer"),
      cert: config.getOptionalString("cert"),
      privateCert: config.getOptionalString("privateKey"),
      decryptionPvk: config.getOptionalString("decryptionPvk"),
      signatureAlgorithm: config.getOptionalString("signatureAlgorithm"),
      digestAlgorithm: config.getOptionalString("digestAlgorithm"),
      tokenIssuer,
      appUrl: globalConfig.appUrl
    };
    if (!opts.cert) {
      delete opts.cert;
    }
    return new SamlAuthProvider(opts);
  };
};

class Auth0Strategy extends OAuth2Strategy__default['default'] {
  constructor(options, verify) {
    const optionsWithURLs = {
      ...options,
      authorizationURL: `https://${options.domain}/authorize`,
      tokenURL: `https://${options.domain}/oauth/token`,
      userInfoURL: `https://${options.domain}/userinfo`,
      apiUrl: `https://${options.domain}/api`
    };
    super(optionsWithURLs, verify);
  }
}

class Auth0AuthProvider {
  constructor(options) {
    this._strategy = new Auth0Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      domain: options.domain,
      passReqToCallback: false
    }, (accessToken, refreshToken, params, fullProfile, done) => {
      done(void 0, {
        fullProfile,
        accessToken,
        refreshToken,
        params
      }, {
        refreshToken
      });
    });
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const {result, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    const profile = makeProfileInfo(result.fullProfile, result.params.id_token);
    return {
      response: await this.populateIdentity({
        profile,
        providerInfo: {
          idToken: result.params.id_token,
          accessToken: result.accessToken,
          scope: result.params.scope,
          expiresInSeconds: result.params.expires_in
        }
      }),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, req.refreshToken, req.scope);
    const fullProfile = await executeFetchUserProfileStrategy(this._strategy, accessToken);
    const profile = makeProfileInfo(fullProfile, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Profile does not contain an email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
const createAuth0Provider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const domain = envConfig.getString("domain");
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const provider = new Auth0AuthProvider({
      clientId,
      clientSecret,
      callbackUrl,
      domain
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: true,
      providerId,
      tokenIssuer
    });
  });
};

class MicrosoftAuthProvider {
  constructor(options) {
    this._strategy = new passportMicrosoft.Strategy({
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      authorizationURL: options.authorizationUrl,
      tokenURL: options.tokenUrl,
      passReqToCallback: false
    }, (accessToken, refreshToken, params, fullProfile, done) => {
      done(void 0, {fullProfile, accessToken, params}, {refreshToken});
    });
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const {result, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    try {
      const photoUrl = await this.getUserPhoto(result.accessToken);
      const profile = makeProfileInfo({
        ...result.fullProfile,
        photos: photoUrl ? [{value: photoUrl}] : void 0
      }, result.params.id_token);
      return {
        response: await this.populateIdentity({
          profile,
          providerInfo: {
            idToken: result.params.id_token,
            accessToken: result.accessToken,
            scope: result.params.scope,
            expiresInSeconds: result.params.expires_in
          }
        }),
        refreshToken: privateInfo.refreshToken
      };
    } catch (error) {
      throw new Error(`Error processing auth response: ${error}`);
    }
  }
  async refresh(req) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, req.refreshToken, req.scope);
    const fullProfile = await executeFetchUserProfileStrategy(this._strategy, accessToken);
    const profile = makeProfileInfo(fullProfile, params.id_token);
    const photo = await this.getUserPhoto(accessToken);
    if (photo) {
      profile.picture = photo;
    }
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  getUserPhoto(accessToken) {
    return new Promise((resolve) => {
      got__default['default'].get("https://graph.microsoft.com/v1.0/me/photos/48x48/$value", {
        encoding: "binary",
        responseType: "buffer",
        headers: {
          Authorization: `Bearer ${accessToken}`
        }
      }).then((photoData) => {
        const photoURL = `data:image/jpeg;base64,${Buffer.from(photoData.body).toString("base64")}`;
        resolve(photoURL);
      }).catch((error) => {
        console.log(`Could not retrieve user profile photo from Microsoft Graph API: ${error}`);
        resolve(void 0);
      });
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("Microsoft profile contained no email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
const createMicrosoftProvider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const tenantId = envConfig.getString("tenantId");
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const authorizationUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/authorize`;
    const tokenUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;
    const provider = new MicrosoftAuthProvider({
      clientId,
      clientSecret,
      callbackUrl,
      authorizationUrl,
      tokenUrl
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: false,
      providerId,
      tokenIssuer
    });
  });
};

class OneLoginProvider {
  constructor(options) {
    this._strategy = new passportOneloginOauth.Strategy({
      issuer: options.issuer,
      clientID: options.clientId,
      clientSecret: options.clientSecret,
      callbackURL: options.callbackUrl,
      passReqToCallback: false
    }, (accessToken, refreshToken, params, fullProfile, done) => {
      done(void 0, {
        accessToken,
        refreshToken,
        params,
        fullProfile
      }, {
        refreshToken
      });
    });
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: "openid",
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const {result, privateInfo} = await executeFrameHandlerStrategy(req, this._strategy);
    const profile = makeProfileInfo(result.fullProfile, result.params.id_token);
    return {
      response: await this.populateIdentity({
        profile,
        providerInfo: {
          idToken: result.params.id_token,
          accessToken: result.accessToken,
          scope: result.params.scope,
          expiresInSeconds: result.params.expires_in
        }
      }),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const {accessToken, params} = await executeRefreshTokenStrategy(this._strategy, req.refreshToken, req.scope);
    const fullProfile = await executeFetchUserProfileStrategy(this._strategy, accessToken);
    const profile = makeProfileInfo(fullProfile, params.id_token);
    return this.populateIdentity({
      providerInfo: {
        accessToken,
        idToken: params.id_token,
        expiresInSeconds: params.expires_in,
        scope: params.scope
      },
      profile
    });
  }
  async populateIdentity(response) {
    const {profile} = response;
    if (!profile.email) {
      throw new Error("OIDC profile contained no email");
    }
    const id = profile.email.split("@")[0];
    return {...response, backstageIdentity: {id}};
  }
}
const createOneLoginProvider = (_options) => {
  return ({providerId, globalConfig, config, tokenIssuer}) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
    const clientId = envConfig.getString("clientId");
    const clientSecret = envConfig.getString("clientSecret");
    const issuer = envConfig.getString("issuer");
    const callbackUrl = `${globalConfig.baseUrl}/${providerId}/handler/frame`;
    const provider = new OneLoginProvider({
      clientId,
      clientSecret,
      callbackUrl,
      issuer
    });
    return OAuthAdapter.fromConfig(globalConfig, provider, {
      disableRefresh: false,
      providerId,
      tokenIssuer
    });
  });
};

const ALB_JWT_HEADER = "x-amzn-oidc-data";
const getJWTHeaders = (input) => {
  const encoded = input.split(".")[0];
  return JSON.parse(Buffer.from(encoded, "base64").toString("utf8"));
};
class AwsAlbAuthProvider {
  constructor(logger, catalogClient, options) {
    this.logger = logger;
    this.catalogClient = catalogClient;
    this.options = options;
    this.keyCache = new NodeCache__default['default']({stdTTL: 3600});
  }
  frameHandler() {
    return Promise.resolve(void 0);
  }
  async refresh(req, res) {
    const jwt = req.header(ALB_JWT_HEADER);
    if (jwt !== void 0) {
      try {
        const headers = getJWTHeaders(jwt);
        const key = await this.getKey(headers.kid);
        const payload = jose.JWT.verify(jwt, key);
        if (this.options.issuer && headers.iss !== this.options.issuer) {
          throw new Error("issuer mismatch on JWT");
        }
        const resolvedEntity = await this.options.identityResolutionCallback(payload, this.catalogClient);
        res.json(resolvedEntity);
      } catch (e) {
        this.logger.error("exception occurred during JWT processing", e);
        res.status(401);
        res.end();
      }
    } else {
      res.status(401);
      res.end();
    }
  }
  start() {
    return Promise.resolve(void 0);
  }
  async getKey(keyId) {
    const optionalCacheKey = this.keyCache.get(keyId);
    if (optionalCacheKey) {
      return crypto.createPublicKey(optionalCacheKey);
    }
    const keyText = await fetch__default['default'](`https://public-keys.auth.elb.${this.options.region}.amazonaws.com/${keyId}`).then((response) => response.text());
    const keyValue = crypto.createPublicKey(keyText);
    this.keyCache.set(keyId, keyValue.export({format: "pem", type: "spki"}));
    return keyValue;
  }
}
const createAwsAlbProvider = (_options) => {
  return ({
    logger,
    catalogApi,
    config,
    identityResolver
  }) => {
    const region = config.getString("region");
    const issuer = config.getOptionalString("iss");
    if (identityResolver !== void 0) {
      return new AwsAlbAuthProvider(logger, catalogApi, {
        region,
        issuer,
        identityResolutionCallback: identityResolver
      });
    }
    throw new Error("Identity resolver is required to use this authentication provider");
  };
};

const factories = {
  google: createGoogleProvider(),
  github: createGithubProvider(),
  gitlab: createGitlabProvider(),
  saml: createSamlProvider(),
  okta: createOktaProvider(),
  auth0: createAuth0Provider(),
  microsoft: createMicrosoftProvider(),
  oauth2: createOAuth2Provider(),
  oidc: createOidcProvider(),
  onelogin: createOneLoginProvider(),
  awsalb: createAwsAlbProvider()
};

function createOidcRouter(options) {
  const {baseUrl, tokenIssuer} = options;
  const router = Router__default['default']();
  const config = {
    issuer: baseUrl,
    token_endpoint: `${baseUrl}/v1/token`,
    userinfo_endpoint: `${baseUrl}/v1/userinfo`,
    jwks_uri: `${baseUrl}/.well-known/jwks.json`,
    response_types_supported: ["id_token"],
    subject_types_supported: ["public"],
    id_token_signing_alg_values_supported: ["RS256"],
    scopes_supported: ["openid"],
    token_endpoint_auth_methods_supported: [],
    claims_supported: ["sub"],
    grant_types_supported: []
  };
  router.get("/.well-known/openid-configuration", (_req, res) => {
    res.json(config);
  });
  router.get("/.well-known/jwks.json", async (_req, res) => {
    const {keys} = await tokenIssuer.listPublicKeys();
    res.json({keys});
  });
  router.get("/v1/token", (_req, res) => {
    res.status(501).send("Not Implemented");
  });
  router.get("/v1/userinfo", (_req, res) => {
    res.status(501).send("Not Implemented");
  });
  return router;
}

const CLOCK_MARGIN_S = 10;
class IdentityClient {
  constructor(options) {
    this.discovery = options.discovery;
    this.issuer = options.issuer;
    this.keyStore = new jose.JWKS.KeyStore();
    this.keyStoreUpdated = 0;
  }
  async authenticate(token) {
    if (!token) {
      throw new Error("No token specified");
    }
    const key = await this.getKey(token);
    if (!key) {
      throw new Error("No signing key matching token found");
    }
    const decoded = jose.JWT.IdToken.verify(token, key, {
      algorithms: ["ES256"],
      audience: "backstage",
      issuer: this.issuer
    });
    const user = {
      id: decoded.sub,
      idToken: token
    };
    return user;
  }
  static getBearerToken(authorizationHeader) {
    if (typeof authorizationHeader !== "string") {
      return void 0;
    }
    const matches = authorizationHeader.match(/Bearer\s+(\S+)/i);
    return matches == null ? void 0 : matches[1];
  }
  async getKey(rawJwtToken) {
    const {header, payload} = jose.JWT.decode(rawJwtToken, {
      complete: true
    });
    const keyStoreHasKey = !!this.keyStore.get({kid: header.kid});
    const issuedAfterLastRefresh = (payload == null ? void 0 : payload.iat) && payload.iat > this.keyStoreUpdated - CLOCK_MARGIN_S;
    if (!keyStoreHasKey && issuedAfterLastRefresh) {
      await this.refreshKeyStore();
    }
    return this.keyStore.get({kid: header.kid});
  }
  async listPublicKeys() {
    const url = `${await this.discovery.getBaseUrl("auth")}/.well-known/jwks.json`;
    const response = await fetch__default['default'](url);
    if (!response.ok) {
      const payload = await response.text();
      const message = `Request failed with ${response.status} ${response.statusText}, ${payload}`;
      throw new Error(message);
    }
    const publicKeys = await response.json();
    return publicKeys;
  }
  async refreshKeyStore() {
    const now = Date.now() / 1e3;
    const publicKeys = await this.listPublicKeys();
    this.keyStore = jose.JWKS.asKeyStore({
      keys: publicKeys.keys.map((key) => key)
    });
    this.keyStoreUpdated = now;
  }
}

const MS_IN_S = 1e3;
class TokenFactory {
  constructor(options) {
    this.issuer = options.issuer;
    this.logger = options.logger;
    this.keyStore = options.keyStore;
    this.keyDurationSeconds = options.keyDurationSeconds;
  }
  async issueToken(params) {
    const key = await this.getKey();
    const iss = this.issuer;
    const sub = params.claims.sub;
    const aud = "backstage";
    const iat = Math.floor(Date.now() / MS_IN_S);
    const exp = iat + this.keyDurationSeconds;
    this.logger.info(`Issuing token for ${sub}`);
    return jose.JWS.sign({iss, sub, aud, iat, exp}, key, {
      alg: key.alg,
      kid: key.kid
    });
  }
  async listPublicKeys() {
    const {items: keys} = await this.keyStore.listKeys();
    const validKeys = [];
    const expiredKeys = [];
    for (const key of keys) {
      const expireAt = luxon.DateTime.fromJSDate(key.createdAt).plus({
        seconds: 3 * this.keyDurationSeconds
      });
      if (expireAt < luxon.DateTime.local()) {
        expiredKeys.push(key);
      } else {
        validKeys.push(key);
      }
    }
    if (expiredKeys.length > 0) {
      const kids = expiredKeys.map(({key}) => key.kid);
      this.logger.info(`Removing expired signing keys, '${kids.join("', '")}'`);
      this.keyStore.removeKeys(kids).catch((error) => {
        this.logger.error(`Failed to remove expired keys, ${error}`);
      });
    }
    return {keys: validKeys.map(({key}) => key)};
  }
  async getKey() {
    if (this.privateKeyPromise) {
      if (this.keyExpiry && luxon.DateTime.fromJSDate(this.keyExpiry) > luxon.DateTime.local()) {
        return this.privateKeyPromise;
      }
      this.logger.info(`Signing key has expired, generating new key`);
      delete this.privateKeyPromise;
    }
    this.keyExpiry = luxon.DateTime.utc().plus({
      seconds: this.keyDurationSeconds
    }).toJSDate();
    const promise = (async () => {
      const key = await jose.JWK.generate("EC", "P-256", {
        use: "sig",
        kid: uuid.v4(),
        alg: "ES256"
      });
      this.logger.info(`Created new signing key ${key.kid}`);
      await this.keyStore.addKey(key.toJWK(false));
      return key;
    })();
    this.privateKeyPromise = promise;
    try {
      await promise;
    } catch (error) {
      this.logger.error(`Failed to generate new signing key, ${error}`);
      delete this.keyExpiry;
      delete this.privateKeyPromise;
    }
    return promise;
  }
}

const migrationsDir = backendCommon.resolvePackagePath("@backstage/plugin-auth-backend", "migrations");
const TABLE = "signing_keys";
const parseDate = (date) => {
  const parsedDate = typeof date === "string" ? luxon.DateTime.fromSQL(date, {zone: "UTC"}) : luxon.DateTime.fromJSDate(date);
  if (!parsedDate.isValid) {
    throw new Error(`Failed to parse date, reason: ${parsedDate.invalidReason}, explanation: ${parsedDate.invalidExplanation}`);
  }
  return parsedDate.toJSDate();
};
class DatabaseKeyStore {
  static async create(options) {
    const {database} = options;
    await database.migrate.latest({
      directory: migrationsDir
    });
    return new DatabaseKeyStore(options);
  }
  constructor(options) {
    this.database = options.database;
  }
  async addKey(key) {
    await this.database(TABLE).insert({
      kid: key.kid,
      key: JSON.stringify(key)
    });
  }
  async listKeys() {
    const rows = await this.database(TABLE).select();
    return {
      items: rows.map((row) => ({
        key: JSON.parse(row.key),
        createdAt: parseDate(row.created_at)
      }))
    };
  }
  async removeKeys(kids) {
    await this.database(TABLE).delete().whereIn("kid", kids);
  }
}

async function createRouter({
  logger,
  config,
  discovery,
  database,
  providerFactories
}) {
  const router = Router__default['default']();
  const appUrl = config.getString("app.baseUrl");
  const authUrl = await discovery.getExternalBaseUrl("auth");
  const keyDurationSeconds = 3600;
  const keyStore = await DatabaseKeyStore.create({
    database: await database.getClient()
  });
  const tokenIssuer = new TokenFactory({
    issuer: authUrl,
    keyStore,
    keyDurationSeconds,
    logger: logger.child({component: "token-factory"})
  });
  const catalogApi = new catalogClient.CatalogClient({discoveryApi: discovery});
  const secret = config.getOptionalString("auth.session.secret");
  if (secret) {
    router.use(cookieParser__default['default'](secret));
    router.use(session__default['default']({secret, saveUninitialized: false, resave: false}));
    router.use(passport__default['default'].initialize());
    router.use(passport__default['default'].session());
  } else {
    router.use(cookieParser__default['default']());
  }
  router.use(express__default['default'].urlencoded({extended: false}));
  router.use(express__default['default'].json());
  const allProviderFactories = {
    ...factories,
    ...providerFactories
  };
  const providersConfig = config.getConfig("auth.providers");
  const providers = providersConfig.keys();
  for (const providerId of providers) {
    logger.info(`Configuring provider, ${providerId}`);
    try {
      const providerFactory = allProviderFactories[providerId];
      if (!providerFactory) {
        throw Error(`No auth provider available for '${providerId}'`);
      }
      const provider = providerFactory({
        providerId,
        globalConfig: {baseUrl: authUrl, appUrl},
        config: providersConfig.getConfig(providerId),
        logger,
        tokenIssuer,
        discovery,
        catalogApi
      });
      const r = Router__default['default']();
      r.get("/start", provider.start.bind(provider));
      r.get("/handler/frame", provider.frameHandler.bind(provider));
      r.post("/handler/frame", provider.frameHandler.bind(provider));
      if (provider.logout) {
        r.post("/logout", provider.logout.bind(provider));
      }
      if (provider.refresh) {
        r.get("/refresh", provider.refresh.bind(provider));
      }
      router.use(`/${providerId}`, r);
    } catch (e) {
      if (process.env.NODE_ENV !== "development") {
        throw new Error(`Failed to initialize ${providerId} auth provider, ${e.message}`);
      }
      logger.warn(`Skipping ${providerId} auth provider, ${e.message}`);
    }
  }
  router.use(createOidcRouter({
    tokenIssuer,
    baseUrl: authUrl
  }));
  router.use("/:provider/", (req) => {
    const {provider} = req.params;
    throw new errors.NotFoundError(`No auth provider registered for '${provider}'`);
  });
  return router;
}

exports.IdentityClient = IdentityClient;
exports.OAuthAdapter = OAuthAdapter;
exports.OAuthEnvironmentHandler = OAuthEnvironmentHandler;
exports.createRouter = createRouter;
exports.defaultAuthProviderFactories = factories;
exports.encodeState = encodeState;
exports.ensuresXRequestedWith = ensuresXRequestedWith;
exports.postMessageResponse = postMessageResponse;
exports.readState = readState;
exports.verifyNonce = verifyNonce;
//# sourceMappingURL=index.cjs.js.map
