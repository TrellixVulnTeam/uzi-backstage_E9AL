import { createApiRef, createRouteRef, useRouteRefParams, useApi, errorApiRef, storageApiRef, Link, OverflowTooltip, Table } from '@backstage/core';
import React, { createContext, useEffect, useContext, useState, useCallback, forwardRef } from 'react';
import { useNavigate, generatePath } from 'react-router';
import { useAsync, useObservable } from 'react-use';
import { ENTITY_DEFAULT_NAMESPACE, serializeEntityRef, RELATION_MEMBER_OF, getEntityName, RELATION_OWNED_BY, RELATION_PART_OF } from '@backstage/catalog-model';
import { groupBy, chunk } from 'lodash';
import { makeStyles } from '@material-ui/core';

const catalogApiRef = createApiRef({
  id: "plugin.catalog.service",
  description: "Used by the Catalog plugin to make requests to accompanying backend"
});

const NoIcon = () => null;
const rootRoute = createRouteRef({
  icon: NoIcon,
  path: "",
  title: "Catalog"
});
const catalogRouteRef = rootRoute;
const entityRoute = createRouteRef({
  icon: NoIcon,
  path: ":namespace/:kind/:name/*",
  title: "Entity",
  params: ["namespace", "kind", "name"]
});
const entityRouteRef = entityRoute;
function entityRouteParams(entity) {
  var _a, _b;
  return {
    kind: entity.kind.toLowerCase(),
    namespace: (_b = (_a = entity.metadata.namespace) == null ? void 0 : _a.toLowerCase()) != null ? _b : ENTITY_DEFAULT_NAMESPACE,
    name: entity.metadata.name
  };
}

const useEntityCompoundName = () => {
  const {kind, namespace, name} = useRouteRefParams(entityRouteRef);
  return {kind, namespace, name};
};

const EntityContext = createContext({
  entity: void 0,
  loading: true,
  error: void 0
});
const useEntityFromUrl = () => {
  const {kind, namespace, name} = useEntityCompoundName();
  const navigate = useNavigate();
  const errorApi = useApi(errorApiRef);
  const catalogApi = useApi(catalogApiRef);
  const {value: entity, error, loading} = useAsync(() => catalogApi.getEntityByName({kind, namespace, name}), [catalogApi, kind, namespace, name]);
  useEffect(() => {
    if (!name) {
      errorApi.post(new Error("No name provided!"));
      navigate("/");
    }
  }, [errorApi, navigate, error, loading, entity, name]);
  return {entity, loading, error};
};
function useEntity() {
  const {entity, loading, error} = useContext(EntityContext);
  return {entity, loading, error};
}

const BATCH_SIZE = 20;
function useRelatedEntities(entity, {type, kind}) {
  const catalogApi = useApi(catalogApiRef);
  const {loading, value: entities, error} = useAsync(async () => {
    const relations = entity.relations && entity.relations.filter((r) => (!type || r.type.toLowerCase() === type.toLowerCase()) && (!kind || r.target.kind.toLowerCase() === kind.toLowerCase()));
    if (!relations) {
      return [];
    }
    const relationsByKindAndNamespace = Object.values(groupBy(relations, ({target}) => {
      return `${target.kind}:${target.namespace}`.toLowerCase();
    }));
    const batchedRelationsByKindAndNamespace = [];
    for (const rs of relationsByKindAndNamespace) {
      batchedRelationsByKindAndNamespace.push({
        kind: rs[0].target.kind,
        namespace: rs[0].target.namespace,
        nameBatches: chunk(rs.map((r) => r.target.name), BATCH_SIZE)
      });
    }
    const results = await Promise.all(batchedRelationsByKindAndNamespace.flatMap((rs) => {
      return rs.nameBatches.map((names) => {
        return catalogApi.getEntities({
          filter: {
            kind: rs.kind,
            "metadata.namespace": rs.namespace,
            "metadata.name": names
          }
        });
      });
    }));
    return results.flatMap((r) => r.items);
  }, [entity, type]);
  return {
    entities,
    loading,
    error
  };
}

const buildEntityKey = (component) => {
  var _a;
  return `entity:${component.kind}:${(_a = component.metadata.namespace) != null ? _a : "default"}:${component.metadata.name}`;
};
const useStarredEntities = () => {
  var _a;
  const storageApi = useApi(storageApiRef);
  const settingsStore = storageApi.forBucket("settings");
  const rawStarredEntityKeys = (_a = settingsStore.get("starredEntities")) != null ? _a : [];
  const [starredEntities, setStarredEntities] = useState(new Set(rawStarredEntityKeys));
  const observedItems = useObservable(settingsStore.observe$("starredEntities"));
  useEffect(() => {
    var _a2;
    if (observedItems == null ? void 0 : observedItems.newValue) {
      const currentValue = (_a2 = observedItems == null ? void 0 : observedItems.newValue) != null ? _a2 : [];
      setStarredEntities(new Set(currentValue));
    }
  }, [observedItems == null ? void 0 : observedItems.newValue]);
  const toggleStarredEntity = useCallback((entity) => {
    const entityKey = buildEntityKey(entity);
    if (starredEntities.has(entityKey)) {
      starredEntities.delete(entityKey);
    } else {
      starredEntities.add(entityKey);
    }
    settingsStore.set("starredEntities", Array.from(starredEntities));
  }, [starredEntities, settingsStore]);
  const isStarredEntity = useCallback((entity) => {
    const entityKey = buildEntityKey(entity);
    return starredEntities.has(entityKey);
  }, [starredEntities]);
  return {
    starredEntities,
    toggleStarredEntity,
    isStarredEntity
  };
};

const EntityProvider = ({entity, children}) => /* @__PURE__ */ React.createElement(EntityContext.Provider, {
  value: {
    entity,
    loading: !Boolean(entity),
    error: void 0
  }
}, children);

function formatEntityRefTitle(entityRef, opts) {
  const defaultKind = opts == null ? void 0 : opts.defaultKind;
  let kind;
  let namespace;
  let name;
  if ("metadata" in entityRef) {
    kind = entityRef.kind;
    namespace = entityRef.metadata.namespace;
    name = entityRef.metadata.name;
  } else {
    kind = entityRef.kind;
    namespace = entityRef.namespace;
    name = entityRef.name;
  }
  if (namespace === ENTITY_DEFAULT_NAMESPACE) {
    namespace = void 0;
  }
  kind = kind.toLowerCase();
  return `${serializeEntityRef({
    kind: defaultKind && defaultKind.toLowerCase() === kind ? void 0 : kind,
    name,
    namespace
  })}`;
}

const EntityRefLink = forwardRef((props, ref) => {
  var _a;
  const {entityRef, defaultKind, children, ...linkProps} = props;
  let kind;
  let namespace;
  let name;
  if ("metadata" in entityRef) {
    kind = entityRef.kind;
    namespace = entityRef.metadata.namespace;
    name = entityRef.metadata.name;
  } else {
    kind = entityRef.kind;
    namespace = entityRef.namespace;
    name = entityRef.name;
  }
  kind = kind.toLocaleLowerCase("en-US");
  const routeParams = {
    kind,
    namespace: (_a = namespace == null ? void 0 : namespace.toLocaleLowerCase("en-US")) != null ? _a : ENTITY_DEFAULT_NAMESPACE,
    name
  };
  return /* @__PURE__ */ React.createElement(Link, {
    ...linkProps,
    ref,
    to: generatePath(`/catalog/${entityRoute.path}`, routeParams)
  }, children, !children && formatEntityRefTitle(entityRef, {defaultKind}));
});

const EntityRefLinks = ({
  entityRefs,
  defaultKind,
  ...linkProps
}) => /* @__PURE__ */ React.createElement(React.Fragment, null, entityRefs.map((r, i) => /* @__PURE__ */ React.createElement(React.Fragment, {
  key: i
}, i > 0 && ", ", /* @__PURE__ */ React.createElement(EntityRefLink, {
  ...linkProps,
  entityRef: r,
  defaultKind
}))));

function getEntityRelations(entity, relationType, filter) {
  var _a, _b;
  let entityNames = ((_b = (_a = entity == null ? void 0 : entity.relations) == null ? void 0 : _a.filter((r) => r.type === relationType)) == null ? void 0 : _b.map((r) => r.target)) || [];
  if (filter == null ? void 0 : filter.kind) {
    entityNames = entityNames == null ? void 0 : entityNames.filter((e) => e.kind.toLowerCase() === filter.kind.toLowerCase());
  }
  return entityNames;
}

function isOwnerOf(owner, owned) {
  const possibleOwners = [
    ...getEntityRelations(owner, RELATION_MEMBER_OF, {kind: "group"}),
    ...owner ? [getEntityName(owner)] : []
  ];
  const owners = getEntityRelations(owned, RELATION_OWNED_BY);
  for (const ownerItem of owners) {
    if (possibleOwners.find((o) => ownerItem.kind.toLowerCase() === o.kind.toLowerCase() && ownerItem.namespace.toLowerCase() === o.namespace.toLowerCase() && ownerItem.name.toLowerCase() === o.name.toLowerCase()) !== void 0) {
      return true;
    }
  }
  return false;
}

function createEntityRefColumn({
  defaultKind
}) {
  function formatContent(entity) {
    return formatEntityRefTitle(entity, {
      defaultKind
    });
  }
  return {
    title: "Name",
    highlight: true,
    customFilterAndSearch(filter, entity) {
      return formatContent(entity).includes(filter);
    },
    customSort(entity1, entity2) {
      return formatContent(entity1).localeCompare(formatContent(entity2));
    },
    render: (entity) => /* @__PURE__ */ React.createElement(EntityRefLink, {
      entityRef: entity,
      defaultKind
    })
  };
}
function createEntityRelationColumn({
  title,
  relation,
  defaultKind,
  filter: entityFilter
}) {
  function getRelations(entity) {
    return getEntityRelations(entity, relation, entityFilter);
  }
  function formatContent(entity) {
    return getRelations(entity).map((r) => formatEntityRefTitle(r, {defaultKind})).join(", ");
  }
  return {
    title,
    customFilterAndSearch(filter, entity) {
      return formatContent(entity).includes(filter);
    },
    customSort(entity1, entity2) {
      return formatContent(entity1).localeCompare(formatContent(entity2));
    },
    render: (entity) => {
      return /* @__PURE__ */ React.createElement(EntityRefLinks, {
        entityRefs: getRelations(entity),
        defaultKind
      });
    }
  };
}
function createOwnerColumn() {
  return createEntityRelationColumn({
    title: "Owner",
    relation: RELATION_OWNED_BY,
    defaultKind: "group"
  });
}
function createDomainColumn() {
  return createEntityRelationColumn({
    title: "Domain",
    relation: RELATION_PART_OF,
    defaultKind: "domain",
    filter: {
      kind: "domain"
    }
  });
}
function createSystemColumn() {
  return createEntityRelationColumn({
    title: "System",
    relation: RELATION_PART_OF,
    defaultKind: "system",
    filter: {
      kind: "system"
    }
  });
}
function createMetadataDescriptionColumn() {
  return {
    title: "Description",
    field: "metadata.description",
    render: (entity) => /* @__PURE__ */ React.createElement(OverflowTooltip, {
      text: entity.metadata.description,
      placement: "bottom-start"
    }),
    width: "auto"
  };
}
function createSpecLifecycleColumn() {
  return {
    title: "Lifecycle",
    field: "spec.lifecycle"
  };
}
function createSpecTypeColumn() {
  return {
    title: "Type",
    field: "spec.type"
  };
}

var columnFactories = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createEntityRefColumn: createEntityRefColumn,
  createEntityRelationColumn: createEntityRelationColumn,
  createOwnerColumn: createOwnerColumn,
  createDomainColumn: createDomainColumn,
  createSystemColumn: createSystemColumn,
  createMetadataDescriptionColumn: createMetadataDescriptionColumn,
  createSpecLifecycleColumn: createSpecLifecycleColumn,
  createSpecTypeColumn: createSpecTypeColumn
});

const systemEntityColumns = [
  createEntityRefColumn({defaultKind: "system"}),
  createDomainColumn(),
  createOwnerColumn(),
  createMetadataDescriptionColumn()
];
const componentEntityColumns = [
  createEntityRefColumn({defaultKind: "component"}),
  createSystemColumn(),
  createOwnerColumn(),
  createSpecTypeColumn(),
  createSpecLifecycleColumn(),
  createMetadataDescriptionColumn()
];

const useStyles = makeStyles((theme) => ({
  empty: {
    padding: theme.spacing(2),
    display: "flex",
    justifyContent: "center"
  }
}));
function EntityTable({
  entities,
  title,
  emptyContent,
  variant = "gridItem",
  columns
}) {
  const classes = useStyles();
  const tableStyle = {
    minWidth: "0",
    width: "100%"
  };
  if (variant === "gridItem") {
    tableStyle.height = "calc(100% - 10px)";
  }
  return /* @__PURE__ */ React.createElement(Table, {
    columns,
    title,
    style: tableStyle,
    emptyContent: emptyContent && /* @__PURE__ */ React.createElement("div", {
      className: classes.empty
    }, emptyContent),
    options: {
      search: false,
      paging: false,
      actionsColumnIndex: -1,
      padding: "dense"
    },
    data: entities
  });
}
EntityTable.columns = columnFactories;
EntityTable.systemEntityColumns = systemEntityColumns;
EntityTable.componentEntityColumns = componentEntityColumns;

export { EntityContext, EntityProvider, EntityRefLink, EntityRefLinks, EntityTable, catalogApiRef, catalogRouteRef, entityRoute, entityRouteParams, entityRouteRef, formatEntityRefTitle, getEntityRelations, isOwnerOf, rootRoute, useEntity, useEntityCompoundName, useEntityFromUrl, useRelatedEntities, useStarredEntities };
//# sourceMappingURL=index.esm.js.map
