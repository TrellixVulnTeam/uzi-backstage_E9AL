import { EDIT_URL_ANNOTATION, VIEW_URL_ANNOTATION, SOURCE_LOCATION_ANNOTATION, parseLocationReference, RELATION_PART_OF, RELATION_OWNED_BY, RELATION_PROVIDES_API, RELATION_CONSUMES_API, ENTITY_DEFAULT_NAMESPACE, ORIGIN_LOCATION_ANNOTATION, getEntityName } from '@backstage/catalog-model';
import { useApi, HeaderIconLinkRow, alertApiRef, configApiRef, Progress, ResponseErrorPanel, attachComponentData, Page, Header, RoutedTabs, Content, HeaderLabel, HeaderTabs, WarningPanel, Link, OverflowTooltip, CodeSnippet, Table, createExternalRouteRef, identityApiRef, errorApiRef, useRouteRef, ContentHeader, SupportButton, createPlugin, createApiFactory, discoveryApiRef, createRoutableExtension, createComponentExtension } from '@backstage/core';
import { scmIntegrationsApiRef } from '@backstage/integration-react';
import { getEntityRelations, EntityRefLinks, useEntity, useStarredEntities, catalogApiRef, EntityRefLink, useEntityCompoundName, EntityContext, formatEntityRefTitle, isOwnerOf, useEntityFromUrl, rootRoute, entityRoute, catalogRouteRef, entityRouteRef } from '@backstage/plugin-catalog-react';
import { makeStyles, Typography, Grid, Chip, Card, CardHeader, IconButton, Divider, CardContent, MenuItem, ListItemIcon, ListItemText, Popover, MenuList, withStyles, Tooltip, Dialog, DialogTitle, DialogContent, DialogActions, Button, Box, DialogContentText, List, ListItemSecondaryAction, ListItem, Checkbox, Link as Link$2 } from '@material-ui/core';
import DocsIcon from '@material-ui/icons/Description';
import EditIcon from '@material-ui/icons/Edit';
import ExtensionIcon from '@material-ui/icons/Extension';
import React, { useState, useCallback, useContext, Children, isValidElement, Fragment, useMemo, createContext, useRef, useEffect } from 'react';
import CodeIcon from '@material-ui/icons/Code';
import GitHubIcon from '@material-ui/icons/GitHub';
import { Alert as Alert$1 } from '@material-ui/lab';
import { useNavigate, useParams, Navigate, matchRoutes, useRoutes, Routes, Route as Route$1 } from 'react-router';
import { makeStyles as makeStyles$1 } from '@material-ui/core/styles';
import Cancel from '@material-ui/icons/Cancel';
import MoreVert from '@material-ui/icons/MoreVert';
import StarBorder from '@material-ui/icons/StarBorder';
import Star from '@material-ui/icons/Star';
import Alert from '@material-ui/lab/Alert';
import { useAsync, useAsyncFn } from 'react-use';
import { Helmet } from 'react-helmet';
import OpenInNew from '@material-ui/icons/OpenInNew';
import SettingsIcon from '@material-ui/icons/Settings';
import { Link as Link$1 } from 'react-router-dom';
import IlloSvgUrl from '../components/EntityNotFound/Illo/illo.svg';
import { CatalogClient } from '@backstage/catalog-client';

function getEntityMetadataViewUrl(entity) {
  var _a;
  return (_a = entity.metadata.annotations) == null ? void 0 : _a[VIEW_URL_ANNOTATION];
}
function getEntityMetadataEditUrl(entity) {
  var _a;
  return (_a = entity.metadata.annotations) == null ? void 0 : _a[EDIT_URL_ANNOTATION];
}

function getEntitySourceLocation(entity, scmIntegrationsApi) {
  var _a;
  const sourceLocation = (_a = entity.metadata.annotations) == null ? void 0 : _a[SOURCE_LOCATION_ANNOTATION];
  if (!sourceLocation) {
    return void 0;
  }
  try {
    const sourceLocationRef = parseLocationReference(sourceLocation);
    const integration = scmIntegrationsApi.byUrl(sourceLocationRef.target);
    return {
      locationTargetUrl: sourceLocationRef.target,
      integrationType: integration == null ? void 0 : integration.type
    };
  } catch {
    return void 0;
  }
}

const useStyles = makeStyles((theme) => ({
  value: {
    fontWeight: "bold",
    overflow: "hidden",
    lineHeight: "24px",
    wordBreak: "break-word"
  },
  label: {
    color: theme.palette.text.secondary,
    textTransform: "uppercase",
    fontSize: "10px",
    fontWeight: "bold",
    letterSpacing: 0.5,
    overflow: "hidden",
    whiteSpace: "nowrap"
  }
}));
const AboutField = ({label, value, gridSizes, children}) => {
  const classes = useStyles();
  const content = React.Children.count(children) ? children : /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    className: classes.value
  }, value || `unknown`);
  return /* @__PURE__ */ React.createElement(Grid, {
    item: true,
    ...gridSizes
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    className: classes.label
  }, label), content);
};

const useStyles$1 = makeStyles({
  description: {
    wordBreak: "break-word"
  }
});
const AboutContent = ({entity}) => {
  var _a, _b, _c, _d;
  const classes = useStyles$1();
  const isSystem = entity.kind.toLocaleLowerCase("en-US") === "system";
  const isDomain = entity.kind.toLocaleLowerCase("en-US") === "domain";
  const isResource = entity.kind.toLocaleLowerCase("en-US") === "resource";
  const isComponent = entity.kind.toLocaleLowerCase("en-US") === "component";
  const partOfSystemRelations = getEntityRelations(entity, RELATION_PART_OF, {
    kind: "system"
  });
  const partOfComponentRelations = getEntityRelations(entity, RELATION_PART_OF, {
    kind: "component"
  });
  const partOfDomainRelations = getEntityRelations(entity, RELATION_PART_OF, {
    kind: "domain"
  });
  const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
  return /* @__PURE__ */ React.createElement(Grid, {
    container: true
  }, /* @__PURE__ */ React.createElement(AboutField, {
    label: "Description",
    gridSizes: {xs: 12}
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    paragraph: true,
    className: classes.description
  }, ((_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.description) || "No description")), /* @__PURE__ */ React.createElement(AboutField, {
    label: "Owner",
    gridSizes: {xs: 12, sm: 6, lg: 4}
  }, /* @__PURE__ */ React.createElement(EntityRefLinks, {
    entityRefs: ownedByRelations,
    defaultKind: "group"
  })), isSystem && /* @__PURE__ */ React.createElement(AboutField, {
    label: "Domain",
    value: "No Domain",
    gridSizes: {xs: 12, sm: 6, lg: 4}
  }, /* @__PURE__ */ React.createElement(EntityRefLinks, {
    entityRefs: partOfDomainRelations,
    defaultKind: "domain"
  })), !isSystem && !isDomain && /* @__PURE__ */ React.createElement(AboutField, {
    label: "System",
    value: "No System",
    gridSizes: {xs: 12, sm: 6, lg: 4}
  }, /* @__PURE__ */ React.createElement(EntityRefLinks, {
    entityRefs: partOfSystemRelations,
    defaultKind: "system"
  })), isComponent && partOfComponentRelations.length > 0 && /* @__PURE__ */ React.createElement(AboutField, {
    label: "Parent Component",
    value: "No Parent Component",
    gridSizes: {xs: 12, sm: 6, lg: 4}
  }, /* @__PURE__ */ React.createElement(EntityRefLinks, {
    entityRefs: partOfComponentRelations,
    defaultKind: "component"
  })), !isSystem && !isDomain && /* @__PURE__ */ React.createElement(AboutField, {
    label: "Type",
    value: (_b = entity == null ? void 0 : entity.spec) == null ? void 0 : _b.type,
    gridSizes: {xs: 12, sm: 6, lg: 4}
  }), !isSystem && !isDomain && !isResource && /* @__PURE__ */ React.createElement(AboutField, {
    label: "Lifecycle",
    value: (_c = entity == null ? void 0 : entity.spec) == null ? void 0 : _c.lifecycle,
    gridSizes: {xs: 12, sm: 6, lg: 4}
  }), /* @__PURE__ */ React.createElement(AboutField, {
    label: "Tags",
    value: "No Tags",
    gridSizes: {xs: 12, sm: 6, lg: 4}
  }, (((_d = entity == null ? void 0 : entity.metadata) == null ? void 0 : _d.tags) || []).map((t) => /* @__PURE__ */ React.createElement(Chip, {
    key: t,
    size: "small",
    label: t
  }))));
};

const ScmIntegrationIcon = ({type}) => {
  switch (type) {
    case "github":
      return /* @__PURE__ */ React.createElement(GitHubIcon, null);
    default:
      return /* @__PURE__ */ React.createElement(CodeIcon, null);
  }
};

const useStyles$2 = makeStyles({
  gridItemCard: {
    display: "flex",
    flexDirection: "column",
    height: "calc(100% - 10px)",
    marginBottom: "10px"
  },
  gridItemCardContent: {
    flex: 1
  }
});
function AboutCard({variant}) {
  var _a;
  const classes = useStyles$2();
  const {entity} = useEntity();
  const scmIntegrationsApi = useApi(scmIntegrationsApiRef);
  const entitySourceLocation = getEntitySourceLocation(entity, scmIntegrationsApi);
  const entityMetadataEditUrl = getEntityMetadataEditUrl(entity);
  const providesApiRelations = getEntityRelations(entity, RELATION_PROVIDES_API);
  const consumesApiRelations = getEntityRelations(entity, RELATION_CONSUMES_API);
  const hasApis = providesApiRelations.length > 0 || consumesApiRelations.length > 0;
  const viewInSource = {
    label: "View Source",
    disabled: !entitySourceLocation,
    icon: /* @__PURE__ */ React.createElement(ScmIntegrationIcon, {
      type: entitySourceLocation == null ? void 0 : entitySourceLocation.integrationType
    }),
    href: entitySourceLocation == null ? void 0 : entitySourceLocation.locationTargetUrl
  };
  const viewInTechDocs = {
    label: "View TechDocs",
    disabled: !((_a = entity.metadata.annotations) == null ? void 0 : _a["backstage.io/techdocs-ref"]),
    icon: /* @__PURE__ */ React.createElement(DocsIcon, null),
    href: `/docs/${entity.metadata.namespace || ENTITY_DEFAULT_NAMESPACE}/${entity.kind}/${entity.metadata.name}`
  };
  const viewApi = {
    title: hasApis ? "" : "No APIs available",
    label: "View API",
    disabled: !hasApis,
    icon: /* @__PURE__ */ React.createElement(ExtensionIcon, null),
    href: "api"
  };
  return /* @__PURE__ */ React.createElement(Card, {
    className: variant === "gridItem" ? classes.gridItemCard : ""
  }, /* @__PURE__ */ React.createElement(CardHeader, {
    title: "About",
    action: /* @__PURE__ */ React.createElement(IconButton, {
      "aria-label": "Edit",
      disabled: !entityMetadataEditUrl,
      title: "Edit Metadata",
      onClick: () => {
        window.open(entityMetadataEditUrl != null ? entityMetadataEditUrl : "#", "_blank");
      }
    }, /* @__PURE__ */ React.createElement(EditIcon, null)),
    subheader: /* @__PURE__ */ React.createElement(HeaderIconLinkRow, {
      links: [viewInSource, viewInTechDocs, viewApi]
    })
  }), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(CardContent, {
    className: variant === "gridItem" ? classes.gridItemCardContent : ""
  }, /* @__PURE__ */ React.createElement(AboutContent, {
    entity
  })));
}

const useStyles$3 = makeStyles$1({
  button: {
    color: "white"
  }
});
const EntityContextMenu = ({
  UNSTABLE_extraContextMenuItems,
  onUnregisterEntity
}) => {
  const [anchorEl, setAnchorEl] = useState();
  const classes = useStyles$3();
  const onOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const onClose = () => {
    setAnchorEl(void 0);
  };
  const extraItems = UNSTABLE_extraContextMenuItems && [
    ...UNSTABLE_extraContextMenuItems.map((item) => /* @__PURE__ */ React.createElement(MenuItem, {
      key: item.title,
      onClick: () => {
        onClose();
        item.onClick();
      }
    }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(item.Icon, {
      fontSize: "small"
    })), /* @__PURE__ */ React.createElement(ListItemText, {
      primary: item.title
    }))),
    /* @__PURE__ */ React.createElement(Divider, {
      key: "the divider is here!"
    })
  ];
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(IconButton, {
    "aria-label": "more",
    "aria-controls": "long-menu",
    "aria-haspopup": "true",
    onClick: onOpen,
    "data-testid": "menu-button",
    className: classes.button
  }, /* @__PURE__ */ React.createElement(MoreVert, null)), /* @__PURE__ */ React.createElement(Popover, {
    open: Boolean(anchorEl),
    onClose,
    anchorEl,
    anchorOrigin: {vertical: "bottom", horizontal: "right"},
    transformOrigin: {vertical: "top", horizontal: "right"}
  }, /* @__PURE__ */ React.createElement(MenuList, null, extraItems, /* @__PURE__ */ React.createElement(MenuItem, {
    onClick: () => {
      onClose();
      onUnregisterEntity();
    }
  }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Cancel, {
    fontSize: "small"
  })), /* @__PURE__ */ React.createElement(ListItemText, {
    primary: "Unregister entity"
  })))));
};

const YellowStar = withStyles({
  root: {
    color: "#f3ba37"
  }
})(Star);
const favouriteEntityTooltip = (isStarred) => isStarred ? "Remove from favorites" : "Add to favorites";
const favouriteEntityIcon = (isStarred) => isStarred ? /* @__PURE__ */ React.createElement(YellowStar, null) : /* @__PURE__ */ React.createElement(StarBorder, null);
const FavouriteEntity = (props) => {
  const {toggleStarredEntity, isStarredEntity} = useStarredEntities();
  const isStarred = isStarredEntity(props.entity);
  return /* @__PURE__ */ React.createElement(IconButton, {
    color: "inherit",
    ...props,
    onClick: () => toggleStarredEntity(props.entity)
  }, /* @__PURE__ */ React.createElement(Tooltip, {
    title: favouriteEntityTooltip(isStarred)
  }, favouriteEntityIcon(isStarred)));
};

function useUnregisterEntityDialogState(entity) {
  var _a;
  const catalogApi = useApi(catalogApiRef);
  const locationRef = (_a = entity.metadata.annotations) == null ? void 0 : _a[ORIGIN_LOCATION_ANNOTATION];
  const uid = entity.metadata.uid;
  const isBootstrap = locationRef === "bootstrap:bootstrap";
  const prerequisites = useAsync(async () => {
    const locationPromise = catalogApi.getOriginLocationByEntity(entity);
    let colocatedEntitiesPromise;
    if (!locationRef) {
      colocatedEntitiesPromise = Promise.resolve([]);
    } else {
      const locationAnnotationFilter = `metadata.annotations.${ORIGIN_LOCATION_ANNOTATION}`;
      colocatedEntitiesPromise = catalogApi.getEntities({
        filter: {[locationAnnotationFilter]: locationRef},
        fields: [
          "kind",
          "metadata.uid",
          "metadata.name",
          "metadata.namespace"
        ]
      }).then((response) => response.items);
    }
    return Promise.all([locationPromise, colocatedEntitiesPromise]).then(([location2, colocatedEntities2]) => ({
      location: location2,
      colocatedEntities: colocatedEntities2
    }));
  }, [catalogApi, entity]);
  const unregisterLocation = useCallback(async function unregisterLocationFn() {
    const {location: location2, colocatedEntities: colocatedEntities2} = prerequisites.value;
    await catalogApi.removeLocationById(location2.id);
    await Promise.allSettled(colocatedEntities2.map((e) => catalogApi.removeEntityByUid(e.metadata.uid)));
  }, [catalogApi, prerequisites]);
  const deleteEntity = useCallback(async function deleteEntityFn() {
    await catalogApi.removeEntityByUid(uid);
  }, [catalogApi, uid]);
  if (isBootstrap) {
    return {type: "bootstrap", location: locationRef, deleteEntity};
  }
  const {loading, error, value} = prerequisites;
  if (loading) {
    return {type: "loading"};
  } else if (error) {
    return {type: "error", error};
  }
  const {location, colocatedEntities} = value;
  if (!location) {
    return {type: "only-delete", deleteEntity};
  }
  return {
    type: "unregister",
    location: locationRef,
    colocatedEntities: colocatedEntities.map(getEntityName),
    unregisterLocation,
    deleteEntity
  };
}

const useStyles$4 = makeStyles({
  advancedButton: {
    fontSize: "0.7em"
  }
});
const Contents = ({
  entity,
  onConfirm
}) => {
  var _a;
  const alertApi = useApi(alertApiRef);
  const configApi = useApi(configApiRef);
  const classes = useStyles$4();
  const state = useUnregisterEntityDialogState(entity);
  const [showDelete, setShowDelete] = useState(false);
  const [busy, setBusy] = useState(false);
  const appTitle = (_a = configApi.getOptionalString("app.title")) != null ? _a : "Backstage";
  const onUnregister = useCallback(async function onUnregisterFn() {
    if ("unregisterLocation" in state) {
      setBusy(true);
      try {
        await state.unregisterLocation();
        onConfirm();
      } catch (err) {
        alertApi.post({message: err.message});
      } finally {
        setBusy(false);
      }
    }
  }, [alertApi, onConfirm, state]);
  const onDelete = useCallback(async function onDeleteFn() {
    if ("deleteEntity" in state) {
      setBusy(true);
      try {
        await state.deleteEntity();
        onConfirm();
      } catch (err) {
        alertApi.post({message: err.message});
      } finally {
        setBusy(false);
      }
    }
  }, [alertApi, onConfirm, state]);
  if (state.type === "loading") {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  if (state.type === "error") {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, {
      error: state.error
    });
  }
  if (state.type === "bootstrap") {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert, {
      severity: "info"
    }, 'You cannot unregister this entity, since it originates from a protected Backstage configuration (location "', state.location, '"). If you believe this is in error, please contact the ', appTitle, " ", "integrator."), /* @__PURE__ */ React.createElement(Box, {
      marginTop: 2
    }, !showDelete && /* @__PURE__ */ React.createElement(Button, {
      variant: "text",
      size: "small",
      color: "primary",
      className: classes.advancedButton,
      onClick: () => setShowDelete(true)
    }, "Advanced Options"), showDelete && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, null, "You have the option to delete the entity itself from the catalog. Note that this should only be done if you know that the catalog file has been deleted at, or moved from, its origin location. If that is not the case, the entity will reappear shortly as the next refresh round is performed by the catalog."), /* @__PURE__ */ React.createElement(Button, {
      variant: "contained",
      color: "secondary",
      disabled: busy,
      onClick: onDelete
    }, "Delete Entity"))));
  }
  if (state.type === "only-delete") {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, null, "This entity does not seem to originate from a location. You therefore only have the option to delete it outright from the catalog."), /* @__PURE__ */ React.createElement(Button, {
      variant: "contained",
      color: "secondary",
      disabled: busy,
      onClick: onDelete
    }, "Delete Entity"));
  }
  if (state.type === "unregister") {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, null, "This action will unregister the following entities:"), /* @__PURE__ */ React.createElement(DialogContentText, {
      component: "ul"
    }, state.colocatedEntities.map((e) => /* @__PURE__ */ React.createElement("li", {
      key: `${e.kind}:${e.namespace}/${e.name}`
    }, /* @__PURE__ */ React.createElement(EntityRefLink, {
      entityRef: e
    })))), /* @__PURE__ */ React.createElement(DialogContentText, null, "Located at the following location:"), /* @__PURE__ */ React.createElement(DialogContentText, {
      component: "ul"
    }, /* @__PURE__ */ React.createElement("li", null, state.location)), /* @__PURE__ */ React.createElement(DialogContentText, null, "To undo, just re-register the entity in ", appTitle, "."), /* @__PURE__ */ React.createElement(Box, {
      marginTop: 2
    }, /* @__PURE__ */ React.createElement(Button, {
      variant: "contained",
      color: "secondary",
      disabled: busy,
      onClick: onUnregister
    }, "Unregister Location"), !showDelete && /* @__PURE__ */ React.createElement(Box, {
      component: "span",
      marginLeft: 2
    }, /* @__PURE__ */ React.createElement(Button, {
      variant: "text",
      size: "small",
      color: "primary",
      className: classes.advancedButton,
      onClick: () => setShowDelete(true)
    }, "Advanced Options"))), showDelete && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Box, {
      paddingTop: 4,
      paddingBottom: 4
    }, /* @__PURE__ */ React.createElement(Divider, null)), /* @__PURE__ */ React.createElement(DialogContentText, null, "You also have the option to delete the entity itself from the catalog. Note that this should only be done if you know that the catalog file has been deleted at, or moved from, its origin location. If that is not the case, the entity will reappear shortly as the next refresh round is performed by the catalog."), /* @__PURE__ */ React.createElement(Button, {
      variant: "contained",
      color: "secondary",
      disabled: busy,
      onClick: onDelete
    }, "Delete Entity")));
  }
  return /* @__PURE__ */ React.createElement(Alert, {
    severity: "error"
  }, "Internal error: Unknown state");
};
const UnregisterEntityDialog = ({
  open,
  onConfirm,
  onClose,
  entity
}) => /* @__PURE__ */ React.createElement(Dialog, {
  open,
  onClose
}, /* @__PURE__ */ React.createElement(DialogTitle, {
  id: "responsive-dialog-title"
}, "Are you sure you want to unregister this entity?"), /* @__PURE__ */ React.createElement(DialogContent, null, /* @__PURE__ */ React.createElement(Contents, {
  entity,
  onConfirm
})), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, {
  onClick: onClose,
  color: "primary"
}, "Cancel")));

const Route = () => null;
attachComponentData(Route, "core.gatherMountPoints", true);
function createSubRoutesFromChildren(childrenProps, entity) {
  const routeType = (/* @__PURE__ */ React.createElement(Route, {
    path: "",
    title: ""
  }, /* @__PURE__ */ React.createElement("div", null))).type;
  return Children.toArray(childrenProps).flatMap((child) => {
    if (!isValidElement(child)) {
      return [];
    }
    if (child.type === Fragment) {
      return createSubRoutesFromChildren(child.props.children, entity);
    }
    if (child.type !== routeType) {
      throw new Error("Child of EntityLayout must be an EntityLayout.Route");
    }
    const {path, title, children, if: condition, tabProps} = child.props;
    if (condition && entity && !condition(entity)) {
      return [];
    }
    return [{path, title, children, tabProps}];
  });
}
const EntityLayoutTitle = ({
  entity,
  title
}) => /* @__PURE__ */ React.createElement(Box, {
  display: "inline-flex",
  alignItems: "center",
  height: "1em"
}, title, entity && /* @__PURE__ */ React.createElement(FavouriteEntity, {
  entity
}));
const headerProps = (paramKind, paramNamespace, paramName, entity) => {
  var _a, _b, _c;
  const kind = (_a = paramKind != null ? paramKind : entity == null ? void 0 : entity.kind) != null ? _a : "";
  const namespace = (_b = paramNamespace != null ? paramNamespace : entity == null ? void 0 : entity.metadata.namespace) != null ? _b : "";
  const name = (_c = paramName != null ? paramName : entity == null ? void 0 : entity.metadata.name) != null ? _c : "";
  return {
    headerTitle: `${name}${namespace && namespace !== ENTITY_DEFAULT_NAMESPACE ? ` in ${namespace}` : ""}`,
    headerType: (() => {
      let t = kind.toLocaleLowerCase("en-US");
      if (entity && entity.spec && "type" in entity.spec) {
        t += " \u2014 ";
        t += entity.spec.type.toLocaleLowerCase("en-US");
      }
      return t;
    })()
  };
};
const EntityLabels = ({entity}) => {
  var _a;
  const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, ownedByRelations.length > 0 && /* @__PURE__ */ React.createElement(HeaderLabel, {
    label: "Owner",
    value: /* @__PURE__ */ React.createElement(EntityRefLinks, {
      entityRefs: ownedByRelations,
      defaultKind: "Group",
      color: "inherit"
    })
  }), ((_a = entity.spec) == null ? void 0 : _a.lifecycle) && /* @__PURE__ */ React.createElement(HeaderLabel, {
    label: "Lifecycle",
    value: entity.spec.lifecycle
  }));
};
const EntityLayout = ({
  UNSTABLE_extraContextMenuItems,
  children
}) => {
  var _a, _b, _c;
  const {kind, namespace, name} = useEntityCompoundName();
  const {entity, loading, error} = useContext(EntityContext);
  const routes = createSubRoutesFromChildren(children, entity);
  const {headerTitle, headerType} = headerProps(kind, namespace, name, entity);
  const [confirmationDialogOpen, setConfirmationDialogOpen] = useState(false);
  const navigate = useNavigate();
  const cleanUpAfterRemoval = async () => {
    setConfirmationDialogOpen(false);
    navigate("/");
  };
  const showRemovalDialog = () => setConfirmationDialogOpen(true);
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: (_c = (_b = (_a = entity == null ? void 0 : entity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString()) != null ? _c : "home"
  }, /* @__PURE__ */ React.createElement(Header, {
    title: /* @__PURE__ */ React.createElement(EntityLayoutTitle, {
      title: headerTitle,
      entity
    }),
    pageTitleOverride: headerTitle,
    type: headerType
  }, entity && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(EntityLabels, {
    entity
  }), /* @__PURE__ */ React.createElement(EntityContextMenu, {
    UNSTABLE_extraContextMenuItems,
    onUnregisterEntity: showRemovalDialog
  }))), loading && /* @__PURE__ */ React.createElement(Progress, null), entity && /* @__PURE__ */ React.createElement(RoutedTabs, {
    routes
  }), error && /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(Alert$1, {
    severity: "error"
  }, error.toString())), /* @__PURE__ */ React.createElement(UnregisterEntityDialog, {
    open: confirmationDialogOpen,
    entity,
    onConfirm: cleanUpAfterRemoval,
    onClose: () => setConfirmationDialogOpen(false)
  }));
};
EntityLayout.Route = Route;

const getSelectedIndexOrDefault = (matchedRoute, tabs, defaultIndex = 0) => {
  if (!matchedRoute)
    return defaultIndex;
  const tabIndex = tabs.findIndex((t) => t.id === matchedRoute.route.path);
  return ~tabIndex ? tabIndex : defaultIndex;
};
const Tabbed = {
  Layout: ({children}) => {
    var _a, _b, _c;
    const routes = [];
    const tabs = [];
    const params = useParams();
    const navigate = useNavigate();
    React.Children.forEach(children, (child) => {
      if (!React.isValidElement(child)) {
        return;
      }
      if (child.type !== Tabbed.Content) {
        throw new Error("This component only accepts Content elements as direct children. Check the code of the EntityPage.");
      }
      const pathAndId = child.props.path;
      tabs.push({
        id: pathAndId,
        label: child.props.title
      });
      routes.push({
        path: pathAndId,
        element: child.props.element
      });
    });
    if (((_b = (_a = routes == null ? void 0 : routes[0]) == null ? void 0 : _a.path) != null ? _b : "") !== "")
      routes.push({
        path: "/*",
        element: /* @__PURE__ */ React.createElement(Navigate, {
          to: routes[0].path
        })
      });
    const [matchedRoute] = (_c = matchRoutes(routes, `/${params["*"]}`)) != null ? _c : [];
    const selectedIndex = getSelectedIndexOrDefault(matchedRoute, tabs);
    const currentTab = tabs[selectedIndex];
    const title = currentTab == null ? void 0 : currentTab.label;
    const onTabChange = (index) => navigate(tabs[index].id.replace(/\/\*$/, "").replace(/^\//, ""));
    const currentRouteElement = useRoutes(routes);
    if (!currentTab)
      return null;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(HeaderTabs, {
      tabs,
      selectedIndex,
      onChange: onTabChange
    }), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(Helmet, {
      title
    }), currentRouteElement));
  },
  Content: (_props) => null
};

const EntityPageTitle = ({
  entity,
  title
}) => /* @__PURE__ */ React.createElement(Box, {
  display: "inline-flex",
  alignItems: "center",
  height: "1em"
}, title, entity && /* @__PURE__ */ React.createElement(FavouriteEntity, {
  entity
}));
const EntityLabels$1 = ({entity}) => {
  var _a;
  const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, ownedByRelations.length > 0 && /* @__PURE__ */ React.createElement(HeaderLabel, {
    label: "Owner",
    value: /* @__PURE__ */ React.createElement(EntityRefLinks, {
      entityRefs: ownedByRelations,
      defaultKind: "Group",
      color: "inherit"
    })
  }), ((_a = entity.spec) == null ? void 0 : _a.lifecycle) && /* @__PURE__ */ React.createElement(HeaderLabel, {
    label: "Lifecycle",
    value: entity.spec.lifecycle
  }));
};
const headerProps$1 = (kind, namespace, name, entity) => {
  return {
    headerTitle: `${name}${namespace && namespace !== ENTITY_DEFAULT_NAMESPACE ? ` in ${namespace}` : ""}`,
    headerType: (() => {
      let t = kind.toLocaleLowerCase("en-US");
      if (entity && entity.spec && "type" in entity.spec) {
        t += " \u2014 ";
        t += entity.spec.type.toLocaleLowerCase("en-US");
      }
      return t;
    })()
  };
};
const EntityPageLayout = ({
  children,
  UNSTABLE_extraContextMenuItems
}) => {
  var _a, _b, _c;
  const {kind, namespace, name} = useEntityCompoundName();
  const {entity, loading, error} = useContext(EntityContext);
  const {headerTitle, headerType} = headerProps$1(kind, namespace, name, entity);
  const [confirmationDialogOpen, setConfirmationDialogOpen] = useState(false);
  const navigate = useNavigate();
  const cleanUpAfterRemoval = async () => {
    setConfirmationDialogOpen(false);
    navigate("/");
  };
  const showRemovalDialog = () => setConfirmationDialogOpen(true);
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: (_c = (_b = (_a = entity == null ? void 0 : entity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString()) != null ? _c : "home"
  }, /* @__PURE__ */ React.createElement(Header, {
    title: /* @__PURE__ */ React.createElement(EntityPageTitle, {
      title: headerTitle,
      entity
    }),
    pageTitleOverride: headerTitle,
    type: headerType
  }, entity && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(EntityLabels$1, {
    entity
  }), /* @__PURE__ */ React.createElement(EntityContextMenu, {
    UNSTABLE_extraContextMenuItems,
    onUnregisterEntity: showRemovalDialog
  }))), loading && /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(Progress, null)), entity && /* @__PURE__ */ React.createElement(Tabbed.Layout, null, children), error && /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ResponseErrorPanel, {
    error
  })), !loading && !error && !entity && /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(WarningPanel, {
    title: "Entity not found"
  }, "There is no ", kind, " with the requested", " ", /* @__PURE__ */ React.createElement(Link, {
    to: "https://backstage.io/docs/features/software-catalog/references"
  }, "kind, namespace, and name"), ".")), /* @__PURE__ */ React.createElement(UnregisterEntityDialog, {
    open: confirmationDialogOpen,
    entity,
    onConfirm: cleanUpAfterRemoval,
    onClose: () => setConfirmationDialogOpen(false)
  }));
};
EntityPageLayout.Content = Tabbed.Content;

function createNameColumn() {
  return {
    title: "Name",
    field: "resolved.name",
    highlight: true,
    render: ({entity}) => /* @__PURE__ */ React.createElement(EntityRefLink, {
      entityRef: entity,
      defaultKind: "Component"
    })
  };
}
function createSystemColumn() {
  return {
    title: "System",
    field: "resolved.partOfSystemRelationTitle",
    render: ({resolved}) => /* @__PURE__ */ React.createElement(EntityRefLinks, {
      entityRefs: resolved.partOfSystemRelations,
      defaultKind: "system"
    })
  };
}
function createOwnerColumn() {
  return {
    title: "Owner",
    field: "resolved.ownedByRelationsTitle",
    render: ({resolved}) => /* @__PURE__ */ React.createElement(EntityRefLinks, {
      entityRefs: resolved.ownedByRelations,
      defaultKind: "group"
    })
  };
}
function createSpecTypeColumn() {
  return {
    title: "Type",
    field: "entity.spec.type",
    hidden: true
  };
}
function createSpecLifecycleColumn() {
  return {
    title: "Lifecycle",
    field: "entity.spec.lifecycle"
  };
}
function createMetadataDescriptionColumn() {
  return {
    title: "Description",
    field: "entity.metadata.description",
    render: ({entity}) => /* @__PURE__ */ React.createElement(OverflowTooltip, {
      text: entity.metadata.description,
      placement: "bottom-start"
    }),
    width: "auto"
  };
}
function createTagsColumn() {
  return {
    title: "Tags",
    field: "entity.metadata.tags",
    cellStyle: {
      padding: "0px 16px 0px 20px"
    },
    render: ({entity}) => /* @__PURE__ */ React.createElement(React.Fragment, null, entity.metadata.tags && entity.metadata.tags.map((t) => /* @__PURE__ */ React.createElement(Chip, {
      key: t,
      label: t,
      size: "small",
      variant: "outlined",
      style: {marginBottom: "0px"}
    })))
  };
}

var columnFactories = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createNameColumn: createNameColumn,
  createSystemColumn: createSystemColumn,
  createOwnerColumn: createOwnerColumn,
  createSpecTypeColumn: createSpecTypeColumn,
  createSpecLifecycleColumn: createSpecLifecycleColumn,
  createMetadataDescriptionColumn: createMetadataDescriptionColumn,
  createTagsColumn: createTagsColumn
});

const defaultColumns = [
  createNameColumn(),
  createSystemColumn(),
  createOwnerColumn(),
  createSpecTypeColumn(),
  createSpecLifecycleColumn(),
  createMetadataDescriptionColumn(),
  createTagsColumn()
];
const CatalogTable = ({
  entities,
  loading,
  error,
  titlePreamble,
  view,
  columns
}) => {
  const {isStarredEntity, toggleStarredEntity} = useStarredEntities();
  if (error) {
    return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(WarningPanel, {
      severity: "error",
      title: "Could not fetch catalog entities."
    }, /* @__PURE__ */ React.createElement(CodeSnippet, {
      language: "text",
      text: error.toString()
    })));
  }
  const actions = [
    ({entity}) => {
      const url = getEntityMetadataViewUrl(entity);
      return {
        icon: () => /* @__PURE__ */ React.createElement(OpenInNew, {
          fontSize: "small"
        }),
        tooltip: "View",
        disabled: !url,
        onClick: () => {
          if (!url)
            return;
          window.open(url, "_blank");
        }
      };
    },
    ({entity}) => {
      const url = getEntityMetadataEditUrl(entity);
      return {
        icon: () => /* @__PURE__ */ React.createElement(EditIcon, {
          fontSize: "small"
        }),
        tooltip: "Edit",
        disabled: !url,
        onClick: () => {
          if (!url)
            return;
          window.open(url, "_blank");
        }
      };
    },
    ({entity}) => {
      const isStarred = isStarredEntity(entity);
      return {
        cellStyle: {paddingLeft: "1em"},
        icon: () => favouriteEntityIcon(isStarred),
        tooltip: favouriteEntityTooltip(isStarred),
        onClick: () => toggleStarredEntity(entity)
      };
    }
  ];
  const rows = entities.map((entity) => {
    const partOfSystemRelations = getEntityRelations(entity, RELATION_PART_OF, {
      kind: "system"
    });
    const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
    return {
      entity,
      resolved: {
        name: formatEntityRefTitle(entity, {
          defaultKind: "Component"
        }),
        ownedByRelationsTitle: ownedByRelations.map((r) => formatEntityRefTitle(r, {defaultKind: "group"})).join(", "),
        ownedByRelations,
        partOfSystemRelationTitle: partOfSystemRelations.map((r) => formatEntityRefTitle(r, {
          defaultKind: "system"
        })).join(", "),
        partOfSystemRelations
      }
    };
  });
  const typeColumn = (columns || defaultColumns).find((c) => c.title === "Type");
  if (typeColumn) {
    typeColumn.hidden = view !== "Other";
  }
  return /* @__PURE__ */ React.createElement(Table, {
    isLoading: loading,
    columns: columns || defaultColumns,
    options: {
      paging: true,
      pageSize: 20,
      actionsColumnIndex: -1,
      loadingType: "linear",
      showEmptyDataSourceMessage: !loading,
      padding: "dense",
      pageSizeOptions: [20, 50, 100]
    },
    title: `${titlePreamble} (${entities && entities.length || 0})`,
    data: rows,
    actions
  });
};
CatalogTable.columns = columnFactories;

const EntitySwitchCase = (_) => null;
function createSwitchCasesFromChildren(childrenNode) {
  return Children.toArray(childrenNode).flatMap((child) => {
    if (!isValidElement(child)) {
      return [];
    }
    if (child.type === Fragment) {
      return createSwitchCasesFromChildren(child.props.children);
    }
    if (child.type !== EntitySwitchCase) {
      throw new Error(`Child of EntitySwitch is not an EntitySwitch.Case`);
    }
    const {if: condition, children} = child.props;
    return [{if: condition, children}];
  });
}
const EntitySwitch = ({children}) => {
  var _a;
  const {entity} = useEntity();
  const switchCases = useMemo(() => createSwitchCasesFromChildren(children), [
    children
  ]);
  const matchingCase = switchCases.find((switchCase) => switchCase.if ? switchCase.if(entity) : true);
  return (_a = matchingCase == null ? void 0 : matchingCase.children) != null ? _a : null;
};
EntitySwitch.Case = EntitySwitchCase;

function strCmp(a, b) {
  return Boolean(a && (a == null ? void 0 : a.toLowerCase()) === (b == null ? void 0 : b.toLowerCase()));
}
function isKind(kind) {
  return (entity) => strCmp(entity == null ? void 0 : entity.kind, kind);
}
function isComponentType(type) {
  return (entity) => {
    if (!strCmp(entity == null ? void 0 : entity.kind, "component")) {
      return false;
    }
    const componentEntity = entity;
    return strCmp(componentEntity.spec.type, type);
  };
}
function isNamespace(namespace) {
  return (entity) => {
    var _a;
    return strCmp((_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.namespace, namespace);
  };
}

const filterGroupsContext = createContext(void 0);

const EntityFilterGroupsProvider = ({
  children
}) => {
  const state = useProvideEntityFilters();
  return /* @__PURE__ */ React.createElement(filterGroupsContext.Provider, {
    value: state
  }, children);
};
function useProvideEntityFilters() {
  const catalogApi = useApi(catalogApiRef);
  const [{value: entities, error}, doReload] = useAsyncFn(async () => {
    const response = await catalogApi.getEntities({
      filter: {kind: "Component"}
    });
    return response.items;
  });
  const filterGroups = useRef({});
  const selectedFilterKeys = useRef({});
  const selectedTags = useRef([]);
  const [filterGroupStates, setFilterGroupStates] = useState({});
  const [matchingEntities, setMatchingEntities] = useState([]);
  const [availableTags, setAvailableTags] = useState([]);
  const [isCatalogEmpty, setCatalogEmpty] = useState(false);
  useEffect(() => {
    doReload();
  }, [doReload]);
  const rebuild = useCallback(() => {
    setFilterGroupStates(buildStates(filterGroups.current, selectedFilterKeys.current, selectedTags.current, entities, error));
    setMatchingEntities(buildMatchingEntities(filterGroups.current, selectedFilterKeys.current, selectedTags.current, entities));
    setAvailableTags(collectTags(entities));
    setCatalogEmpty(entities !== void 0 && entities.length === 0);
  }, [entities, error]);
  const register = useCallback((filterGroupId, filterGroup, initialSelectedFilterIds) => {
    filterGroups.current[filterGroupId] = filterGroup;
    selectedFilterKeys.current[filterGroupId] = new Set(initialSelectedFilterIds != null ? initialSelectedFilterIds : []);
    rebuild();
  }, [rebuild]);
  const unregister = useCallback((filterGroupId) => {
    delete filterGroups.current[filterGroupId];
    delete selectedFilterKeys.current[filterGroupId];
    rebuild();
  }, [rebuild]);
  const setGroupSelectedFilters = useCallback((filterGroupId, filters) => {
    selectedFilterKeys.current[filterGroupId] = new Set(filters);
    rebuild();
  }, [rebuild]);
  const setSelectedTags = useCallback((tags) => {
    selectedTags.current = tags;
    rebuild();
  }, [rebuild]);
  const reload = useCallback(async () => {
    await doReload();
  }, [doReload]);
  return {
    register,
    unregister,
    setGroupSelectedFilters,
    setSelectedTags,
    reload,
    loading: !error && !entities,
    error,
    filterGroupStates,
    matchingEntities,
    availableTags,
    isCatalogEmpty
  };
}
function buildStates(filterGroups, selectedFilterKeys, selectedTags, entities, error) {
  var _a;
  if (error) {
    return Object.fromEntries(Object.keys(filterGroups).map((filterGroupId) => [
      filterGroupId,
      {type: "error", error}
    ]));
  }
  if (!entities) {
    return Object.fromEntries(Object.keys(filterGroups).map((filterGroupId) => [
      filterGroupId,
      {type: "loading"}
    ]));
  }
  const result = {};
  for (const [filterGroupId, filterGroup] of Object.entries(filterGroups)) {
    const otherMatchingEntities = buildMatchingEntities(filterGroups, selectedFilterKeys, selectedTags, entities, filterGroupId);
    const groupState = {filters: {}};
    for (const [filterId, filterFn] of Object.entries(filterGroup.filters)) {
      const isSelected = !!((_a = selectedFilterKeys[filterGroupId]) == null ? void 0 : _a.has(filterId));
      const matchCount = otherMatchingEntities.filter((entity) => filterFn(entity)).length;
      groupState.filters[filterId] = {isSelected, matchCount};
    }
    result[filterGroupId] = {type: "ready", state: groupState};
  }
  return result;
}
function collectTags(entities) {
  const tags = new Set();
  (entities || []).forEach((e) => {
    if (e.metadata.tags) {
      e.metadata.tags.forEach((t) => tags.add(t));
    }
  });
  return Array.from(tags).sort();
}
function buildMatchingEntities(filterGroups, selectedFilterKeys, selectedTags, entities, excludeFilterGroupId) {
  var _a, _b;
  const allFilters = [];
  for (const [filterGroupId, filterGroup] of Object.entries(filterGroups)) {
    if (excludeFilterGroupId === filterGroupId) {
      continue;
    }
    const groupFilters = [];
    for (const [filterId, filterFn] of Object.entries(filterGroup.filters)) {
      if (!!((_a = selectedFilterKeys[filterGroupId]) == null ? void 0 : _a.has(filterId))) {
        groupFilters.push(filterFn);
      }
    }
    if (groupFilters.length) {
      allFilters.push((entity) => groupFilters.some((fn) => fn(entity)));
    }
  }
  if (selectedTags.length > 0) {
    allFilters.push((entity) => !!entity.metadata.tags && entity.metadata.tags.some((t) => selectedTags.includes(t)));
  }
  return (_b = entities == null ? void 0 : entities.filter((entity) => allFilters.every((fn) => fn(entity)))) != null ? _b : [];
}

const useEntityFilterGroup = (filterGroupId, filterGroup, initialSelectedFilters) => {
  const context = useContext(filterGroupsContext);
  if (!context) {
    throw new Error(`Must be used inside an EntityFilterGroupsProvider`);
  }
  const {
    register,
    unregister,
    setGroupSelectedFilters,
    filterGroupStates
  } = context;
  const initialMemo = useMemo(() => {
    return initialSelectedFilters == null ? void 0 : initialSelectedFilters.slice();
  }, [initialSelectedFilters]);
  useEffect(() => {
    register(filterGroupId, filterGroup, initialMemo);
    return () => unregister(filterGroupId);
  }, [register, unregister, filterGroupId, filterGroup]);
  const setSelectedFilters = useCallback((filters) => {
    setGroupSelectedFilters(filterGroupId, filters);
  }, [setGroupSelectedFilters, filterGroupId]);
  let state = filterGroupStates[filterGroupId];
  if (!state) {
    state = {type: "loading"};
  }
  return {state, setSelectedFilters};
};

function useFilteredEntities() {
  const context = useContext(filterGroupsContext);
  if (!context) {
    throw new Error(`Must be used inside an EntityFilterGroupsProvider`);
  }
  return {
    loading: context.loading,
    error: context.error,
    matchingEntities: context.matchingEntities,
    availableTags: context.availableTags,
    isCatalogEmpty: context.isCatalogEmpty,
    reload: context.reload
  };
}

const createComponentRouteRef = createExternalRouteRef({
  id: "create-component",
  optional: true
});

const useStyles$5 = makeStyles((theme) => ({
  root: {
    backgroundColor: "rgba(0, 0, 0, .11)",
    boxShadow: "none"
  },
  title: {
    margin: theme.spacing(1, 0, 0, 1),
    textTransform: "uppercase",
    fontSize: 12,
    fontWeight: "bold"
  },
  listIcon: {
    minWidth: 30,
    color: theme.palette.text.primary
  },
  menuItem: {
    minHeight: theme.spacing(6)
  },
  groupWrapper: {
    margin: theme.spacing(1, 1, 2, 1)
  },
  menuTitle: {
    fontWeight: 500
  }
}));
const CatalogFilter = ({
  buttonGroups,
  onChange,
  initiallySelected
}) => {
  const classes = useStyles$5();
  const {currentFilter, setCurrentFilter, getFilterCount} = useFilter(buttonGroups, initiallySelected);
  const onChangeRef = useRef();
  useEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  const setCurrent = useCallback((item) => {
    var _a;
    setCurrentFilter(item.id);
    (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, {id: item.id, label: item.label});
  }, [setCurrentFilter]);
  useEffect(() => {
    var _a;
    const items = buttonGroups.flatMap((g) => g.items);
    const item = items.find((i) => i.id === initiallySelected) || items[0];
    if (item) {
      (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, {id: item.id, label: item.label});
    }
  }, []);
  return /* @__PURE__ */ React.createElement(Card, {
    className: classes.root
  }, buttonGroups.map((group) => /* @__PURE__ */ React.createElement(React.Fragment, {
    key: group.name
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    className: classes.title
  }, group.name), /* @__PURE__ */ React.createElement(Card, {
    className: classes.groupWrapper
  }, /* @__PURE__ */ React.createElement(List, {
    disablePadding: true,
    dense: true
  }, group.items.map((item) => {
    var _a;
    return /* @__PURE__ */ React.createElement(MenuItem, {
      key: item.id,
      button: true,
      divider: true,
      onClick: () => setCurrent(item),
      selected: item.id === currentFilter,
      className: classes.menuItem
    }, item.icon && /* @__PURE__ */ React.createElement(ListItemIcon, {
      className: classes.listIcon
    }, /* @__PURE__ */ React.createElement(item.icon, {
      fontSize: "small"
    })), /* @__PURE__ */ React.createElement(ListItemText, null, /* @__PURE__ */ React.createElement(Typography, {
      variant: "body1",
      className: classes.menuTitle
    }, item.label)), /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, (_a = getFilterCount(item.id)) != null ? _a : "-"));
  }))))));
};
function useFilter(buttonGroups, initiallySelected) {
  const [currentFilter, setCurrentFilter] = useState(initiallySelected);
  const filterGroup = useMemo(() => ({
    filters: Object.fromEntries(buttonGroups.flatMap((g) => g.items).map((i) => [i.id, i.filterFn]))
  }), [buttonGroups]);
  const {setSelectedFilters, state} = useEntityFilterGroup("primary-sidebar", filterGroup, [initiallySelected]);
  const setCurrent = useCallback((filterId) => {
    setCurrentFilter(filterId);
    setSelectedFilters([filterId]);
  }, [setCurrentFilter, setSelectedFilters]);
  const getFilterCount = useCallback((filterId) => {
    if (state.type !== "ready") {
      return void 0;
    }
    return state.state.filters[filterId].matchCount;
  }, [state]);
  return {
    currentFilter,
    setCurrentFilter: setCurrent,
    getFilterCount
  };
}

const useStyles$6 = makeStyles((theme) => ({
  filterBox: {
    display: "flex",
    margin: theme.spacing(2, 0, 0, 0)
  },
  filterBoxTitle: {
    margin: theme.spacing(1, 0, 0, 1),
    fontWeight: "bold",
    flex: 1
  },
  title: {
    margin: theme.spacing(1, 0, 0, 1),
    textTransform: "uppercase",
    fontSize: 12,
    fontWeight: "bold"
  },
  checkbox: {
    padding: theme.spacing(0, 1, 0, 1)
  }
}));
const ResultsFilter = ({availableTags}) => {
  const classes = useStyles$6();
  const [selectedTags, setSelectedTags] = useState([]);
  const context = useContext(filterGroupsContext);
  if (!context) {
    throw new Error(`Must be used inside an EntityFilterGroupsProvider`);
  }
  const setSelectedTagsFilter = context == null ? void 0 : context.setSelectedTags;
  const updateSelectedTags = useCallback((tags) => {
    setSelectedTags(tags);
    setSelectedTagsFilter(tags);
  }, [setSelectedTags, setSelectedTagsFilter]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: classes.filterBox
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    className: classes.filterBoxTitle
  }, "Refine Results"), " ", /* @__PURE__ */ React.createElement(Button, {
    onClick: () => updateSelectedTags([])
  }, "Clear")), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    className: classes.title
  }, "Tags"), /* @__PURE__ */ React.createElement(List, {
    disablePadding: true,
    dense: true
  }, availableTags.map((t) => {
    const labelId = `checkbox-list-label-${t}`;
    return /* @__PURE__ */ React.createElement(ListItem, {
      key: t,
      dense: true,
      button: true,
      onClick: () => updateSelectedTags(selectedTags.includes(t) ? selectedTags.filter((s) => s !== t) : [...selectedTags, t])
    }, /* @__PURE__ */ React.createElement(Checkbox, {
      edge: "start",
      color: "primary",
      checked: selectedTags.includes(t),
      tabIndex: -1,
      disableRipple: true,
      className: classes.checkbox,
      inputProps: {"aria-labelledby": labelId}
    }), /* @__PURE__ */ React.createElement(ListItemText, {
      id: labelId,
      primary: t
    }));
  })));
};

function useOwnUser() {
  const catalogApi = useApi(catalogApiRef);
  const identityApi = useApi(identityApiRef);
  return useAsync(() => catalogApi.getEntityByName({
    kind: "User",
    namespace: "default",
    name: identityApi.getUserId()
  }), [catalogApi, identityApi]);
}

const CatalogLayout = ({children}) => {
  var _a;
  const orgName = (_a = useApi(configApiRef).getOptionalString("organization.name")) != null ? _a : "Backstage";
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "home"
  }, /* @__PURE__ */ React.createElement(Header, {
    title: `${orgName} Catalog`,
    subtitle: `Catalog of software components at ${orgName}`,
    pageTitleOverride: "Home"
  }), children);
};

const CatalogTabs = ({tabs, onChange}) => {
  const filterGroup = useMemo(() => {
    const otherType = "other";
    const wellKnownTypes = tabs.map((t) => t.id).filter((t) => t !== otherType);
    const isOtherType = (entity) => {
      var _a;
      return !wellKnownTypes.includes((_a = entity.spec) == null ? void 0 : _a.type);
    };
    return {
      filters: Object.fromEntries(tabs.map((t) => [
        t.id,
        (entity) => {
          var _a;
          return t.id === otherType && isOtherType(entity) || ((_a = entity.spec) == null ? void 0 : _a.type) === t.id;
        }
      ]))
    };
  }, [tabs]);
  const {setSelectedFilters} = useEntityFilterGroup("type", filterGroup, [
    tabs[0].id
  ]);
  const [currentTabIndex, setCurrentTabIndex] = useState(0);
  const onChangeRef = useRef();
  useEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  useEffect(() => {
    var _a;
    (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, tabs[currentTabIndex]);
  }, [tabs, currentTabIndex]);
  const switchTab = useCallback((index) => {
    var _a;
    const tab = tabs[index];
    setSelectedFilters([tab.id]);
    setCurrentTabIndex(index);
    (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, tab);
  }, [tabs, setSelectedFilters]);
  return /* @__PURE__ */ React.createElement(HeaderTabs, {
    tabs,
    onChange: switchTab
  });
};

const useStyles$7 = makeStyles((theme) => ({
  contentWrapper: {
    display: "grid",
    gridTemplateAreas: "'filters' 'table'",
    gridTemplateColumns: "250px 1fr",
    gridColumnGap: theme.spacing(2)
  },
  buttonSpacing: {
    marginLeft: theme.spacing(2)
  }
}));
const CatalogPageContents = (props) => {
  var _a, _b, _c, _d;
  const styles = useStyles$7();
  const {
    loading,
    error,
    reload,
    matchingEntities,
    availableTags,
    isCatalogEmpty
  } = useFilteredEntities();
  const configApi = useApi(configApiRef);
  const catalogApi = useApi(catalogApiRef);
  const errorApi = useApi(errorApiRef);
  const {isStarredEntity} = useStarredEntities();
  const [selectedTab, setSelectedTab] = useState();
  const [
    selectedSidebarItem,
    setSelectedSidebarItem
  ] = useState();
  const orgName = (_a = configApi.getOptionalString("organization.name")) != null ? _a : "Company";
  const initiallySelectedFilter = (_c = (_b = selectedSidebarItem == null ? void 0 : selectedSidebarItem.id) != null ? _b : props.initiallySelectedFilter) != null ? _c : "owned";
  const createComponentLink = useRouteRef(createComponentRouteRef);
  const addMockData = useCallback(async () => {
    try {
      const promises = [];
      const root = configApi.getConfig("catalog.exampleEntityLocations");
      for (const type of root.keys()) {
        for (const target of root.getStringArray(type)) {
          promises.push(catalogApi.addLocation({target}));
        }
      }
      await Promise.all(promises);
      await reload();
    } catch (err) {
      errorApi.post(err);
    }
  }, [catalogApi, configApi, errorApi, reload]);
  const tabs = useMemo(() => [
    {
      id: "service",
      label: "Services"
    },
    {
      id: "website",
      label: "Websites"
    },
    {
      id: "library",
      label: "Libraries"
    },
    {
      id: "documentation",
      label: "Documentation"
    },
    {
      id: "other",
      label: "Other"
    }
  ], []);
  const {value: user} = useOwnUser();
  const filterGroups = useMemo(() => [
    {
      name: "Personal",
      items: [
        {
          id: "owned",
          label: "Owned",
          icon: SettingsIcon,
          filterFn: (entity) => user !== void 0 && isOwnerOf(user, entity)
        },
        {
          id: "starred",
          label: "Starred",
          icon: Star,
          filterFn: isStarredEntity
        }
      ]
    },
    {
      name: orgName,
      items: [
        {
          id: "all",
          label: "All",
          filterFn: () => true
        }
      ]
    }
  ], [isStarredEntity, orgName, user]);
  const showAddExampleEntities = configApi.has("catalog.exampleEntityLocations") && isCatalogEmpty;
  return /* @__PURE__ */ React.createElement(CatalogLayout, null, /* @__PURE__ */ React.createElement(CatalogTabs, {
    tabs,
    onChange: ({label}) => setSelectedTab(label)
  }), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ContentHeader, {
    title: selectedTab != null ? selectedTab : ""
  }, createComponentLink && /* @__PURE__ */ React.createElement(Button, {
    component: Link$1,
    variant: "contained",
    color: "primary",
    to: createComponentLink()
  }, "Create Component"), showAddExampleEntities && /* @__PURE__ */ React.createElement(Button, {
    className: styles.buttonSpacing,
    variant: "outlined",
    color: "primary",
    onClick: addMockData
  }, "Add example components"), /* @__PURE__ */ React.createElement(SupportButton, null, "All your software catalog entities")), /* @__PURE__ */ React.createElement("div", {
    className: styles.contentWrapper
  }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(CatalogFilter, {
    buttonGroups: filterGroups,
    onChange: ({label, id}) => setSelectedSidebarItem({label, id}),
    initiallySelected: initiallySelectedFilter
  }), /* @__PURE__ */ React.createElement(ResultsFilter, {
    availableTags
  })), /* @__PURE__ */ React.createElement(CatalogTable, {
    titlePreamble: (_d = selectedSidebarItem == null ? void 0 : selectedSidebarItem.label) != null ? _d : "",
    view: selectedTab,
    columns: props.columns,
    entities: matchingEntities,
    loading,
    error
  }))));
};
const CatalogPage = (props) => /* @__PURE__ */ React.createElement(EntityFilterGroupsProvider, null, /* @__PURE__ */ React.createElement(CatalogPageContents, {
  ...props
}));

const EntityLoaderProvider = ({children}) => {
  const {entity, loading, error} = useEntityFromUrl();
  return /* @__PURE__ */ React.createElement(EntityContext.Provider, {
    value: {entity, loading, error}
  }, children);
};

const useStyles$8 = makeStyles((theme) => ({
  illo: {
    maxWidth: "60%",
    top: 100,
    right: 20,
    position: "absolute",
    [theme.breakpoints.down("xs")]: {
      maxWidth: "96%",
      position: "relative",
      top: "unset",
      right: "unset",
      margin: `${theme.spacing(10)}px auto ${theme.spacing(4)}px`
    }
  }
}));
const Illo = () => {
  const classes = useStyles$8();
  return /* @__PURE__ */ React.createElement("img", {
    src: IlloSvgUrl,
    className: classes.illo,
    alt: "Illustration on entity not found page"
  });
};

const useStyles$9 = makeStyles$1((theme) => ({
  container: {
    paddingTop: theme.spacing(24),
    paddingLeft: theme.spacing(8),
    [theme.breakpoints.down("xs")]: {
      padding: theme.spacing(2)
    }
  },
  title: {
    paddingBottom: theme.spacing(2),
    [theme.breakpoints.down("xs")]: {
      fontSize: 32
    }
  },
  body: {
    paddingBottom: theme.spacing(6),
    [theme.breakpoints.down("xs")]: {
      paddingBottom: theme.spacing(5)
    }
  }
}));
const EntityNotFound = () => {
  const classes = useStyles$9();
  return /* @__PURE__ */ React.createElement(Grid, {
    container: true,
    spacing: 0,
    className: classes.container
  }, /* @__PURE__ */ React.createElement(Illo, null), /* @__PURE__ */ React.createElement(Grid, {
    item: true,
    xs: 12,
    sm: 6
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h2",
    className: classes.title
  }, "Entity was not found"), /* @__PURE__ */ React.createElement(Typography, {
    variant: "body1",
    className: classes.body
  }, "Want to help us build this? Check out our Getting Started documentation."), /* @__PURE__ */ React.createElement(Button, {
    variant: "contained",
    color: "primary",
    href: "https://backstage.io/docs"
  }, "DOCS")));
};

const DefaultEntityPage = () => /* @__PURE__ */ React.createElement(EntityPageLayout, null, /* @__PURE__ */ React.createElement(EntityPageLayout.Content, {
  path: "/",
  title: "Overview",
  element: /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h2"
  }, "This is the default entity page."), /* @__PURE__ */ React.createElement(Typography, {
    variant: "body1"
  }, "To override this component with your custom implementation, read docs on", " ", /* @__PURE__ */ React.createElement(Link$2, {
    target: "_blank",
    href: "https://backstage.io/docs"
  }, "backstage.io/docs")))
}));
const EntityPageSwitch = ({EntityPage}) => {
  const {entity, loading, error} = useEntity();
  if (loading)
    return /* @__PURE__ */ React.createElement(EntityPageLayout, null);
  if (error || !entity)
    return /* @__PURE__ */ React.createElement(EntityNotFound, null);
  return /* @__PURE__ */ React.createElement(EntityPage, null);
};
const OldEntityRouteRedirect = () => {
  var _a;
  const {optionalNamespaceAndName, "*": rest} = useParams();
  const [name, namespace] = optionalNamespaceAndName.split(":").reverse();
  const namespaceLower = (_a = namespace == null ? void 0 : namespace.toLocaleLowerCase("en-US")) != null ? _a : ENTITY_DEFAULT_NAMESPACE;
  const restWithSlash = rest ? `/${rest}` : "";
  return /* @__PURE__ */ React.createElement(Navigate, {
    to: `../../${namespaceLower}/component/${name}${restWithSlash}`
  });
};
const Router = ({
  EntityPage = DefaultEntityPage
}) => /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route$1, {
  path: `${rootRoute.path}`,
  element: /* @__PURE__ */ React.createElement(CatalogPage, null)
}), /* @__PURE__ */ React.createElement(Route$1, {
  path: `${entityRoute.path}`,
  element: /* @__PURE__ */ React.createElement(EntityLoaderProvider, null, /* @__PURE__ */ React.createElement(EntityPageSwitch, {
    EntityPage
  }))
}), /* @__PURE__ */ React.createElement(Route$1, {
  path: "Component/:optionalNamespaceAndName/*",
  element: /* @__PURE__ */ React.createElement(OldEntityRouteRedirect, null)
}));

class CatalogClientWrapper {
  constructor(options) {
    this.client = options.client;
    this.identityApi = options.identityApi;
  }
  async getLocationById(id, options) {
    var _a;
    return await this.client.getLocationById(id, {
      token: (_a = options == null ? void 0 : options.token) != null ? _a : await this.identityApi.getIdToken()
    });
  }
  async getEntities(request, options) {
    var _a;
    return await this.client.getEntities(request, {
      token: (_a = options == null ? void 0 : options.token) != null ? _a : await this.identityApi.getIdToken()
    });
  }
  async getEntityByName(compoundName, options) {
    var _a;
    return await this.client.getEntityByName(compoundName, {
      token: (_a = options == null ? void 0 : options.token) != null ? _a : await this.identityApi.getIdToken()
    });
  }
  async addLocation(request, options) {
    var _a;
    return await this.client.addLocation(request, {
      token: (_a = options == null ? void 0 : options.token) != null ? _a : await this.identityApi.getIdToken()
    });
  }
  async getOriginLocationByEntity(entity, options) {
    var _a;
    return await this.client.getOriginLocationByEntity(entity, {
      token: (_a = options == null ? void 0 : options.token) != null ? _a : await this.identityApi.getIdToken()
    });
  }
  async getLocationByEntity(entity, options) {
    var _a;
    return await this.client.getLocationByEntity(entity, {
      token: (_a = options == null ? void 0 : options.token) != null ? _a : await this.identityApi.getIdToken()
    });
  }
  async removeLocationById(id, options) {
    var _a;
    return await this.client.removeLocationById(id, {
      token: (_a = options == null ? void 0 : options.token) != null ? _a : await this.identityApi.getIdToken()
    });
  }
  async removeEntityByUid(uid, options) {
    var _a;
    return await this.client.removeEntityByUid(uid, {
      token: (_a = options == null ? void 0 : options.token) != null ? _a : await this.identityApi.getIdToken()
    });
  }
}

const catalogPlugin = createPlugin({
  id: "catalog",
  apis: [
    createApiFactory({
      api: catalogApiRef,
      deps: {discoveryApi: discoveryApiRef, identityApi: identityApiRef},
      factory: ({discoveryApi, identityApi}) => new CatalogClientWrapper({
        client: new CatalogClient({discoveryApi}),
        identityApi
      })
    })
  ],
  routes: {
    catalogIndex: catalogRouteRef,
    catalogEntity: entityRouteRef
  },
  externalRoutes: {
    createComponent: createComponentRouteRef
  }
});
const CatalogIndexPage = catalogPlugin.provide(createRoutableExtension({
  component: () => import('./index-debd3943.esm.js').then((m) => m.CatalogPage),
  mountPoint: catalogRouteRef
}));
const CatalogEntityPage = catalogPlugin.provide(createRoutableExtension({
  component: () => import('./index-291071ad.esm.js').then((m) => m.CatalogEntityPage),
  mountPoint: entityRouteRef
}));
const EntityAboutCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-e0b4ece2.esm.js').then((m) => m.AboutCard)
  }
}));
const EntityLinksCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-e628ccf2.esm.js').then((m) => m.EntityLinksCard)
  }
}));
const EntityHasSystemsCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-4ef77e53.esm.js').then((m) => m.HasSystemsCard)
  }
}));
const EntityHasComponentsCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-b3e21eee.esm.js').then((m) => m.HasComponentsCard)
  }
}));
const EntityHasSubcomponentsCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-3ace567b.esm.js').then((m) => m.HasSubcomponentsCard)
  }
}));
const EntityHasResourcesCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-593342f8.esm.js').then((m) => m.HasResourcesCard)
  }
}));
const EntityDependsOnComponentsCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-36b66f8e.esm.js').then((m) => m.DependsOnComponentsCard)
  }
}));
const EntityDependsOnResourcesCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-d231361f.esm.js').then((m) => m.DependsOnResourcesCard)
  }
}));
const EntitySystemDiagramCard = catalogPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-d159831b.esm.js').then((m) => m.SystemDiagramCard)
  }
}));

const DeleteEntityDialog = ({
  open,
  onClose,
  onConfirm,
  entity
}) => {
  const [busy, setBusy] = useState(false);
  const catalogApi = useApi(catalogApiRef);
  const alertApi = useApi(alertApiRef);
  const onDelete = async () => {
    setBusy(true);
    try {
      const uid = entity.metadata.uid;
      await catalogApi.removeEntityByUid(uid);
      onConfirm();
    } catch (err) {
      alertApi.post({message: err.message});
    } finally {
      setBusy(false);
    }
  };
  return /* @__PURE__ */ React.createElement(Dialog, {
    open,
    onClose
  }, /* @__PURE__ */ React.createElement(DialogTitle, {
    id: "responsive-dialog-title"
  }, "Are you sure you want to delete this entity?"), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, {
    variant: "contained",
    color: "secondary",
    disabled: busy,
    onClick: onDelete
  }, "Delete"), /* @__PURE__ */ React.createElement(Button, {
    onClick: onClose,
    color: "primary"
  }, "Cancel")));
};

const isOrphan = (entity) => {
  var _a, _b;
  return ((_b = (_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.annotations) == null ? void 0 : _b["backstage.io/orphan"]) === "true";
};
const EntityOrphanWarning = () => {
  const navigate = useNavigate();
  const catalogLink = useRouteRef(catalogRouteRef);
  const [confirmationDialogOpen, setConfirmationDialogOpen] = useState(false);
  const {entity} = useEntity();
  const cleanUpAfterRemoval = async () => {
    setConfirmationDialogOpen(false);
    navigate(catalogLink());
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert$1, {
    severity: "warning",
    onClick: () => setConfirmationDialogOpen(true)
  }, "This entity is not referenced by any location and is therefore not receiving updates. Click here to delete."), /* @__PURE__ */ React.createElement(DeleteEntityDialog, {
    open: confirmationDialogOpen,
    entity,
    onConfirm: cleanUpAfterRemoval,
    onClose: () => setConfirmationDialogOpen(false)
  }));
};

export { AboutCard as A, CatalogPage as C, EntityLoaderProvider as E, Router as R, EntityLayout as a, EntityPageLayout as b, CatalogTable as c, CatalogEntityPage as d, CatalogIndexPage as e, catalogPlugin as f, EntityAboutCard as g, EntityDependsOnComponentsCard as h, EntityDependsOnResourcesCard as i, EntityHasComponentsCard as j, EntityHasResourcesCard as k, EntityHasSubcomponentsCard as l, EntityHasSystemsCard as m, EntityLinksCard as n, EntitySystemDiagramCard as o, EntitySwitch as p, isKind as q, isNamespace as r, isComponentType as s, EntityOrphanWarning as t, isOrphan as u };
//# sourceMappingURL=index-85897b39.esm.js.map
