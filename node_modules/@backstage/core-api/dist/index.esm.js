import React, { useContext, useMemo, createContext, Children, isValidElement, Fragment, lazy, Suspense, useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import GithubIcon from '@material-ui/icons/AcUnit';
import ObservableImpl from 'zen-observable';
import { ConfigReader } from '@backstage/config';
export { ConfigReader } from '@backstage/config';
import { useRoutes, matchRoutes, generatePath, useLocation, useParams, Navigate, Route, Routes } from 'react-router-dom';
import MuiMenuBookIcon from '@material-ui/icons/MenuBook';
import MuiBrokenImageIcon from '@material-ui/icons/BrokenImage';
import MuiChatIcon from '@material-ui/icons/Chat';
import MuiDashboardIcon from '@material-ui/icons/Dashboard';
import MuiEmailIcon from '@material-ui/icons/Email';
import MuiGitHubIcon from '@material-ui/icons/GitHub';
import MuiHelpIcon from '@material-ui/icons/Help';
import MuiPeopleIcon from '@material-ui/icons/People';
import MuiPersonIcon from '@material-ui/icons/Person';
import MuiWarningIcon from '@material-ui/icons/Warning';
import MuiDocsIcon from '@material-ui/icons/Description';
import { useObservable, useAsync } from 'react-use';
import { ThemeProvider, CssBaseline } from '@material-ui/core';

class ApiAggregator {
  constructor(...holders) {
    this.holders = holders;
  }
  get(apiRef) {
    for (const holder of this.holders) {
      const api = holder.get(apiRef);
      if (api) {
        return api;
      }
    }
    return void 0;
  }
}

function getGlobalObject() {
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  return Function("return this")();
}
const globalObject = getGlobalObject();
const makeKey = (id) => `__@backstage/${id}__`;
function getGlobalSingleton(id) {
  const key = makeKey(id);
  if (!(key in globalObject)) {
    throw new Error(`Global ${id} is not set`);
  }
  return globalObject[key];
}
function getOrCreateGlobalSingleton(id, supplier) {
  const key = makeKey(id);
  let value = globalObject[key];
  if (value) {
    return value;
  }
  value = supplier();
  globalObject[key] = value;
  return value;
}

function createVersionedValueMap(versions) {
  Object.freeze(versions);
  return {
    atVersion(version) {
      return versions[version];
    }
  };
}

const missingHolderMessage = `No ApiProvider available in react context. A common cause of this error is that multiple versions of @backstage/core-api are installed. You can check if that is the case using 'yarn backstage-cli versions:check', and can in many cases fix the issue either with the --fix flag or using 'yarn backstage-cli versions:bump'`;
const ApiContext = getOrCreateGlobalSingleton("api-context", () => createContext(void 0));
const ApiProvider = ({
  apis,
  children
}) => {
  var _a;
  const parentHolder = (_a = useContext(ApiContext)) == null ? void 0 : _a.atVersion(1);
  const versionedValue = useMemo(() => createVersionedValueMap({
    1: parentHolder ? new ApiAggregator(apis, parentHolder) : apis
  }), [parentHolder, apis]);
  return /* @__PURE__ */ React.createElement(ApiContext.Provider, {
    value: versionedValue,
    children
  });
};
ApiProvider.propTypes = {
  apis: PropTypes.shape({get: PropTypes.func.isRequired}).isRequired,
  children: PropTypes.node
};
function useApiHolder() {
  const versionedHolder = useContext(getGlobalSingleton("api-context"));
  if (!versionedHolder) {
    throw new Error(missingHolderMessage);
  }
  const apiHolder = versionedHolder.atVersion(1);
  if (!apiHolder) {
    throw new Error("ApiContext v1 not available");
  }
  return apiHolder;
}
function useApi(apiRef) {
  const apiHolder = useApiHolder();
  const api = apiHolder.get(apiRef);
  if (!api) {
    throw new Error(`No implementation available for ${apiRef}`);
  }
  return api;
}

class ApiRegistryBuilder {
  constructor() {
    this.apis = [];
  }
  add(api, impl) {
    this.apis.push([api.id, impl]);
    return impl;
  }
  build() {
    return new ApiRegistry(new Map(this.apis));
  }
}
class ApiRegistry {
  constructor(apis) {
    this.apis = apis;
  }
  static builder() {
    return new ApiRegistryBuilder();
  }
  static from(apis) {
    return new ApiRegistry(new Map(apis.map(([api, impl]) => [api.id, impl])));
  }
  static with(api, impl) {
    return new ApiRegistry(new Map([[api.id, impl]]));
  }
  with(api, impl) {
    return new ApiRegistry(new Map([...this.apis, [api.id, impl]]));
  }
  get(api) {
    return this.apis.get(api.id);
  }
}

class ApiResolver {
  constructor(factories) {
    this.factories = factories;
    this.apis = new Map();
  }
  static validateFactories(factories, apis) {
    for (const api of apis) {
      const heap = [api];
      const allDeps = new Set();
      while (heap.length) {
        const apiRef = heap.shift();
        const factory = factories.get(apiRef);
        if (!factory) {
          continue;
        }
        for (const dep of Object.values(factory.deps)) {
          if (dep.id === api.id) {
            throw new Error(`Circular dependency of api factory for ${api}`);
          }
          if (!allDeps.has(dep)) {
            allDeps.add(dep);
            heap.push(dep);
          }
        }
      }
    }
  }
  get(ref) {
    return this.load(ref);
  }
  load(ref, loading = []) {
    const impl = this.apis.get(ref.id);
    if (impl) {
      return impl;
    }
    const factory = this.factories.get(ref);
    if (!factory) {
      return void 0;
    }
    if (loading.includes(factory.api)) {
      throw new Error(`Circular dependency of api factory for ${factory.api}`);
    }
    const deps = this.loadDeps(ref, factory.deps, [...loading, factory.api]);
    const api = factory.factory(deps);
    this.apis.set(ref.id, api);
    return api;
  }
  loadDeps(dependent, apis, loading) {
    const impls = {};
    for (const key in apis) {
      if (apis.hasOwnProperty(key)) {
        const ref = apis[key];
        const api = this.load(ref, loading);
        if (!api) {
          throw new Error(`No API factory available for dependency ${ref} of dependent ${dependent}`);
        }
        impls[key] = api;
      }
    }
    return impls;
  }
}

var ScopePriority;
(function(ScopePriority2) {
  ScopePriority2[ScopePriority2["default"] = 10] = "default";
  ScopePriority2[ScopePriority2["app"] = 50] = "app";
  ScopePriority2[ScopePriority2["static"] = 100] = "static";
})(ScopePriority || (ScopePriority = {}));
class ApiFactoryRegistry {
  constructor() {
    this.factories = new Map();
  }
  register(scope, factory) {
    const priority = ScopePriority[scope];
    const existing = this.factories.get(factory.api.id);
    if (existing && existing.priority >= priority) {
      return false;
    }
    this.factories.set(factory.api.id, {priority, factory});
    return true;
  }
  get(api) {
    const tuple = this.factories.get(api.id);
    if (!tuple) {
      return void 0;
    }
    return tuple.factory;
  }
  getAllApis() {
    const refs = new Set();
    for (const {factory} of this.factories.values()) {
      refs.add(factory.api);
    }
    return refs;
  }
}

class ApiRefImpl {
  constructor(config) {
    this.config = config;
    const valid = config.id.split(".").flatMap((part) => part.split("-")).every((part) => part.match(/^[a-z][a-z0-9]*$/));
    if (!valid) {
      throw new Error(`API id must only contain period separated lowercase alphanum tokens with dashes, got '${config.id}'`);
    }
  }
  get id() {
    return this.config.id;
  }
  get description() {
    return this.config.description;
  }
  get T() {
    throw new Error(`tried to read ApiRef.T of ${this}`);
  }
  toString() {
    return `apiRef{${this.config.id}}`;
  }
}
function createApiRef(config) {
  return new ApiRefImpl(config);
}

function createApiFactory(factory, instance) {
  if ("id" in factory) {
    return {
      api: factory,
      deps: {},
      factory: () => instance
    };
  }
  return factory;
}

var SessionState;
(function(SessionState2) {
  SessionState2["SignedIn"] = "SignedIn";
  SessionState2["SignedOut"] = "SignedOut";
})(SessionState || (SessionState = {}));
const googleAuthApiRef = createApiRef({
  id: "core.auth.google",
  description: "Provides authentication towards Google APIs and identities"
});
const githubAuthApiRef = createApiRef({
  id: "core.auth.github",
  description: "Provides authentication towards GitHub APIs"
});
const oktaAuthApiRef = createApiRef({
  id: "core.auth.okta",
  description: "Provides authentication towards Okta APIs"
});
const gitlabAuthApiRef = createApiRef({
  id: "core.auth.gitlab",
  description: "Provides authentication towards GitLab APIs"
});
const auth0AuthApiRef = createApiRef({
  id: "core.auth.auth0",
  description: "Provides authentication towards Auth0 APIs"
});
const microsoftAuthApiRef = createApiRef({
  id: "core.auth.microsoft",
  description: "Provides authentication towards Microsoft APIs and identities"
});
const oauth2ApiRef = createApiRef({
  id: "core.auth.oauth2",
  description: "Example of how to use oauth2 custom provider"
});
const oidcAuthApiRef = createApiRef({
  id: "core.auth.oidc",
  description: "Example of how to use oidc custom provider"
});
const samlAuthApiRef = createApiRef({
  id: "core.auth.saml",
  description: "Example of how to use SAML custom provider"
});
const oneloginAuthApiRef = createApiRef({
  id: "core.auth.onelogin",
  description: "Provides authentication towards OneLogin APIs and identities"
});

const alertApiRef = createApiRef({
  id: "core.alert",
  description: "Used to report alerts and forward them to the app"
});

const appThemeApiRef = createApiRef({
  id: "core.apptheme",
  description: "API Used to configure the app theme, and enumerate options"
});

const configApiRef = createApiRef({
  id: "core.config",
  description: "Used to access runtime configuration"
});

const discoveryApiRef = createApiRef({
  id: "core.discovery",
  description: "Provides service discovery of backend plugins"
});

const errorApiRef = createApiRef({
  id: "core.error",
  description: "Used to report errors and forward them to the app"
});

var FeatureFlagState;
(function(FeatureFlagState2) {
  FeatureFlagState2[FeatureFlagState2["None"] = 0] = "None";
  FeatureFlagState2[FeatureFlagState2["Active"] = 1] = "Active";
})(FeatureFlagState || (FeatureFlagState = {}));
const featureFlagsApiRef = createApiRef({
  id: "core.featureflags",
  description: "Used to toggle functionality in features across Backstage"
});

const identityApiRef = createApiRef({
  id: "core.identity",
  description: "Provides access to the identity of the signed in user"
});

const oauthRequestApiRef = createApiRef({
  id: "core.oauthrequest",
  description: "An API for implementing unified OAuth flows in Backstage"
});

const storageApiRef = createApiRef({
  id: "core.storage",
  description: "Provides the ability to store data which is unique to the user"
});

function showLoginPopup(options) {
  return new Promise((resolve, reject) => {
    const width = options.width || 500;
    const height = options.height || 700;
    const left = window.screen.width / 2 - width / 2;
    const top = window.screen.height / 2 - height / 2;
    const popup = window.open(options.url, options.name, `menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=${width},height=${height},top=${top},left=${left}`);
    let targetOrigin = "";
    if (!popup || typeof popup.closed === "undefined" || popup.closed) {
      const error = new Error("Failed to open auth popup.");
      error.name = "PopupRejectedError";
      reject(error);
      return;
    }
    const messageListener = (event) => {
      if (event.source !== popup) {
        return;
      }
      if (event.origin !== options.origin) {
        return;
      }
      const {data} = event;
      if (data.type === "config_info") {
        targetOrigin = data.targetOrigin;
        return;
      }
      if (data.type !== "authorization_response") {
        return;
      }
      const authResult = data;
      if ("error" in authResult) {
        const error = new Error(authResult.error.message);
        error.name = authResult.error.name;
        reject(error);
      } else {
        resolve(authResult.response);
      }
      done();
    };
    const intervalId = setInterval(() => {
      if (popup.closed) {
        const errMessage = `Login failed, ${targetOrigin && targetOrigin !== window.location.origin ? `Incorrect app origin, expected ${targetOrigin}` : "popup was closed"}`;
        const error = new Error(errMessage);
        error.name = "PopupClosedError";
        reject(error);
        done();
      }
    }, 100);
    function done() {
      window.removeEventListener("message", messageListener);
      clearInterval(intervalId);
    }
    window.addEventListener("message", messageListener);
  });
}

function defaultJoinScopes(scopes) {
  return [...scopes].join(" ");
}
class DefaultAuthConnector {
  constructor(options) {
    const {
      discoveryApi,
      environment,
      provider,
      joinScopes = defaultJoinScopes,
      oauthRequestApi,
      sessionTransform = (id) => id
    } = options;
    this.authRequester = oauthRequestApi.createAuthRequester({
      provider,
      onAuthRequest: (scopes) => this.showPopup(scopes)
    });
    this.discoveryApi = discoveryApi;
    this.environment = environment;
    this.provider = provider;
    this.joinScopesFunc = joinScopes;
    this.sessionTransform = sessionTransform;
  }
  async createSession(options) {
    if (options.instantPopup) {
      return this.showPopup(options.scopes);
    }
    return this.authRequester(options.scopes);
  }
  async refreshSession() {
    const res = await fetch(await this.buildUrl("/refresh", {optional: true}), {
      headers: {
        "x-requested-with": "XMLHttpRequest"
      },
      credentials: "include"
    }).catch((error) => {
      throw new Error(`Auth refresh request failed, ${error}`);
    });
    if (!res.ok) {
      const error = new Error(`Auth refresh request failed, ${res.statusText}`);
      error.status = res.status;
      throw error;
    }
    const authInfo = await res.json();
    if (authInfo.error) {
      const error = new Error(authInfo.error.message);
      if (authInfo.error.name) {
        error.name = authInfo.error.name;
      }
      throw error;
    }
    return await this.sessionTransform(authInfo);
  }
  async removeSession() {
    const res = await fetch(await this.buildUrl("/logout"), {
      method: "POST",
      headers: {
        "x-requested-with": "XMLHttpRequest"
      },
      credentials: "include"
    }).catch((error) => {
      throw new Error(`Logout request failed, ${error}`);
    });
    if (!res.ok) {
      const error = new Error(`Logout request failed, ${res.statusText}`);
      error.status = res.status;
      throw error;
    }
  }
  async showPopup(scopes) {
    const scope = this.joinScopesFunc(scopes);
    const popupUrl = await this.buildUrl("/start", {scope});
    const payload = await showLoginPopup({
      url: popupUrl,
      name: `${this.provider.title} Login`,
      origin: new URL(popupUrl).origin,
      width: 450,
      height: 730
    });
    return await this.sessionTransform(payload);
  }
  async buildUrl(path, query) {
    const baseUrl = await this.discoveryApi.getBaseUrl("auth");
    const queryString = this.buildQueryString({
      ...query,
      env: this.environment
    });
    return `${baseUrl}/${this.provider.id}${path}${queryString}`;
  }
  buildQueryString(query) {
    if (!query) {
      return "";
    }
    const queryString = Object.entries(query).map(([key, value]) => {
      if (typeof value === "string") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      } else if (value) {
        return encodeURIComponent(key);
      }
      return void 0;
    }).filter(Boolean).join("&");
    if (!queryString) {
      return "";
    }
    return `?${queryString}`;
  }
}

class DirectAuthConnector {
  constructor(options) {
    const {discoveryApi, environment, provider} = options;
    this.discoveryApi = discoveryApi;
    this.environment = environment;
    this.provider = provider;
  }
  async createSession() {
    const popupUrl = await this.buildUrl("/start");
    const payload = await showLoginPopup({
      url: popupUrl,
      name: `${this.provider.title} Login`,
      origin: new URL(popupUrl).origin,
      width: 450,
      height: 730
    });
    return {
      ...payload,
      id: payload.profile.email
    };
  }
  async refreshSession() {
  }
  async removeSession() {
    const res = await fetch(await this.buildUrl("/logout"), {
      method: "POST",
      headers: {
        "x-requested-with": "XMLHttpRequest"
      },
      credentials: "include"
    }).catch((error) => {
      throw new Error(`Logout request failed, ${error}`);
    });
    if (!res.ok) {
      const error = new Error(`Logout request failed, ${res.statusText}`);
      error.status = res.status;
      throw error;
    }
  }
  async buildUrl(path) {
    const baseUrl = await this.discoveryApi.getBaseUrl("auth");
    return `${baseUrl}/${this.provider.id}${path}?env=${this.environment}`;
  }
}

function hasScopes(searched, searchFor) {
  for (const scope of searchFor) {
    if (!searched.has(scope)) {
      return false;
    }
  }
  return true;
}
class SessionScopeHelper {
  constructor(options) {
    this.options = options;
  }
  sessionExistsAndHasScope(session, scopes) {
    if (!session) {
      return false;
    }
    if (!scopes) {
      return true;
    }
    if (this.options.sessionScopes === void 0) {
      return true;
    }
    const sessionScopes = this.options.sessionScopes(session);
    return hasScopes(sessionScopes, scopes);
  }
  getExtendedScope(session, scopes) {
    const newScope = new Set(this.options.defaultScopes);
    if (session && this.options.sessionScopes !== void 0) {
      const sessionScopes = this.options.sessionScopes(session);
      for (const scope of sessionScopes) {
        newScope.add(scope);
      }
    }
    if (scopes) {
      for (const scope of scopes) {
        newScope.add(scope);
      }
    }
    return newScope;
  }
}

class PublishSubject {
  constructor() {
    this.isClosed = false;
    this.observable = new ObservableImpl((subscriber) => {
      if (this.isClosed) {
        if (this.terminatingError) {
          subscriber.error(this.terminatingError);
        } else {
          subscriber.complete();
        }
        return () => {
        };
      }
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    this.subscribers = new Set();
  }
  [Symbol.observable]() {
    return this;
  }
  get closed() {
    return this.isClosed;
  }
  next(value) {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.subscribers.forEach((subscriber) => subscriber.next(value));
  }
  error(error) {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.isClosed = true;
    this.terminatingError = error;
    this.subscribers.forEach((subscriber) => subscriber.error(error));
  }
  complete() {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.isClosed = true;
    this.subscribers.forEach((subscriber) => subscriber.complete());
  }
  subscribe(onNext, onError, onComplete) {
    const observer = typeof onNext === "function" ? {
      next: onNext,
      error: onError,
      complete: onComplete
    } : onNext;
    return this.observable.subscribe(observer);
  }
}
class BehaviorSubject {
  constructor(value) {
    this.isClosed = false;
    this.observable = new ObservableImpl((subscriber) => {
      if (this.isClosed) {
        if (this.terminatingError) {
          subscriber.error(this.terminatingError);
        } else {
          subscriber.complete();
        }
        return () => {
        };
      }
      subscriber.next(this.currentValue);
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    this.subscribers = new Set();
    this.currentValue = value;
  }
  [Symbol.observable]() {
    return this;
  }
  get closed() {
    return this.isClosed;
  }
  next(value) {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.currentValue = value;
    this.subscribers.forEach((subscriber) => subscriber.next(value));
  }
  error(error) {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.isClosed = true;
    this.terminatingError = error;
    this.subscribers.forEach((subscriber) => subscriber.error(error));
  }
  complete() {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.isClosed = true;
    this.subscribers.forEach((subscriber) => subscriber.complete());
  }
  subscribe(onNext, onError, onComplete) {
    const observer = typeof onNext === "function" ? {
      next: onNext,
      error: onError,
      complete: onComplete
    } : onNext;
    return this.observable.subscribe(observer);
  }
}

class SessionStateTracker {
  constructor() {
    this.subject = new BehaviorSubject(SessionState.SignedOut);
    this.signedIn = false;
  }
  setIsSignedIn(isSignedIn) {
    if (this.signedIn !== isSignedIn) {
      this.signedIn = isSignedIn;
      this.subject.next(this.signedIn ? SessionState.SignedIn : SessionState.SignedOut);
    }
  }
  sessionState$() {
    return this.subject;
  }
}

class RefreshingAuthSessionManager {
  constructor(options) {
    this.stateTracker = new SessionStateTracker();
    const {
      connector,
      defaultScopes = new Set(),
      sessionScopes,
      sessionShouldRefresh
    } = options;
    this.connector = connector;
    this.sessionScopesFunc = sessionScopes;
    this.sessionShouldRefreshFunc = sessionShouldRefresh;
    this.helper = new SessionScopeHelper({sessionScopes, defaultScopes});
  }
  async getSession(options) {
    if (this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)) {
      const shouldRefresh = this.sessionShouldRefreshFunc(this.currentSession);
      if (!shouldRefresh) {
        return this.currentSession;
      }
      try {
        const refreshedSession = await this.collapsedSessionRefresh();
        const currentScopes = this.sessionScopesFunc(this.currentSession);
        const refreshedScopes = this.sessionScopesFunc(refreshedSession);
        if (hasScopes(refreshedScopes, currentScopes)) {
          this.currentSession = refreshedSession;
        }
        return refreshedSession;
      } catch (error) {
        if (options.optional) {
          return void 0;
        }
        throw error;
      }
    }
    if (!this.currentSession && !options.instantPopup) {
      try {
        const newSession = await this.collapsedSessionRefresh();
        this.currentSession = newSession;
        return this.getSession(options);
      } catch {
      }
    }
    if (options.optional) {
      return void 0;
    }
    this.currentSession = await this.connector.createSession({
      ...options,
      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes)
    });
    this.stateTracker.setIsSignedIn(true);
    return this.currentSession;
  }
  async removeSession() {
    this.currentSession = void 0;
    await this.connector.removeSession();
    this.stateTracker.setIsSignedIn(false);
  }
  sessionState$() {
    return this.stateTracker.sessionState$();
  }
  async collapsedSessionRefresh() {
    if (this.refreshPromise) {
      return this.refreshPromise;
    }
    this.refreshPromise = this.connector.refreshSession();
    try {
      const session = await this.refreshPromise;
      this.stateTracker.setIsSignedIn(true);
      return session;
    } finally {
      delete this.refreshPromise;
    }
  }
}

class StaticAuthSessionManager {
  constructor(options) {
    this.stateTracker = new SessionStateTracker();
    const {connector, defaultScopes = new Set(), sessionScopes} = options;
    this.connector = connector;
    this.helper = new SessionScopeHelper({sessionScopes, defaultScopes});
  }
  setSession(session) {
    this.currentSession = session;
    this.stateTracker.setIsSignedIn(Boolean(session));
  }
  async getSession(options) {
    if (this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)) {
      return this.currentSession;
    }
    if (options.optional) {
      return void 0;
    }
    this.currentSession = await this.connector.createSession({
      ...options,
      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes)
    });
    this.stateTracker.setIsSignedIn(true);
    return this.currentSession;
  }
  async removeSession() {
    this.currentSession = void 0;
    await this.connector.removeSession();
    this.stateTracker.setIsSignedIn(false);
  }
  sessionState$() {
    return this.stateTracker.sessionState$();
  }
}

class AuthSessionStore {
  constructor(options) {
    const {
      manager,
      storageKey,
      sessionScopes,
      sessionShouldRefresh = () => false
    } = options;
    this.manager = manager;
    this.storageKey = storageKey;
    this.sessionShouldRefreshFunc = sessionShouldRefresh;
    this.helper = new SessionScopeHelper({
      sessionScopes,
      defaultScopes: new Set()
    });
  }
  async getSession(options) {
    const {scopes} = options;
    const session = this.loadSession();
    if (this.helper.sessionExistsAndHasScope(session, scopes)) {
      const shouldRefresh = this.sessionShouldRefreshFunc(session);
      if (!shouldRefresh) {
        this.manager.setSession(session);
        return session;
      }
    }
    const newSession = await this.manager.getSession(options);
    this.saveSession(newSession);
    return newSession;
  }
  async removeSession() {
    localStorage.removeItem(this.storageKey);
    await this.manager.removeSession();
  }
  sessionState$() {
    return this.manager.sessionState$();
  }
  loadSession() {
    try {
      const sessionJson = localStorage.getItem(this.storageKey);
      if (sessionJson) {
        const session = JSON.parse(sessionJson, (_key, value) => {
          if ((value == null ? void 0 : value.__type) === "Set") {
            return new Set(value.__value);
          }
          return value;
        });
        return session;
      }
      return void 0;
    } catch (error) {
      localStorage.removeItem(this.storageKey);
      return void 0;
    }
  }
  saveSession(session) {
    if (session === void 0) {
      localStorage.removeItem(this.storageKey);
    } else {
      localStorage.setItem(this.storageKey, JSON.stringify(session, (_key, value) => {
        if (value instanceof Set) {
          return {
            __type: "Set",
            __value: Array.from(value)
          };
        }
        return value;
      }));
    }
  }
}

const DEFAULT_PROVIDER = {
  id: "github",
  title: "GitHub",
  icon: GithubIcon
};
class GithubAuth {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER,
    oauthRequestApi,
    defaultScopes = ["read:user"]
  }) {
    const connector = new DefaultAuthConnector({
      discoveryApi,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            accessToken: res.providerInfo.accessToken,
            scopes: GithubAuth.normalizeScope(res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new StaticAuthSessionManager({
      connector,
      defaultScopes: new Set(defaultScopes),
      sessionScopes: (session) => session.providerInfo.scopes
    });
    const authSessionStore = new AuthSessionStore({
      manager: sessionManager,
      storageKey: `${provider.id}Session`,
      sessionScopes: (session) => session.providerInfo.scopes
    });
    return new GithubAuth(authSessionStore);
  }
  async signIn() {
    await this.getAccessToken();
  }
  async signOut() {
    await this.sessionManager.removeSession();
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: GithubAuth.normalizeScope(scope)
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  static normalizeScope(scope) {
    if (!scope) {
      return new Set();
    }
    const scopeList = Array.isArray(scope) ? scope : scope.split(/[\s|,]/).filter(Boolean);
    return new Set(scopeList);
  }
}

const DEFAULT_PROVIDER$1 = {
  id: "oauth2",
  title: "Your Identity Provider",
  icon: GithubIcon
};
class OAuth2 {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$1,
    oauthRequestApi,
    defaultScopes = [],
    scopeTransform = (x) => x
  }) {
    const connector = new DefaultAuthConnector({
      discoveryApi,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            idToken: res.providerInfo.idToken,
            accessToken: res.providerInfo.accessToken,
            scopes: OAuth2.normalizeScopes(scopeTransform, res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new RefreshingAuthSessionManager({
      connector,
      defaultScopes: new Set(defaultScopes),
      sessionScopes: (session) => session.providerInfo.scopes,
      sessionShouldRefresh: (session) => {
        const expiresInSec = (session.providerInfo.expiresAt.getTime() - Date.now()) / 1e3;
        return expiresInSec < 60 * 5;
      }
    });
    return new OAuth2({sessionManager, scopeTransform});
  }
  constructor(options) {
    this.sessionManager = options.sessionManager;
    this.scopeTransform = options.scopeTransform;
  }
  async signIn() {
    await this.getAccessToken();
  }
  async signOut() {
    await this.sessionManager.removeSession();
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const normalizedScopes = OAuth2.normalizeScopes(this.scopeTransform, scope);
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: normalizedScopes
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getIdToken(options = {}) {
    var _a;
    const session = await this.sessionManager.getSession(options);
    return (_a = session == null ? void 0 : session.providerInfo.idToken) != null ? _a : "";
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  static normalizeScopes(scopeTransform, scopes) {
    if (!scopes) {
      return new Set();
    }
    const scopeList = Array.isArray(scopes) ? scopes : scopes.split(/[\s|,]/).filter(Boolean);
    return new Set(scopeTransform(scopeList));
  }
}

const DEFAULT_PROVIDER$2 = {
  id: "gitlab",
  title: "GitLab",
  icon: GithubIcon
};
class GitlabAuth {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$2,
    oauthRequestApi,
    defaultScopes = ["read_user"]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes
    });
  }
}

const DEFAULT_PROVIDER$3 = {
  id: "google",
  title: "Google",
  icon: GithubIcon
};
const SCOPE_PREFIX = "https://www.googleapis.com/auth/";
class GoogleAuth {
  static create({
    discoveryApi,
    oauthRequestApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$3,
    defaultScopes = [
      "openid",
      `${SCOPE_PREFIX}userinfo.email`,
      `${SCOPE_PREFIX}userinfo.profile`
    ]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes,
      scopeTransform(scopes) {
        return scopes.map((scope) => {
          if (scope === "openid") {
            return scope;
          }
          if (scope === "profile" || scope === "email") {
            return `${SCOPE_PREFIX}userinfo.${scope}`;
          }
          if (scope.startsWith(SCOPE_PREFIX)) {
            return scope;
          }
          return `${SCOPE_PREFIX}${scope}`;
        });
      }
    });
  }
}

const DEFAULT_PROVIDER$4 = {
  id: "okta",
  title: "Okta",
  icon: GithubIcon
};
const OKTA_OIDC_SCOPES = new Set([
  "openid",
  "profile",
  "email",
  "phone",
  "address",
  "groups",
  "offline_access"
]);
const OKTA_SCOPE_PREFIX = "okta.";
class OktaAuth {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$4,
    oauthRequestApi,
    defaultScopes = ["openid", "email", "profile", "offline_access"]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes,
      scopeTransform(scopes) {
        return scopes.map((scope) => {
          if (OKTA_OIDC_SCOPES.has(scope)) {
            return scope;
          }
          if (scope.startsWith(OKTA_SCOPE_PREFIX)) {
            return scope;
          }
          return `${OKTA_SCOPE_PREFIX}${scope}`;
        });
      }
    });
  }
}

const DEFAULT_PROVIDER$5 = {
  id: "saml",
  title: "SAML",
  icon: GithubIcon
};
class SamlAuth {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$5
  }) {
    const connector = new DirectAuthConnector({
      discoveryApi,
      environment,
      provider
    });
    const sessionManager = new StaticAuthSessionManager({
      connector
    });
    const authSessionStore = new AuthSessionStore({
      manager: sessionManager,
      storageKey: `${provider.id}Session`
    });
    return new SamlAuth(authSessionStore);
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async signIn() {
    await this.getBackstageIdentity({});
  }
  async signOut() {
    await this.sessionManager.removeSession();
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
}

const DEFAULT_PROVIDER$6 = {
  id: "auth0",
  title: "Auth0",
  icon: GithubIcon
};
class Auth0Auth {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$6,
    oauthRequestApi,
    defaultScopes = ["openid", `email`, `profile`]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes
    });
  }
}

const DEFAULT_PROVIDER$7 = {
  id: "microsoft",
  title: "Microsoft",
  icon: GithubIcon
};
class MicrosoftAuth {
  static create({
    environment = "development",
    provider = DEFAULT_PROVIDER$7,
    oauthRequestApi,
    discoveryApi,
    defaultScopes = [
      "openid",
      "offline_access",
      "profile",
      "email",
      "User.Read"
    ]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes
    });
  }
}

const DEFAULT_PROVIDER$8 = {
  id: "onelogin",
  title: "onelogin",
  icon: GithubIcon
};
const OIDC_SCOPES = new Set([
  "openid",
  "profile",
  "email",
  "phone",
  "address",
  "groups",
  "offline_access"
]);
const SCOPE_PREFIX$1 = "onelogin.";
class OneLoginAuth {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$8,
    oauthRequestApi
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes: ["openid", "email", "profile", "offline_access"],
      scopeTransform(scopes) {
        return scopes.map((scope) => {
          if (OIDC_SCOPES.has(scope)) {
            return scope;
          }
          if (scope.startsWith(SCOPE_PREFIX$1)) {
            return scope;
          }
          return `${SCOPE_PREFIX$1}${scope}`;
        });
      }
    });
  }
}

class AlertApiForwarder {
  constructor() {
    this.subject = new PublishSubject();
  }
  post(alert) {
    this.subject.next(alert);
  }
  alert$() {
    return this.subject;
  }
}

const STORAGE_KEY = "theme";
class AppThemeSelector {
  constructor(themes) {
    this.themes = themes;
    this.subject = new BehaviorSubject(void 0);
  }
  static createWithStorage(themes) {
    var _a;
    const selector = new AppThemeSelector(themes);
    if (!window.localStorage) {
      return selector;
    }
    const initialThemeId = (_a = window.localStorage.getItem(STORAGE_KEY)) != null ? _a : void 0;
    selector.setActiveThemeId(initialThemeId);
    selector.activeThemeId$().subscribe((themeId) => {
      if (themeId) {
        window.localStorage.setItem(STORAGE_KEY, themeId);
      } else {
        window.localStorage.removeItem(STORAGE_KEY);
      }
    });
    window.addEventListener("storage", (event) => {
      var _a2;
      if (event.key === STORAGE_KEY) {
        const themeId = (_a2 = localStorage.getItem(STORAGE_KEY)) != null ? _a2 : void 0;
        selector.setActiveThemeId(themeId);
      }
    });
    return selector;
  }
  getInstalledThemes() {
    return this.themes.slice();
  }
  activeThemeId$() {
    return this.subject;
  }
  getActiveThemeId() {
    return this.activeThemeId;
  }
  setActiveThemeId(themeId) {
    this.activeThemeId = themeId;
    this.subject.next(themeId);
  }
}

class UrlPatternDiscovery {
  constructor(parts) {
    this.parts = parts;
  }
  static compile(pattern) {
    const parts = pattern.split(/\{\{\s*pluginId\s*\}\}/);
    try {
      const urlStr = parts.join("pluginId");
      const url = new URL(urlStr);
      if (url.hash) {
        throw new Error("URL must not have a hash");
      }
      if (url.search) {
        throw new Error("URL must not have a query");
      }
      if (urlStr.endsWith("/")) {
        throw new Error("URL must not end with a slash");
      }
    } catch (error) {
      throw new Error(`Invalid discovery URL pattern, ${error.message}`);
    }
    return new UrlPatternDiscovery(parts);
  }
  async getBaseUrl(pluginId) {
    return this.parts.join(pluginId);
  }
}

class ErrorAlerter {
  constructor(alertApi, errorApi) {
    this.alertApi = alertApi;
    this.errorApi = errorApi;
  }
  post(error, context) {
    if (!(context == null ? void 0 : context.hidden)) {
      this.alertApi.post({message: error.message, severity: "error"});
    }
    return this.errorApi.post(error, context);
  }
  error$() {
    return this.errorApi.error$();
  }
}

class ErrorApiForwarder {
  constructor() {
    this.subject = new PublishSubject();
  }
  post(error, context) {
    this.subject.next({error, context});
  }
  error$() {
    return this.subject;
  }
}

function validateFlagName(name) {
  if (name.length < 3) {
    throw new Error(`The '${name}' feature flag must have a minimum length of three characters.`);
  }
  if (name.length > 150) {
    throw new Error(`The '${name}' feature flag must not exceed 150 characters.`);
  }
  if (!name.match(/^[a-z]+[a-z0-9-]+$/)) {
    throw new Error(`The '${name}' feature flag must start with a lowercase letter and only contain lowercase letters, numbers and hyphens. Examples: feature-flag-one, alpha, release-2020`);
  }
}
class LocalStorageFeatureFlags {
  constructor() {
    this.registeredFeatureFlags = [];
  }
  registerFlag(flag) {
    validateFlagName(flag.name);
    this.registeredFeatureFlags.push(flag);
  }
  getRegisteredFlags() {
    return this.registeredFeatureFlags.slice();
  }
  isActive(name) {
    if (!this.flags) {
      this.flags = this.load();
    }
    return this.flags.get(name) === FeatureFlagState.Active;
  }
  save(options) {
    if (!this.flags) {
      this.flags = this.load();
    }
    if (!options.merge) {
      this.flags.clear();
    }
    for (const [name, state] of Object.entries(options.states)) {
      this.flags.set(name, state);
    }
    const enabled = Array.from(this.flags.entries()).filter(([, state]) => state === FeatureFlagState.Active);
    window.localStorage.setItem("featureFlags", JSON.stringify(Object.fromEntries(enabled)));
  }
  load() {
    try {
      const jsonStr = window.localStorage.getItem("featureFlags");
      if (!jsonStr) {
        return new Map();
      }
      const json = JSON.parse(jsonStr);
      if (typeof json !== "object" || json === null || Array.isArray(json)) {
        return new Map();
      }
      const entries = Object.entries(json).filter(([name, value]) => {
        validateFlagName(name);
        return value === FeatureFlagState.Active;
      });
      return new Map(entries);
    } catch {
      return new Map();
    }
  }
}

function hasScopes$1(searched, searchFor) {
  for (const scope of searchFor) {
    if (!searched.has(scope)) {
      return false;
    }
  }
  return true;
}
function joinScopes(scopes, ...moreScopess) {
  const result = new Set(scopes);
  for (const moreScopes of moreScopess) {
    for (const scope of moreScopes) {
      result.add(scope);
    }
  }
  return result;
}
class OAuthPendingRequests {
  constructor() {
    this.requests = [];
    this.subject = new BehaviorSubject(this.getCurrentPending());
  }
  request(scopes) {
    return new Promise((resolve, reject) => {
      this.requests.push({scopes, resolve, reject});
      this.subject.next(this.getCurrentPending());
    });
  }
  resolve(scopes, result) {
    this.requests = this.requests.filter((request) => {
      if (hasScopes$1(scopes, request.scopes)) {
        request.resolve(result);
        return false;
      }
      return true;
    });
    this.subject.next(this.getCurrentPending());
  }
  reject(error) {
    this.requests.forEach((request) => request.reject(error));
    this.requests = [];
    this.subject.next(this.getCurrentPending());
  }
  pending() {
    return this.subject;
  }
  getCurrentPending() {
    const currentScopes = this.requests.length === 0 ? void 0 : this.requests.slice(1).reduce((acc, current) => joinScopes(acc, current.scopes), this.requests[0].scopes);
    return {
      scopes: currentScopes,
      resolve: (value) => {
        if (currentScopes) {
          this.resolve(currentScopes, value);
        }
      },
      reject: (reason) => {
        if (currentScopes) {
          this.reject(reason);
        }
      }
    };
  }
}

class OAuthRequestManager {
  constructor() {
    this.subject = new BehaviorSubject([]);
    this.currentRequests = [];
    this.handlerCount = 0;
  }
  createAuthRequester(options) {
    const handler = new OAuthPendingRequests();
    const index = this.handlerCount;
    this.handlerCount++;
    handler.pending().subscribe({
      next: (scopeRequest) => {
        const newRequests = this.currentRequests.slice();
        const request = this.makeAuthRequest(scopeRequest, options);
        if (!request) {
          delete newRequests[index];
        } else {
          newRequests[index] = request;
        }
        this.currentRequests = newRequests;
        this.subject.next(newRequests.filter(Boolean));
      }
    });
    return (scopes) => {
      return handler.request(scopes);
    };
  }
  makeAuthRequest(request, options) {
    const {scopes} = request;
    if (!scopes) {
      return void 0;
    }
    return {
      provider: options.provider,
      trigger: async () => {
        const result = await options.onAuthRequest(scopes);
        request.resolve(result);
      },
      reject: () => {
        const error = new Error("Login failed, rejected by user");
        error.name = "RejectedError";
        request.reject(error);
      }
    };
  }
  authRequest$() {
    return this.subject;
  }
}

const buckets = new Map();
class WebStorage {
  constructor(namespace, errorApi) {
    this.namespace = namespace;
    this.errorApi = errorApi;
    this.subscribers = new Set();
    this.observable = new ObservableImpl((subscriber) => {
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
  }
  static create(options) {
    var _a;
    return new WebStorage((_a = options.namespace) != null ? _a : "", options.errorApi);
  }
  get(key) {
    try {
      const storage = JSON.parse(localStorage.getItem(this.getKeyName(key)));
      return storage != null ? storage : void 0;
    } catch (e) {
      this.errorApi.post(new Error(`Error when parsing JSON config from storage for: ${key}`));
    }
    return void 0;
  }
  forBucket(name) {
    const bucketPath = `${this.namespace}/${name}`;
    if (!buckets.has(bucketPath)) {
      buckets.set(bucketPath, new WebStorage(bucketPath, this.errorApi));
    }
    return buckets.get(bucketPath);
  }
  async set(key, data) {
    localStorage.setItem(this.getKeyName(key), JSON.stringify(data, null, 2));
    this.notifyChanges({key, newValue: data});
  }
  async remove(key) {
    localStorage.removeItem(this.getKeyName(key));
    this.notifyChanges({key, newValue: void 0});
  }
  observe$(key) {
    return this.observable.filter(({key: messageKey}) => messageKey === key);
  }
  getKeyName(key) {
    return `${this.namespace}/${encodeURIComponent(key)}`;
  }
  notifyChanges(message) {
    for (const subscription of this.subscribers) {
      subscription.next(message);
    }
  }
}

const AppContext = getOrCreateGlobalSingleton("app-context", () => createContext(void 0));
const AppContextProvider = ({
  appContext,
  children
}) => {
  const versionedValue = useMemo(() => createVersionedValueMap({1: appContext}), [appContext]);
  return /* @__PURE__ */ React.createElement(AppContext.Provider, {
    value: versionedValue,
    children
  });
};
const useApp = () => {
  const versionedContext = useContext(getGlobalSingleton("app-context"));
  if (!versionedContext) {
    throw new Error("No app context available");
  }
  const appContext = versionedContext.atVersion(1);
  if (!appContext) {
    throw new Error("AppContext v1 not available");
  }
  return appContext;
};

const DATA_KEY = Symbol("backstage-component-data");
const store = getOrCreateGlobalSingleton("component-data-store", () => new WeakMap());
function attachComponentData(component, type, data) {
  const dataComponent = component;
  let container = store.get(component) || dataComponent[DATA_KEY];
  if (!container) {
    container = {map: new Map()};
    store.set(component, container);
    dataComponent[DATA_KEY] = container;
  }
  if (container.map.has(type)) {
    const name = component.displayName || component.name;
    throw new Error(`Attempted to attach duplicate data "${type}" to component "${name}"`);
  }
  container.map.set(type, data);
}
function getComponentData(node, type) {
  if (!node) {
    return void 0;
  }
  const component = node.type;
  if (!component) {
    return void 0;
  }
  const container = store.get(component) || component[DATA_KEY];
  if (!container) {
    return void 0;
  }
  return container.map.get(type);
}

const routeRefType = getOrCreateGlobalSingleton("route-ref-type", () => Symbol("route-ref-type"));

var _a;
class ExternalRouteRefImpl {
  constructor(id, params, optional) {
    this.id = id;
    this.params = params;
    this.optional = optional;
    this[_a] = "external";
  }
  toString() {
    return `routeRef{type=external,id=${this.id}}`;
  }
}
_a = routeRefType;
function createExternalRouteRef(options) {
  var _a2;
  return new ExternalRouteRefImpl(options.id, (_a2 = options.params) != null ? _a2 : [], Boolean(options.optional));
}
function isExternalRouteRef(routeRef) {
  return routeRef[routeRefType] === "external";
}

function createRoutesFromChildren(childrenNode) {
  return Children.toArray(childrenNode).flatMap((child) => {
    var _a;
    if (!isValidElement(child)) {
      return [];
    }
    const {children} = child.props;
    if (child.type === Fragment) {
      return createRoutesFromChildren(children);
    }
    let path = child.props.path;
    if (path === "") {
      return [];
    }
    path = (_a = path == null ? void 0 : path.replace(/\/\*$/, "")) != null ? _a : "/";
    return [
      {
        path,
        element: child,
        children: children && [
          {
            path: "/*",
            element: children
          }
        ]
      }
    ];
  });
}
const FlatRoutes = (props) => {
  const app = useApp();
  const {NotFoundErrorPage} = app.getComponents();
  const routes = createRoutesFromChildren(props.children).sort((a, b) => b.path.localeCompare(a.path)).map((obj) => {
    obj.path = obj.path === "/" ? "/" : `${obj.path}/*`;
    return obj;
  });
  routes.push({
    element: /* @__PURE__ */ React.createElement(NotFoundErrorPage, null),
    path: "/*"
  });
  return useRoutes(routes);
};

var _a$1;
class RouteRefImpl {
  constructor(id, params, config) {
    this.id = id;
    this.params = params;
    this.config = config;
    this[_a$1] = "absolute";
  }
  get icon() {
    return this.config.icon;
  }
  get path() {
    var _a2;
    return (_a2 = this.config.path) != null ? _a2 : "";
  }
  get title() {
    var _a2;
    return (_a2 = this.config.title) != null ? _a2 : this.id;
  }
  toString() {
    return `routeRef{type=absolute,id=${this.id}}`;
  }
}
_a$1 = routeRefType;
function createRouteRef(config) {
  var _a2;
  const id = config.id || config.title;
  if (!id) {
    throw new Error("RouteRef must be provided a non-empty id");
  }
  return new RouteRefImpl(id, (_a2 = config.params) != null ? _a2 : [], config);
}
function isRouteRef(routeRef) {
  return routeRef[routeRefType] === "absolute";
}

var _a$2;
const PARAM_PATTERN = /^\w+$/;
class SubRouteRefImpl {
  constructor(id, path, parent, params) {
    this.id = id;
    this.path = path;
    this.parent = parent;
    this.params = params;
    this[_a$2] = "sub";
  }
  toString() {
    return `routeRef{type=sub,id=${this.id}}`;
  }
}
_a$2 = routeRefType;
function createSubRouteRef(config) {
  const {id, path, parent} = config;
  const pathParams = path.split("/").filter((p) => p.startsWith(":")).map((p) => p.substring(1));
  const params = [...parent.params, ...pathParams];
  if (parent.params.some((p) => pathParams.includes(p))) {
    throw new Error("SubRouteRef may not have params that overlap with its parent");
  }
  if (!path.startsWith("/")) {
    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);
  }
  if (path.endsWith("/")) {
    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);
  }
  for (const param of pathParams) {
    if (!PARAM_PATTERN.test(param)) {
      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);
    }
  }
  const subRouteRef = new SubRouteRefImpl(id, path, parent, params);
  return subRouteRef;
}
function isSubRouteRef(routeRef) {
  return routeRef[routeRefType] === "sub";
}

function joinPaths(...paths) {
  const normalized = paths.join("/").replace(/\/\/+/g, "/");
  if (normalized !== "/" && normalized.endsWith("/")) {
    return normalized.slice(0, -1);
  }
  return normalized;
}
function resolveTargetRef(anyRouteRef, routePaths, routeBindings) {
  let targetRef;
  let subRoutePath = "";
  if (isRouteRef(anyRouteRef)) {
    targetRef = anyRouteRef;
  } else if (isSubRouteRef(anyRouteRef)) {
    targetRef = anyRouteRef.parent;
    subRoutePath = anyRouteRef.path;
  } else if (isExternalRouteRef(anyRouteRef)) {
    const resolvedRoute = routeBindings.get(anyRouteRef);
    if (!resolvedRoute) {
      return [void 0, ""];
    }
    if (isRouteRef(resolvedRoute)) {
      targetRef = resolvedRoute;
    } else if (isSubRouteRef(resolvedRoute)) {
      targetRef = resolvedRoute.parent;
      subRoutePath = resolvedRoute.path;
    } else {
      throw new Error(`ExternalRouteRef was bound to invalid target, ${resolvedRoute}`);
    }
  } else if (anyRouteRef[routeRefType]) {
    throw new Error(`Unknown or invalid route ref type, ${anyRouteRef[routeRefType]}`);
  } else {
    throw new Error(`Unknown object passed to useRouteRef, got ${anyRouteRef}`);
  }
  if (!targetRef) {
    return [void 0, ""];
  }
  const resolvedPath = routePaths.get(targetRef);
  if (!resolvedPath) {
    return [void 0, ""];
  }
  const targetPath = joinPaths(resolvedPath, subRoutePath);
  return [targetRef, targetPath];
}
function resolveBasePath(targetRef, sourceLocation, routePaths, routeParents, routeObjects) {
  var _a;
  const match = (_a = matchRoutes(routeObjects, sourceLocation)) != null ? _a : [];
  const refDiffList = Array();
  let matchIndex = -1;
  for (let targetSearchRef = targetRef; targetSearchRef; targetSearchRef = routeParents.get(targetSearchRef)) {
    matchIndex = match.findIndex((m) => m.route.routeRefs.has(targetSearchRef));
    if (matchIndex !== -1) {
      break;
    }
    refDiffList.unshift(targetSearchRef);
  }
  if (refDiffList.length === 0) {
    matchIndex -= 1;
  }
  const parentPath = matchIndex === -1 ? "" : match[matchIndex].pathname;
  const diffPath = joinPaths(...refDiffList.slice(0, -1).map((ref) => {
    const path = routePaths.get(ref);
    if (!path) {
      throw new Error(`No path for ${ref}`);
    }
    if (path.includes(":")) {
      throw new Error(`Cannot route to ${targetRef} with parent ${ref} as it has parameters`);
    }
    return path;
  }));
  return parentPath + diffPath;
}
class RouteResolver {
  constructor(routePaths, routeParents, routeObjects, routeBindings) {
    this.routePaths = routePaths;
    this.routeParents = routeParents;
    this.routeObjects = routeObjects;
    this.routeBindings = routeBindings;
  }
  resolve(anyRouteRef, sourceLocation) {
    const [targetRef, targetPath] = resolveTargetRef(anyRouteRef, this.routePaths, this.routeBindings);
    if (!targetRef) {
      return void 0;
    }
    const basePath = resolveBasePath(targetRef, sourceLocation, this.routePaths, this.routeParents, this.routeObjects);
    const routeFunc = (...[params]) => {
      return basePath + generatePath(targetPath, params);
    };
    return routeFunc;
  }
}

const RoutingContext = getOrCreateGlobalSingleton("routing-context", () => createContext(void 0));
function useRouteRef(routeRef) {
  const sourceLocation = useLocation();
  const versionedContext = useContext(getGlobalSingleton("routing-context"));
  const resolver = versionedContext == null ? void 0 : versionedContext.atVersion(1);
  const routeFunc = useMemo(() => resolver && resolver.resolve(routeRef, sourceLocation), [resolver, routeRef, sourceLocation]);
  if (!versionedContext) {
    throw new Error("useRouteRef used outside of routing context");
  }
  if (!resolver) {
    throw new Error("RoutingContext v1 not available");
  }
  const isOptional = "optional" in routeRef && routeRef.optional;
  if (!routeFunc && !isOptional) {
    throw new Error(`No path for ${routeRef}`);
  }
  return routeFunc;
}
const RoutingProvider = ({
  routePaths,
  routeParents,
  routeObjects,
  routeBindings,
  children
}) => {
  const resolver = new RouteResolver(routePaths, routeParents, routeObjects, routeBindings);
  const versionedValue = createVersionedValueMap({1: resolver});
  return /* @__PURE__ */ React.createElement(RoutingContext.Provider, {
    value: versionedValue
  }, children);
};
function useRouteRefParams(_routeRef) {
  return useParams();
}

function createRoutableExtension(options) {
  const {component, mountPoint} = options;
  return createReactExtension({
    component: {
      lazy: () => component().then((InnerComponent) => {
        const RoutableExtensionWrapper = (props) => {
          try {
            useRouteRef(mountPoint);
          } catch (error) {
            if (error == null ? void 0 : error.message.startsWith("No path for ")) {
              throw new Error(`Routable extension component with mount point ${mountPoint} was not discovered in the app element tree. Routable extension components may not be rendered by other components and must be directly available as an element within the App provider component.`);
            }
            throw error;
          }
          return /* @__PURE__ */ React.createElement(InnerComponent, {
            ...props
          });
        };
        const componentName = InnerComponent.displayName || InnerComponent.name || "LazyComponent";
        RoutableExtensionWrapper.displayName = `RoutableExtension(${componentName})`;
        return RoutableExtensionWrapper;
      }, (error) => {
        const RoutableExtensionWrapper = (_) => {
          const app = useApp();
          const {BootErrorPage} = app.getComponents();
          return /* @__PURE__ */ React.createElement(BootErrorPage, {
            step: "load-chunk",
            error
          });
        };
        return RoutableExtensionWrapper;
      })
    },
    data: {
      "core.mountPoint": mountPoint
    }
  });
}
function createComponentExtension(options) {
  const {component} = options;
  return createReactExtension({component});
}
function createReactExtension(options) {
  const {data = {}} = options;
  let Component;
  if ("lazy" in options.component) {
    const lazyLoader = options.component.lazy;
    Component = lazy(() => lazyLoader().then((component) => ({default: component})));
  } else {
    Component = options.component.sync;
  }
  const componentName = Component.displayName || Component.name || "Component";
  return {
    expose(plugin) {
      const Result = (props) => /* @__PURE__ */ React.createElement(Suspense, {
        fallback: "..."
      }, /* @__PURE__ */ React.createElement(Component, {
        ...props
      }));
      attachComponentData(Result, "core.plugin", plugin);
      for (const [key, value] of Object.entries(data)) {
        attachComponentData(Result, key, value);
      }
      Result.displayName = `Extension(${componentName})`;
      return Result;
    }
  };
}

const defaultSystemIcons = {
  brokenImage: MuiBrokenImageIcon,
  catalog: MuiMenuBookIcon,
  chat: MuiChatIcon,
  dashboard: MuiDashboardIcon,
  email: MuiEmailIcon,
  github: MuiGitHubIcon,
  group: MuiPeopleIcon,
  help: MuiHelpIcon,
  user: MuiPersonIcon,
  warning: MuiWarningIcon,
  docs: MuiDocsIcon
};
const overridableSystemIcon = (key) => {
  const Component = (props) => {
    const app = useApp();
    const Icon = app.getSystemIcon(key);
    return Icon ? /* @__PURE__ */ React.createElement(Icon, {
      ...props
    }) : /* @__PURE__ */ React.createElement(MuiBrokenImageIcon, {
      ...props
    });
  };
  return Component;
};
const BrokenImageIcon = overridableSystemIcon("brokenImage");
const ChatIcon = overridableSystemIcon("chat");
const DashboardIcon = overridableSystemIcon("dashboard");
const EmailIcon = overridableSystemIcon("email");
const GitHubIcon = overridableSystemIcon("github");
const GroupIcon = overridableSystemIcon("group");
const HelpIcon = overridableSystemIcon("help");
const UserIcon = overridableSystemIcon("user");
const WarningIcon = overridableSystemIcon("warning");
const DocsIcon = overridableSystemIcon("docs");

class PluginImpl {
  constructor(config) {
    this.config = config;
  }
  getId() {
    return this.config.id;
  }
  getApis() {
    var _a;
    return (_a = this.config.apis) != null ? _a : [];
  }
  get routes() {
    var _a;
    return (_a = this.config.routes) != null ? _a : {};
  }
  get externalRoutes() {
    var _a;
    return (_a = this.config.externalRoutes) != null ? _a : {};
  }
  output() {
    if (this.storedOutput) {
      return this.storedOutput;
    }
    if (!this.config.register) {
      return [];
    }
    const outputs = new Array();
    this.config.register({
      router: {
        addRoute(target, component, options) {
          outputs.push({
            type: "route",
            target,
            component,
            options
          });
        }
      },
      featureFlags: {
        register(name) {
          outputs.push({type: "feature-flag", name});
        }
      }
    });
    this.storedOutput = outputs;
    return this.storedOutput;
  }
  provide(extension) {
    return extension.expose(this);
  }
  toString() {
    return `plugin{${this.config.id}}`;
  }
}
function createPlugin(config) {
  return new PluginImpl(config);
}

function traverseElementTree(options) {
  const collectors = {};
  for (const name in options.collectors) {
    if (options.collectors.hasOwnProperty(name)) {
      collectors[name] = options.collectors[name]();
    }
  }
  const queue = [
    {
      node: Children.toArray(options.root),
      parent: void 0,
      contexts: {}
    }
  ];
  while (queue.length !== 0) {
    const {node, parent, contexts} = queue.shift();
    Children.forEach(node, (element) => {
      if (!isValidElement(element)) {
        return;
      }
      const nextContexts = {};
      for (const name in collectors) {
        if (collectors.hasOwnProperty(name)) {
          const collector = collectors[name];
          nextContexts[name] = collector.visit(collector.accumulator, element, parent, contexts[name]);
        }
      }
      for (const discoverer of options.discoverers) {
        const children = discoverer(element);
        if (children) {
          queue.push({
            node: children,
            parent: element,
            contexts: nextContexts
          });
        }
      }
    });
  }
  return Object.fromEntries(Object.entries(collectors).map(([name, c]) => [name, c.accumulator]));
}
function createCollector(accumulatorFactory, visit) {
  return () => ({accumulator: accumulatorFactory(), visit});
}
function childDiscoverer(element) {
  var _a;
  return (_a = element.props) == null ? void 0 : _a.children;
}
function routeElementDiscoverer(element) {
  var _a, _b, _c;
  if (((_a = element.props) == null ? void 0 : _a.path) && ((_b = element.props) == null ? void 0 : _b.element)) {
    return (_c = element.props) == null ? void 0 : _c.element;
  }
  return void 0;
}

const pluginCollector = createCollector(() => new Set(), (acc, node) => {
  const plugin = getComponentData(node, "core.plugin");
  if (plugin) {
    acc.add(plugin);
  }
});

function getMountPoint(node) {
  var _a;
  const element = (_a = node.props) == null ? void 0 : _a.element;
  let routeRef = getComponentData(node, "core.mountPoint");
  if (!routeRef && isValidElement(element)) {
    routeRef = getComponentData(element, "core.mountPoint");
  }
  return routeRef;
}
const routePathCollector = createCollector(() => new Map(), (acc, node, parent, ctxPath) => {
  var _a, _b;
  let currentCtxPath = ctxPath;
  if ((parent == null ? void 0 : parent.props.element) === node) {
    return currentCtxPath;
  }
  if (getComponentData(node, "core.gatherMountPoints")) {
    const path = (_a = node.props) == null ? void 0 : _a.path;
    if (!path) {
      throw new Error("Mount point gatherer must have a path");
    }
    currentCtxPath = path;
  }
  const routeRef = getMountPoint(node);
  if (routeRef) {
    let path = (_b = node.props) == null ? void 0 : _b.path;
    if (currentCtxPath) {
      if (path) {
        currentCtxPath = void 0;
      } else {
        path = currentCtxPath;
      }
    }
    if (!path) {
      throw new Error("Mounted routable extension must have a path");
    }
    acc.set(routeRef, path);
  }
  return currentCtxPath;
});
const routeParentCollector = createCollector(() => new Map(), (acc, node, parent, parentRouteRef) => {
  var _a;
  if ((parent == null ? void 0 : parent.props.element) === node) {
    return parentRouteRef;
  }
  let nextParent = parentRouteRef;
  const routeRef = getMountPoint(node);
  if (routeRef) {
    if (parentRouteRef && "sticky" in parentRouteRef) {
      acc.set(routeRef, parentRouteRef.sticky);
      if ((_a = node.props) == null ? void 0 : _a.path) {
        nextParent = routeRef;
      } else {
        nextParent = parentRouteRef;
      }
    } else {
      acc.set(routeRef, parentRouteRef);
      nextParent = routeRef;
    }
  }
  if (getComponentData(node, "core.gatherMountPoints")) {
    return {sticky: nextParent};
  }
  return nextParent;
});
const MATCH_ALL_ROUTE = {
  caseSensitive: false,
  path: "/*",
  element: "match-all",
  routeRefs: new Set()
};
const routeObjectCollector = createCollector(() => Array(), (acc, node, parent, parentObj) => {
  var _a, _b, _c;
  const parentChildren = (_a = parentObj == null ? void 0 : parentObj.children) != null ? _a : acc;
  if ((parent == null ? void 0 : parent.props.element) === node) {
    return parentObj;
  }
  const path = (_b = node.props) == null ? void 0 : _b.path;
  const caseSensitive = Boolean((_c = node.props) == null ? void 0 : _c.caseSensitive);
  const routeRef = getMountPoint(node);
  if (routeRef) {
    if (path) {
      const newObject = {
        caseSensitive,
        path,
        element: "mounted",
        routeRefs: new Set([routeRef]),
        children: [MATCH_ALL_ROUTE]
      };
      parentChildren.push(newObject);
      return newObject;
    }
    parentObj == null ? void 0 : parentObj.routeRefs.add(routeRef);
  }
  const isGatherer = getComponentData(node, "core.gatherMountPoints");
  if (isGatherer) {
    if (!path) {
      throw new Error("Mount point gatherer must have a path");
    }
    const newObject = {
      caseSensitive,
      path,
      element: "gathered",
      routeRefs: new Set(),
      children: [MATCH_ALL_ROUTE]
    };
    parentChildren.push(newObject);
    return newObject;
  }
  return parentObj;
});

function validateRoutes(routePaths, routeParents) {
  const notLeafRoutes = new Set(routeParents.values());
  notLeafRoutes.delete(void 0);
  for (const route of routeParents.keys()) {
    if (notLeafRoutes.has(route)) {
      continue;
    }
    let currentRouteRef = route;
    let fullPath = "";
    while (currentRouteRef) {
      const path = routePaths.get(currentRouteRef);
      if (!path) {
        throw new Error(`No path for ${currentRouteRef}`);
      }
      fullPath = `${path}${fullPath}`;
      currentRouteRef = routeParents.get(currentRouteRef);
    }
    const params = fullPath.match(/:(\w+)/g);
    if (params) {
      for (let j = 0; j < params.length; j++) {
        for (let i = j + 1; i < params.length; i++) {
          if (params[i] === params[j]) {
            throw new Error(`Parameter ${params[i]} is duplicated in path ${fullPath}`);
          }
        }
      }
    }
  }
}

class AppIdentity {
  constructor() {
    this.hasIdentity = false;
  }
  getUserId() {
    if (!this.hasIdentity) {
      throw new Error("Tried to access IdentityApi userId before app was loaded");
    }
    return this.userId;
  }
  getProfile() {
    if (!this.hasIdentity) {
      throw new Error("Tried to access IdentityApi profile before app was loaded");
    }
    return this.profile;
  }
  async getIdToken() {
    var _a;
    if (!this.hasIdentity) {
      throw new Error("Tried to access IdentityApi idToken before app was loaded");
    }
    return (_a = this.idTokenFunc) == null ? void 0 : _a.call(this);
  }
  async signOut() {
    var _a;
    if (!this.hasIdentity) {
      throw new Error("Tried to access IdentityApi signOutFunc before app was loaded");
    }
    await ((_a = this.signOutFunc) == null ? void 0 : _a.call(this));
    location.reload();
  }
  setSignInResult(result) {
    if (this.hasIdentity) {
      return;
    }
    if (!result.userId) {
      throw new Error("Invalid sign-in result, userId not set");
    }
    if (!result.profile) {
      throw new Error("Invalid sign-in result, profile not set");
    }
    this.hasIdentity = true;
    this.userId = result.userId;
    this.profile = result.profile;
    this.idTokenFunc = result.getIdToken;
    this.signOutFunc = result.signOut;
  }
}

function resolveTheme(themeId, shouldPreferDark, themes) {
  if (themeId !== void 0) {
    const selectedTheme = themes.find((theme) => theme.id === themeId);
    if (selectedTheme) {
      return selectedTheme;
    }
  }
  if (shouldPreferDark) {
    const darkTheme = themes.find((theme) => theme.variant === "dark");
    if (darkTheme) {
      return darkTheme;
    }
  }
  const lightTheme = themes.find((theme) => theme.variant === "light");
  if (lightTheme) {
    return lightTheme;
  }
  return themes[0];
}
const useShouldPreferDarkTheme = () => {
  const mediaQuery = useMemo(() => window.matchMedia("(prefers-color-scheme: dark)"), []);
  const [shouldPreferDark, setPrefersDark] = useState(mediaQuery.matches);
  useEffect(() => {
    const listener = (event) => {
      setPrefersDark(event.matches);
    };
    mediaQuery.addListener(listener);
    return () => {
      mediaQuery.removeListener(listener);
    };
  }, [mediaQuery]);
  return shouldPreferDark;
};
function AppThemeProvider({children}) {
  const appThemeApi = useApi(appThemeApiRef);
  const themeId = useObservable(appThemeApi.activeThemeId$(), appThemeApi.getActiveThemeId());
  const shouldPreferDark = Boolean(window.matchMedia) ? useShouldPreferDarkTheme() : false;
  const appTheme = resolveTheme(themeId, shouldPreferDark, appThemeApi.getInstalledThemes());
  if (!appTheme) {
    throw new Error("App has no themes");
  }
  return /* @__PURE__ */ React.createElement(ThemeProvider, {
    theme: appTheme.theme
  }, /* @__PURE__ */ React.createElement(CssBaseline, null, children));
}

function generateBoundRoutes(bindRoutes) {
  const result = new Map();
  if (bindRoutes) {
    const bind = (externalRoutes, targetRoutes) => {
      for (const [key, value] of Object.entries(targetRoutes)) {
        const externalRoute = externalRoutes[key];
        if (!externalRoute) {
          throw new Error(`Key ${key} is not an existing external route`);
        }
        if (!value && !externalRoute.optional) {
          throw new Error(`External route ${key} is required but was undefined`);
        }
        if (value) {
          result.set(externalRoute, value);
        }
      }
    };
    bindRoutes({bind});
  }
  return result;
}
function useConfigLoader(configLoader, components, appThemeApi) {
  var _a;
  const hasConfig = Boolean(configLoader);
  const config = useAsync(configLoader || (() => Promise.resolve([])));
  let noConfigNode = void 0;
  if (hasConfig && config.loading) {
    const {Progress} = components;
    noConfigNode = /* @__PURE__ */ React.createElement(Progress, null);
  } else if (config.error) {
    const {BootErrorPage} = components;
    noConfigNode = /* @__PURE__ */ React.createElement(BootErrorPage, {
      step: "load-config",
      error: config.error
    });
  }
  if (noConfigNode) {
    return {
      node: /* @__PURE__ */ React.createElement(ApiProvider, {
        apis: ApiRegistry.from([[appThemeApiRef, appThemeApi]])
      }, /* @__PURE__ */ React.createElement(AppThemeProvider, null, noConfigNode))
    };
  }
  const configReader = ConfigReader.fromConfigs((_a = config.value) != null ? _a : []);
  return {api: configReader};
}
class AppContextImpl {
  constructor(app) {
    this.app = app;
  }
  getPlugins() {
    console.warn("appContext.getPlugins() is deprecated and will be removed");
    return this.app.getPlugins();
  }
  getSystemIcon(key) {
    return this.app.getSystemIcon(key);
  }
  getComponents() {
    return this.app.getComponents();
  }
  getProvider() {
    console.warn("appContext.getProvider() is deprecated and will be removed");
    return this.app.getProvider();
  }
  getRouter() {
    console.warn("appContext.getRouter() is deprecated and will be removed");
    return this.app.getRouter();
  }
  getRoutes() {
    console.warn("appContext.getRoutes() is deprecated and will be removed");
    return this.app.getRoutes();
  }
}
class PrivateAppImpl {
  constructor(options) {
    this.identityApi = new AppIdentity();
    this.apis = options.apis;
    this.icons = options.icons;
    this.plugins = new Set(options.plugins);
    this.components = options.components;
    this.themes = options.themes;
    this.configLoader = options.configLoader;
    this.defaultApis = options.defaultApis;
    this.bindRoutes = options.bindRoutes;
  }
  getPlugins() {
    return Array.from(this.plugins);
  }
  getSystemIcon(key) {
    return this.icons[key];
  }
  getComponents() {
    return this.components;
  }
  getRoutes() {
    const routes = new Array();
    const {NotFoundErrorPage} = this.components;
    for (const plugin of this.plugins.values()) {
      for (const output of plugin.output()) {
        switch (output.type) {
          case "legacy-route": {
            const {path, component: Component} = output;
            routes.push(/* @__PURE__ */ React.createElement(Route, {
              key: path,
              path,
              element: /* @__PURE__ */ React.createElement(Component, null)
            }));
            break;
          }
          case "route": {
            const {target, component: Component} = output;
            routes.push(/* @__PURE__ */ React.createElement(Route, {
              key: `${plugin.getId()}-${target.path}`,
              path: target.path,
              element: /* @__PURE__ */ React.createElement(Component, null)
            }));
            break;
          }
          case "legacy-redirect-route": {
            const {path, target} = output;
            routes.push(/* @__PURE__ */ React.createElement(Navigate, {
              key: path,
              to: target
            }));
            break;
          }
          case "redirect-route": {
            const {from, to} = output;
            routes.push(/* @__PURE__ */ React.createElement(Navigate, {
              key: from.path,
              to: to.path
            }));
            break;
          }
        }
      }
    }
    routes.push(/* @__PURE__ */ React.createElement(Route, {
      key: "not-found-error-page",
      path: "/*",
      element: /* @__PURE__ */ React.createElement(NotFoundErrorPage, null)
    }));
    return routes;
  }
  getProvider() {
    const appContext = new AppContextImpl(this);
    const Provider = ({children}) => {
      const appThemeApi = useMemo(() => AppThemeSelector.createWithStorage(this.themes), []);
      const {routePaths, routeParents, routeObjects} = useMemo(() => {
        const result = traverseElementTree({
          root: children,
          discoverers: [childDiscoverer, routeElementDiscoverer],
          collectors: {
            routePaths: routePathCollector,
            routeParents: routeParentCollector,
            routeObjects: routeObjectCollector,
            collectedPlugins: pluginCollector
          }
        });
        validateRoutes(result.routePaths, result.routeParents);
        result.collectedPlugins.forEach((plugin) => this.plugins.add(plugin));
        this.verifyPlugins(this.plugins);
        this.getApiHolder();
        return result;
      }, [children]);
      const loadedConfig = useConfigLoader(this.configLoader, this.components, appThemeApi);
      const hasConfigApi = "api" in loadedConfig;
      if (hasConfigApi) {
        const {api} = loadedConfig;
        this.configApi = api;
      }
      useEffect(() => {
        if (hasConfigApi) {
          const featureFlagsApi = this.getApiHolder().get(featureFlagsApiRef);
          for (const plugin of this.plugins.values()) {
            for (const output of plugin.output()) {
              switch (output.type) {
                case "feature-flag": {
                  featureFlagsApi.registerFlag({
                    name: output.name,
                    pluginId: plugin.getId()
                  });
                  break;
                }
              }
            }
          }
        }
      }, [hasConfigApi, loadedConfig]);
      if ("node" in loadedConfig) {
        return loadedConfig.node;
      }
      return /* @__PURE__ */ React.createElement(ApiProvider, {
        apis: this.getApiHolder()
      }, /* @__PURE__ */ React.createElement(AppContextProvider, {
        appContext
      }, /* @__PURE__ */ React.createElement(AppThemeProvider, null, /* @__PURE__ */ React.createElement(RoutingProvider, {
        routePaths,
        routeParents,
        routeObjects,
        routeBindings: generateBoundRoutes(this.bindRoutes)
      }, children))));
    };
    return Provider;
  }
  getRouter() {
    const {
      Router: RouterComponent,
      SignInPage: SignInPageComponent
    } = this.components;
    const SignInPageWrapper = ({
      component: Component,
      children
    }) => {
      const [result, setResult] = useState();
      if (result) {
        this.identityApi.setSignInResult(result);
        return children;
      }
      return /* @__PURE__ */ React.createElement(Component, {
        onResult: setResult
      });
    };
    const AppRouter = ({children}) => {
      var _a;
      const configApi = useApi(configApiRef);
      let {pathname} = new URL((_a = configApi.getOptionalString("app.baseUrl")) != null ? _a : "/", "http://dummy.dev");
      if (pathname.endsWith("/")) {
        pathname = pathname.replace(/\/$/, "");
      }
      if (!SignInPageComponent) {
        this.identityApi.setSignInResult({
          userId: "guest",
          profile: {
            email: "guest@example.com",
            displayName: "Guest"
          }
        });
        return /* @__PURE__ */ React.createElement(RouterComponent, null, /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
          path: `${pathname}/*`,
          element: /* @__PURE__ */ React.createElement(React.Fragment, null, children)
        })));
      }
      return /* @__PURE__ */ React.createElement(RouterComponent, null, /* @__PURE__ */ React.createElement(SignInPageWrapper, {
        component: SignInPageComponent
      }, /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
        path: `${pathname}/*`,
        element: /* @__PURE__ */ React.createElement(React.Fragment, null, children)
      }))));
    };
    return AppRouter;
  }
  getApiHolder() {
    if (this.apiHolder) {
      return this.apiHolder;
    }
    const registry = new ApiFactoryRegistry();
    registry.register("static", {
      api: appThemeApiRef,
      deps: {},
      factory: () => AppThemeSelector.createWithStorage(this.themes)
    });
    registry.register("static", {
      api: configApiRef,
      deps: {},
      factory: () => {
        if (!this.configApi) {
          throw new Error("Tried to access config API before config was loaded");
        }
        return this.configApi;
      }
    });
    registry.register("static", {
      api: identityApiRef,
      deps: {},
      factory: () => this.identityApi
    });
    registry.register("default", {
      api: featureFlagsApiRef,
      deps: {},
      factory: () => new LocalStorageFeatureFlags()
    });
    for (const factory of this.defaultApis) {
      registry.register("default", factory);
    }
    for (const plugin of this.plugins) {
      for (const factory of plugin.getApis()) {
        if (!registry.register("default", factory)) {
          throw new Error(`Plugin ${plugin.getId()} tried to register duplicate or forbidden API factory for ${factory.api}`);
        }
      }
    }
    for (const factory of this.apis) {
      if (!registry.register("app", factory)) {
        throw new Error(`Duplicate or forbidden API factory for ${factory.api} in app`);
      }
    }
    ApiResolver.validateFactories(registry, registry.getAllApis());
    this.apiHolder = new ApiResolver(registry);
    return this.apiHolder;
  }
  verify() {
  }
  verifyPlugins(plugins) {
    const pluginIds = new Set();
    for (const plugin of plugins) {
      const id = plugin.getId();
      if (pluginIds.has(id)) {
        throw new Error(`Duplicate plugin found '${id}'`);
      }
      pluginIds.add(id);
    }
  }
}

var privateExports = /*#__PURE__*/Object.freeze({
  __proto__: null,
  PrivateAppImpl: PrivateAppImpl
});

export default privateExports;
export { AlertApiForwarder, ApiFactoryRegistry, ApiProvider, ApiRegistry, ApiResolver, AppThemeSelector, Auth0Auth, BrokenImageIcon, ChatIcon, DashboardIcon, DocsIcon, EmailIcon, ErrorAlerter, ErrorApiForwarder, FeatureFlagState, FlatRoutes, GitHubIcon, GithubAuth, GitlabAuth, GoogleAuth, GroupIcon, HelpIcon, LocalStorageFeatureFlags, MicrosoftAuth, OAuth2, OAuthRequestManager, OktaAuth, OneLoginAuth, SamlAuth, SessionState, UrlPatternDiscovery, UserIcon, WarningIcon, WebStorage, alertApiRef, appThemeApiRef, attachComponentData, auth0AuthApiRef, configApiRef, createApiFactory, createApiRef, createComponentExtension, createExternalRouteRef, createPlugin, createReactExtension, createRoutableExtension, createRouteRef, createSubRouteRef, defaultSystemIcons, discoveryApiRef, errorApiRef, featureFlagsApiRef, getComponentData, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauth2ApiRef, oauthRequestApiRef, oidcAuthApiRef, oktaAuthApiRef, oneloginAuthApiRef, samlAuthApiRef, storageApiRef, useApi, useApiHolder, useApp, useRouteRef, useRouteRefParams };
//# sourceMappingURL=index.esm.js.map
