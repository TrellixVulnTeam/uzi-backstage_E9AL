import { Logger } from 'winston';
import { IndexableDocument, SearchQuery, SearchResultSet, DocumentCollator, DocumentDecorator } from '@backstage/search-common';
import lunr from 'lunr';

/**
 * Parameters required to register a collator.
 */
interface RegisterCollatorParameters {
    /**
     * The type of document to be indexed (used to name indices, to configure refresh loop, etc).
     */
    type: string;
    /**
     * The default interval (in seconds) that the provided collator will be called (can be overridden in config).
     */
    defaultRefreshIntervalSeconds: number;
    /**
     * The collator class responsible for returning all documents of the given type.
     */
    collator: DocumentCollator;
}
/**
 * Parameters required to register a decorator
 */
interface RegisterDecoratorParameters {
    /**
     * The decorator class responsible for appending or modifying documents of the given type(s).
     */
    decorator: DocumentDecorator;
    /**
     * (Optional) An array of document types that the given decorator should apply to. If none are provided,
     * the decorator will be applied to all types.
     */
    types?: string[];
}
/**
 * A type of function responsible for translating an abstract search query into
 * a concrete query relevant to a particular search engine.
 */
declare type QueryTranslator = (query: SearchQuery) => unknown;
/**
 * Interface that must be implemented by specific search engines, responsible
 * for performing indexing and querying and translating abstract queries into
 * concrete, search engine-specific queries.
 */
interface SearchEngine {
    translator: QueryTranslator;
    index(type: string, documents: IndexableDocument[]): void;
    query(query: SearchQuery): Promise<SearchResultSet>;
}

declare type IndexBuilderOptions = {
    searchEngine: SearchEngine;
    logger: Logger;
};
declare class IndexBuilder {
    private collators;
    private decorators;
    private searchEngine;
    private logger;
    constructor({ logger, searchEngine }: IndexBuilderOptions);
    getSearchEngine(): SearchEngine;
    /**
     * Makes the index builder aware of a collator that should be executed at the
     * given refresh interval.
     */
    addCollator({ type, collator, defaultRefreshIntervalSeconds, }: RegisterCollatorParameters): void;
    /**
     * Makes the index builder aware of a decorator. If no types are provided, it
     * will be applied to documents from all known collators, otherwise it will
     * only be applied to documents of the given types.
     */
    addDecorator({ types, decorator, }: RegisterDecoratorParameters): void;
    /**
     * Compiles collators and decorators into tasks, which are added to a
     * scheduler returned to the caller.
     */
    build(): Promise<{
        scheduler: Scheduler;
    }>;
}

/**
 * TODO: coordination, error handling
 */
declare class Scheduler {
    private logger;
    private schedule;
    private intervalTimeouts;
    constructor({ logger }: {
        logger: Logger;
    });
    /**
     * Adds each task and interval to the schedule
     *
     */
    addToSchedule(task: Function, interval: number): void;
    /**
     * Starts the scheduling process for each task
     */
    start(): void;
    /**
     * Stop all scheduled tasks.
     */
    stop(): void;
}

declare class LunrSearchEngine implements SearchEngine {
    protected lunrIndices: Record<string, lunr.Index>;
    protected docStore: Record<string, IndexableDocument>;
    protected logger: Logger;
    constructor({ logger }: {
        logger: Logger;
    });
    translator: QueryTranslator;
    index(type: string, documents: IndexableDocument[]): void;
    query(query: SearchQuery): Promise<SearchResultSet>;
}

export { IndexBuilder, LunrSearchEngine, Scheduler, SearchEngine };
