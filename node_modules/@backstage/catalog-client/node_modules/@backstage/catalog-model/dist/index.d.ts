import { JsonValue, JsonObject } from '@backstage/config';
import { JSONSchema7 } from 'json-schema';
import { SerializedError } from '@backstage/errors';
import { ObjectSchema } from 'yup';

/**
 * The namespace that entities without an explicit namespace fall into.
 */
declare const ENTITY_DEFAULT_NAMESPACE = "default";
/**
 * The keys of EntityMeta that are auto-generated.
 */
declare const ENTITY_META_GENERATED_FIELDS: readonly ["uid", "etag", "generation"];
/**
 * Annotations for linking to entity from catalog pages.
 */
declare const VIEW_URL_ANNOTATION = "backstage.io/view-url";
declare const EDIT_URL_ANNOTATION = "backstage.io/edit-url";

declare type JSONSchema = JSONSchema7 & {
    [key in string]?: JsonValue;
};
/**
 * A complete entity name, with the full kind-namespace-name triplet.
 */
declare type EntityName = {
    kind: string;
    namespace: string;
    name: string;
};
/**
 * A reference by name to an entity, either as a compact string representation,
 * or as a compound reference structure.
 *
 * The string representation is on the form [<kind>:][<namespace>/]<name>.
 *
 * Left-out parts of the reference need to be handled by the application,
 * either by rejecting the reference or by falling back to default values.
 */
declare type EntityRef = string | {
    kind?: string;
    namespace?: string;
    name: string;
};

/**
 * The envelope skeleton parts of an entity - whatever is necessary to be able
 * to give it a ref and pass to further validation / policy checking.
 *
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/
 */
declare type EntityEnvelope = {
    /**
     * The version of specification format for this particular entity that
     * this is written against.
     */
    apiVersion: string;
    /**
     * The high level entity type being described.
     */
    kind: string;
    /**
     * Metadata related to the entity.
     */
    metadata: {
        /**
         * The name of the entity.
         *
         * Must be unique within the catalog at any given point in time, for any
         * given namespace + kind pair.
         */
        name: string;
        /**
         * The namespace that the entity belongs to.
         */
        namespace?: string;
    };
};

/**
 * The current status of the entity, as claimed by various sources.
 * @alpha
 */
declare type UNSTABLE_EntityStatus = {
    /**
     * Specific status item on a well known format.
     */
    items?: UNSTABLE_EntityStatusItem[];
};
/**
 * A specific status item on a well known format.
 * @alpha
 */
declare type UNSTABLE_EntityStatusItem = {
    /**
     * The type of status as a unique key per source.
     */
    type: string;
    /**
     * The level / severity of the status item. If the level is "error", the
     * processing of the entity may be entirely blocked. In this case the status
     * entry may apply to a different, newer version of the data than what is
     * being returned in the catalog response.
     */
    level: UNSTABLE_EntityStatusLevel;
    /**
     * A brief message describing the status, intended for human consumption.
     */
    message: string;
    /**
     * An optional serialized error object related to the status.
     */
    error?: SerializedError;
};
/**
 * Each entity status item has a level, describing its severity.
 * @alpha
 */
declare type UNSTABLE_EntityStatusLevel = 'info' | 'warning' | 'error';

/**
 * The parts of the format that's common to all versions/kinds of entity.
 *
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/
 */
declare type Entity = EntityEnvelope & {
    /**
     * The version of specification format for this particular entity that
     * this is written against.
     */
    apiVersion: string;
    /**
     * The high level entity type being described.
     */
    kind: string;
    /**
     * Metadata related to the entity.
     */
    metadata: EntityMeta;
    /**
     * The specification data describing the entity itself.
     */
    spec?: JsonObject;
    /**
     * The relations that this entity has with other entities.
     */
    relations?: EntityRelation[];
    /**
     * The current status of the entity, as claimed by various sources.
     *
     * The keys are implementation defined and the values can be any JSON object
     * with semantics that match that implementation.
     */
    status?: UNSTABLE_EntityStatus;
};
/**
 * Metadata fields common to all versions/kinds of entity.
 *
 * @see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#objectmeta-v1-meta
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/
 */
declare type EntityMeta = JsonObject & {
    /**
     * A globally unique ID for the entity.
     *
     * This field can not be set by the user at creation time, and the server
     * will reject an attempt to do so. The field will be populated in read
     * operations. The field can (optionally) be specified when performing
     * update or delete operations, but the server is free to reject requests
     * that do so in such a way that it breaks semantics.
     */
    uid?: string;
    /**
     * An opaque string that changes for each update operation to any part of
     * the entity, including metadata.
     *
     * This field can not be set by the user at creation time, and the server
     * will reject an attempt to do so. The field will be populated in read
     * operations. The field can (optionally) be specified when performing
     * update or delete operations, and the server will then reject the
     * operation if it does not match the current stored value.
     */
    etag?: string;
    /**
     * A positive nonzero number that indicates the current generation of data
     * for this entity; the value is incremented each time the spec changes.
     *
     * This field can not be set by the user at creation time, and the server
     * will reject an attempt to do so. The field will be populated in read
     * operations.
     */
    generation?: number;
    /**
     * The name of the entity.
     *
     * Must be unique within the catalog at any given point in time, for any
     * given namespace + kind pair.
     */
    name: string;
    /**
     * The namespace that the entity belongs to.
     */
    namespace?: string;
    /**
     * A short (typically relatively few words, on one line) description of the
     * entity.
     */
    description?: string;
    /**
     * Key/value pairs of identifying information attached to the entity.
     */
    labels?: Record<string, string>;
    /**
     * Key/value pairs of non-identifying auxiliary information attached to the
     * entity.
     */
    annotations?: Record<string, string>;
    /**
     * A list of single-valued strings, to for example classify catalog entities in
     * various ways.
     */
    tags?: string[];
    /**
     * A list of external hyperlinks related to the entity.
     */
    links?: EntityLink[];
};
/**
 * A relation of a specific type to another entity in the catalog.
 */
declare type EntityRelation = {
    /**
     * The type of the relation.
     */
    type: string;
    /**
     * The target entity of this relation.
     */
    target: EntityName;
};
/**
 * Holds the relation data for entities.
 */
declare type EntityRelationSpec = {
    /**
     * The source entity of this relation.
     */
    source: EntityName;
    /**
     * The type of the relation.
     */
    type: string;
    /**
     * The target entity of this relation.
     */
    target: EntityName;
};
/**
 * A link to external information that is related to the entity.
 */
declare type EntityLink = {
    /**
     * The url to the external site, document, etc.
     */
    url: string;
    /**
     * An optional descriptive title for the link.
     */
    title?: string;
    /**
     * An optional semantic key that represents a visual icon.
     */
    icon?: string;
};

/**
 * A policy for validation or mutation to be applied to entities as they are
 * entering the system.
 */
declare type EntityPolicy = {
    /**
     * Applies validation or mutation on an entity.
     *
     * @param entity The entity, as validated/mutated so far in the policy tree
     * @returns The incoming entity, or a mutated version of the same, or
     *          undefined if this processor could not handle the entity
     * @throws An error if the entity should be rejected
     */
    enforce(entity: Entity): Promise<Entity | undefined>;
};

/**
 * Sets a default namespace if none was set.
 */
declare class DefaultNamespaceEntityPolicy implements EntityPolicy {
    private readonly namespace;
    constructor(namespace?: string);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Contains various helper validation and normalization functions that can be
 * composed to form a Validator.
 */
declare class CommonValidatorFunctions {
    /**
     * Checks that the value is on the form <suffix> or <prefix><separator><suffix>, and validates
     * those parts separately.
     *
     * @param value The value to check
     * @param separator The separator between parts
     * @param isValidPrefix Checks that the part before the separator is valid, if present
     * @param isValidSuffix Checks that the part after the separator (or the entire value if there is no separator) is valid
     */
    static isValidPrefixAndOrSuffix(value: unknown, separator: string, isValidPrefix: (value: string) => boolean, isValidSuffix: (value: string) => boolean): boolean;
    /**
     * Checks that the value can be safely transferred as JSON.
     *
     * @param value The value to check
     */
    static isJsonSafe(value: unknown): boolean;
    /**
     * Checks that the value is a valid DNS subdomain name.
     *
     * @param value The value to check
     * @see https://tools.ietf.org/html/rfc1123
     */
    static isValidDnsSubdomain(value: unknown): boolean;
    /**
     * Checks that the value is a valid DNS label.
     *
     * @param value The value to check
     * @see https://tools.ietf.org/html/rfc1123
     */
    static isValidDnsLabel(value: unknown): boolean;
    /**
     * Checks that the value is a valid URL.
     *
     * @param value The value to check
     */
    static isValidUrl(value: unknown): boolean;
    /**
     * Checks that the value is a non empty string value.
     *
     * @param value The value to check
     */
    static isValidString(value: unknown): boolean;
}

/**
 * Creates a validation function that takes some arbitrary data, and either
 * returns that data cast to an {@link EntityEnvelope} (or the given subtype)
 * if it matches that schema, or throws a {@link TypeError} describing the
 * errors.
 *
 * Note that this validator is only meant for applying the base schema checks;
 * it does not take custom policies or additional processor based validation
 * into account.
 *
 * By default, the plain `EntityEnvelope` schema is used. If you pass in your
 * own, it may contain `$ref` references to the following, which are resolved
 * automatically for you:
 *
 * - EntityEnvelope
 * - Entity
 * - EntityMeta
 * - common#<id>
 *
 * @see https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema
 */
declare function entityEnvelopeSchemaValidator<T extends EntityEnvelope = EntityEnvelope>(schema?: unknown): (data: unknown) => T;

/**
 * Creates a validation function that takes some arbitrary data, and either
 * returns that data cast to a `T` if it matches that schema, or `false` if the
 * schema apiVersion/kind didn't apply to that data, or throws a
 * {@link TypeError} describing actual errors.
 *
 * This validator is highly specialized, in that it has special treatment of
 * the `kind` and `apiVersion` root keys. This only works if your schema has
 * their rule set to `"enum"`:
 *
 * <pre>
 *   "apiVersion": {
 *      "enum": ["backstage.io/v1alpha1", "backstage.io/v1beta1"]
 *   },
 *   "kind": {
 *     "enum": ["Group"]
 *   },
 * </pre>
 *
 * In the above example, the created validator will return `false` if and only
 * if the kind and/or apiVersion mismatch.
 *
 * Note that this validator is only meant for applying the base schema checks;
 * it does not take custom policies or additional processor based validation
 * into account.
 *
 * The given schema may contain `$ref` references to the following, which are
 * resolved automatically for you:
 *
 * - EntityEnvelope
 * - Entity
 * - EntityMeta
 * - common#<id>
 *
 * @see https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema
 */
declare function entityKindSchemaValidator<T extends Entity>(schema: unknown): (data: unknown) => T | false;

/**
 * Creates a validation function that takes some arbitrary data, and either
 * returns that data cast to an {@link Entity} (or the given subtype) if it
 * matches that schema, or throws a {@link TypeError} describing the errors.
 *
 * Note that this validator is only meant for applying the base schema checks;
 * it does not take custom policies or additional processor based validation
 * into account.
 *
 * By default, the plain `Entity` schema is used. If you pass in your own, it
 * may contain `$ref` references to the following, which are resolved
 * automatically for you:
 *
 * - EntityEnvelope
 * - Entity
 * - EntityMeta
 * - common#<id>
 *
 * @see https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema
 */
declare function entitySchemaValidator<T extends Entity = Entity>(schema?: unknown): (data: unknown) => T;

/**
 * Contains validation functions that match the Kubernetes spec, usable to
 * build a catalog that is compatible with those rule sets.
 *
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/names/
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
 * @see https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
 */
declare class KubernetesValidatorFunctions {
    static isValidApiVersion(value: unknown): boolean;
    static isValidKind(value: unknown): boolean;
    static isValidObjectName(value: unknown): boolean;
    static isValidNamespace(value: unknown): boolean;
    static isValidLabelKey(value: unknown): boolean;
    static isValidLabelValue(value: unknown): boolean;
    static isValidAnnotationKey(value: unknown): boolean;
    static isValidAnnotationValue(value: unknown): boolean;
}

declare type Validators = {
    isValidApiVersion(value: unknown): boolean;
    isValidKind(value: unknown): boolean;
    isValidEntityName(value: unknown): boolean;
    isValidNamespace(value: unknown): boolean;
    isValidLabelKey(value: unknown): boolean;
    isValidLabelValue(value: unknown): boolean;
    isValidAnnotationKey(value: unknown): boolean;
    isValidAnnotationValue(value: unknown): boolean;
    isValidTag(value: unknown): boolean;
};

declare function makeValidator(overrides?: Partial<Validators>): Validators;

/**
 * Ensures that the format of individual fields of the entity envelope
 * is valid.
 *
 * This does not take into account machine generated fields such as uid, etag
 * and generation.
 */
declare class FieldFormatEntityPolicy implements EntityPolicy {
    private readonly validators;
    constructor(validators?: Validators);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Ensures that there are no foreign root fields in the entity.
 */
declare class NoForeignRootFieldsEntityPolicy implements EntityPolicy {
    private readonly knownFields;
    constructor(knownFields?: string[]);
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Ensures that the entity spec is valid according to a schema.
 *
 * This should be the first policy in the list, to ensure that other downstream
 * policies can work with a structure that is at least valid in therms of the
 * typescript type.
 */
declare class SchemaValidEntityPolicy implements EntityPolicy {
    private validate;
    enforce(entity: Entity): Promise<Entity>;
}

/**
 * Extracts the kind, namespace and name that form the name triplet of the
 * given entity.
 *
 * @param entity An entity
 * @returns The complete entity name
 */
declare function getEntityName(entity: Entity): EntityName;
/**
 * The context of defaults that entity reference parsing happens within.
 */
declare type EntityRefContext = {
    /** The default kind, if none is given in the reference */
    defaultKind?: string;
    /** The default namespace, if none is given in the reference */
    defaultNamespace?: string;
};
/**
 * Parses an entity reference, either on string or compound form, and always
 * returns a complete entity name including kind, namespace and name.
 *
 * This function automatically assumes the default namespace "default" unless
 * otherwise specified as part of the options, and will throw an error if no
 * kind was specified in the input reference and no default kind was given.
 *
 * @param ref The reference to parse
 * @param context The context of defaults that the parsing happens within
 * @returns A complete entity name
 */
declare function parseEntityName(ref: EntityRef, context?: EntityRefContext): EntityName;
/**
 * Parses an entity reference, either on string or compound form, and returns
 * a structure with a name, and optional kind and namespace.
 *
 * The options object can contain default values for the kind and namespace,
 * that will be used if the input reference did not specify any.
 *
 * @param ref The reference to parse
 * @param context The context of defaults that the parsing happens within
 * @returns The compound form of the reference
 */
declare function parseEntityRef(ref: EntityRef, context?: {
    defaultKind: string;
    defaultNamespace: string;
}): {
    kind: string;
    namespace: string;
    name: string;
};
declare function parseEntityRef(ref: EntityRef, context?: {
    defaultKind: string;
}): {
    kind: string;
    namespace?: string;
    name: string;
};
declare function parseEntityRef(ref: EntityRef, context?: {
    defaultNamespace: string;
}): {
    kind?: string;
    namespace: string;
    name: string;
};
/**
 * Takes an entity reference or name, and outputs an entity reference on the
 * most compact form possible. I.e. if the parts do not contain any
 * special/reserved characters, it outputs the string form, otherwise it
 * outputs the compound form.
 *
 * @deprecated Use `stringifyEntityRef` instead
 * @param ref The reference to serialize
 * @returns The same reference on either string or compound form
 */
declare function serializeEntityRef(ref: Entity | {
    kind?: string;
    namespace?: string;
    name: string;
}): EntityRef;
/**
 * Takes an entity or entity name/reference, and returns the string form of an
 * entity ref.
 *
 * This function creates a canonical and unique reference to the entity, converting
 * all parts of the name to lowercase and inserts the default namespace if needed.
 * It is typically not the best way to represent the entity reference to the user.
 *
 * @param ref The reference to serialize
 * @returns The same reference on either string or compound form
 */
declare function stringifyEntityRef(ref: Entity | {
    kind: string;
    namespace?: string;
    name: string;
}): string;
/**
 * Compares an entity to either a string reference or a compound reference.
 *
 * The comparison is case insensitive, and all of kind, namespace, and name
 * must match (after applying the optional context to the ref).
 *
 * @param entity The entity to match
 * @param ref A string or compound entity ref
 * @param context An optional context of default kind and namespace, that apply
 *                to the ref if given
 * @returns True if matching, false otherwise
 */
declare function compareEntityToRef(entity: Entity, ref: EntityRef | EntityName, context?: EntityRefContext): boolean;

/**
 * Generates a new random UID for an entity.
 *
 * @returns A string with enough randomness to uniquely identify an entity
 */
declare function generateEntityUid(): string;
/**
 * Generates a new random Etag for an entity.
 *
 * @returns A string with enough randomness to uniquely identify an entity
 *          revision
 */
declare function generateEntityEtag(): string;
/**
 * Checks whether there are any significant changes going from the previous to
 * the next version of this entity.
 *
 * Significance, in this case, means that we do not compare generated fields
 * such as uid, etag and generation.
 *
 * Note that this comparison does NOT take status, relations or similar into
 * account. It only compares the actual input entity data, i.e. metadata and
 * spec.
 *
 * @param previous The old state of the entity
 * @param next The new state of the entity
 */
declare function entityHasChanges(previous: Entity, next: Entity): boolean;
/**
 * Takes an old revision of an entity and a new desired state, and merges
 * them into a complete new state.
 *
 * The previous revision is expected to be a complete model loaded from the
 * catalog, including the uid, etag and generation fields.
 *
 * @param previous The old state of the entity
 * @param next The new state of the entity
 * @returns An entity with the merged state of both
 */
declare function generateUpdatedEntity(previous: Entity, next: Entity): Entity;

declare class AllEntityPolicies implements EntityPolicy {
    private readonly policies;
    constructor(policies: EntityPolicy[]);
    enforce(entity: Entity): Promise<Entity>;
}
declare class AnyEntityPolicy implements EntityPolicy {
    private readonly policies;
    constructor(policies: EntityPolicy[]);
    enforce(entity: Entity): Promise<Entity>;
}
declare const EntityPolicies: {
    allOf(policies: EntityPolicy[]): AllEntityPolicies;
    oneOf(policies: EntityPolicy[]): AnyEntityPolicy;
};

/**
 * Validates entities of a certain kind.
 */
declare type KindValidator = {
    /**
     * Validates the entity as a known entity kind.
     *
     * @param entity The entity to validate
     * @returns Resolves to true, if the entity was of a kind that was known and
     *   handled by this validator, and was found to be valid. Resolves to false,
     *   if the entity was not of a kind that was known by this validator.
     *   Rejects to an Error describing the problem, if the entity was of a kind
     *   that was known by this validator and was not valid.
     */
    check(entity: Entity): Promise<boolean>;
};

interface ApiEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'API';
    spec: {
        type: string;
        lifecycle: string;
        owner: string;
        definition: string;
        system?: string;
    };
}
declare const apiEntityV1alpha1Validator: KindValidator;

interface ComponentEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Component';
    spec: {
        type: string;
        lifecycle: string;
        owner: string;
        subcomponentOf?: string;
        providesApis?: string[];
        consumesApis?: string[];
        dependsOn?: string[];
        system?: string;
    };
}
declare const componentEntityV1alpha1Validator: KindValidator;

interface DomainEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Domain';
    spec: {
        owner: string;
    };
}
declare const domainEntityV1alpha1Validator: KindValidator;

interface GroupEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Group';
    spec: {
        type: string;
        profile?: {
            displayName?: string;
            email?: string;
            picture?: string;
        };
        parent?: string;
        children: string[];
        members?: string[];
    };
}
declare const groupEntityV1alpha1Validator: KindValidator;

interface LocationEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Location';
    spec: {
        type?: string;
        target?: string;
        targets?: string[];
    };
}
declare const locationEntityV1alpha1Validator: KindValidator;

/**
 * An ownership relation where the owner is usually an organizational
 * entity (user or group), and the other entity can be anything.
 */
declare const RELATION_OWNED_BY = "ownedBy";
declare const RELATION_OWNER_OF = "ownerOf";
/**
 * A relation with an API entity, typically from a component
 */
declare const RELATION_CONSUMES_API = "consumesApi";
declare const RELATION_API_CONSUMED_BY = "apiConsumedBy";
declare const RELATION_PROVIDES_API = "providesApi";
declare const RELATION_API_PROVIDED_BY = "apiProvidedBy";
/**
 * A relation denoting a dependency on another entity.
 */
declare const RELATION_DEPENDS_ON = "dependsOn";
declare const RELATION_DEPENDENCY_OF = "dependencyOf";
/**
 * A parent/child relation to build up a tree, used for example to describe
 * the organizational structure between groups.
 */
declare const RELATION_PARENT_OF = "parentOf";
declare const RELATION_CHILD_OF = "childOf";
/**
 * A membership relation, typically for users in a group.
 */
declare const RELATION_MEMBER_OF = "memberOf";
declare const RELATION_HAS_MEMBER = "hasMember";
/**
 * A part/whole relation, typically for components in a system and systems
 * in a domain.
 */
declare const RELATION_PART_OF = "partOf";
declare const RELATION_HAS_PART = "hasPart";

interface ResourceEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Resource';
    spec: {
        type: string;
        owner: string;
        dependsOn?: string[];
        system?: string;
    };
}
declare const resourceEntityV1alpha1Validator: KindValidator;

interface SystemEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'System';
    spec: {
        owner: string;
        domain?: string;
    };
}
declare const systemEntityV1alpha1Validator: KindValidator;

interface TemplateEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'Template';
    spec: {
        type: string;
        templater: string;
        path?: string;
        schema: JSONSchema;
        owner?: string;
    };
}
declare const templateEntityV1alpha1Validator: KindValidator;

interface TemplateEntityV1beta2 extends Entity {
    apiVersion: 'backstage.io/v1beta2';
    kind: 'Template';
    metadata: EntityMeta & {
        title?: string;
    };
    spec: {
        type: string;
        parameters?: JsonObject | JsonObject[];
        steps: Array<{
            id?: string;
            name?: string;
            action: string;
            input?: JsonObject;
        }>;
        output?: {
            [name: string]: string;
        };
        owner?: string;
    };
}
declare const templateEntityV1beta2Validator: KindValidator;

interface UserEntityV1alpha1 extends Entity {
    apiVersion: 'backstage.io/v1alpha1' | 'backstage.io/v1beta1';
    kind: 'User';
    spec: {
        profile?: {
            displayName?: string;
            email?: string;
            picture?: string;
        };
        memberOf: string[];
    };
}
declare const userEntityV1alpha1Validator: KindValidator;

declare const LOCATION_ANNOTATION = "backstage.io/managed-by-location";
declare const ORIGIN_LOCATION_ANNOTATION = "backstage.io/managed-by-origin-location";
declare const SOURCE_LOCATION_ANNOTATION = "backstage.io/source-location";

/**
 * Parses a string form location reference.
 *
 * Note that the return type is not `LocationSpec`, because we do not want to
 * conflate the string form with the additional properties of that type.
 *
 * @param ref A string-form location reference, e.g. 'url:https://host'
 * @returns A location reference, e.g. { type: 'url', target: 'https://host' }
 */
declare function parseLocationReference(ref: string): {
    type: string;
    target: string;
};
/**
 * Turns a location reference into its string form.
 *
 * Note that the input type is not `LocationSpec`, because we do not want to
 * conflate the string form with the additional properties of that type.
 *
 * @param ref A location reference, e.g. { type: 'url', target: 'https://host' }
 * @returns A string-form location reference, e.g. 'url:https://host'
 */
declare function stringifyLocationReference(ref: {
    type: string;
    target: string;
}): string;
/**
 * Returns the source code location of the Entity, to the extent that one exists.
 *
 * If the returned location type is of type 'url', the target should be readable at least
 * using the UrlReader from @backstage/backend-common. If it is not of type 'url', the caller
 * needs to have explicit handling of each location type or signal that it is not supported.
 */
declare function getEntitySourceLocation(entity: Entity): {
    type: string;
    target: string;
};

declare type LocationSpec = {
    type: string;
    target: string;
    presence?: 'optional' | 'required';
};
declare type Location = {
    id: string;
} & LocationSpec;

declare const locationSpecSchema: ObjectSchema<LocationSpec, object>;
declare const locationSchema: ObjectSchema<Location, object>;
declare const analyzeLocationSchema: ObjectSchema<{
    location: LocationSpec;
}, object>;

export { ApiEntityV1alpha1 as ApiEntity, ApiEntityV1alpha1, CommonValidatorFunctions, ComponentEntityV1alpha1 as ComponentEntity, ComponentEntityV1alpha1, DefaultNamespaceEntityPolicy, DomainEntityV1alpha1 as DomainEntity, DomainEntityV1alpha1, EDIT_URL_ANNOTATION, ENTITY_DEFAULT_NAMESPACE, ENTITY_META_GENERATED_FIELDS, Entity, EntityEnvelope, EntityLink, EntityMeta, EntityName, EntityPolicies, EntityPolicy, EntityRef, EntityRelation, EntityRelationSpec, FieldFormatEntityPolicy, GroupEntityV1alpha1 as GroupEntity, GroupEntityV1alpha1, JSONSchema, KindValidator, KubernetesValidatorFunctions, LOCATION_ANNOTATION, Location, LocationEntityV1alpha1 as LocationEntity, LocationEntityV1alpha1, LocationSpec, NoForeignRootFieldsEntityPolicy, ORIGIN_LOCATION_ANNOTATION, RELATION_API_CONSUMED_BY, RELATION_API_PROVIDED_BY, RELATION_CHILD_OF, RELATION_CONSUMES_API, RELATION_DEPENDENCY_OF, RELATION_DEPENDS_ON, RELATION_HAS_MEMBER, RELATION_HAS_PART, RELATION_MEMBER_OF, RELATION_OWNED_BY, RELATION_OWNER_OF, RELATION_PARENT_OF, RELATION_PART_OF, RELATION_PROVIDES_API, ResourceEntityV1alpha1 as ResourceEntity, ResourceEntityV1alpha1, SOURCE_LOCATION_ANNOTATION, SchemaValidEntityPolicy, SystemEntityV1alpha1 as SystemEntity, SystemEntityV1alpha1, TemplateEntityV1alpha1 as TemplateEntity, TemplateEntityV1alpha1, TemplateEntityV1beta2, UNSTABLE_EntityStatus, UNSTABLE_EntityStatusItem, UNSTABLE_EntityStatusLevel, UserEntityV1alpha1 as UserEntity, UserEntityV1alpha1, VIEW_URL_ANNOTATION, Validators, analyzeLocationSchema, apiEntityV1alpha1Validator, compareEntityToRef, componentEntityV1alpha1Validator, domainEntityV1alpha1Validator, entityEnvelopeSchemaValidator, entityHasChanges, entityKindSchemaValidator, entitySchemaValidator, generateEntityEtag, generateEntityUid, generateUpdatedEntity, getEntityName, getEntitySourceLocation, groupEntityV1alpha1Validator, locationEntityV1alpha1Validator, locationSchema, locationSpecSchema, makeValidator, parseEntityName, parseEntityRef, parseLocationReference, resourceEntityV1alpha1Validator, serializeEntityRef, stringifyEntityRef, stringifyLocationReference, systemEntityV1alpha1Validator, templateEntityV1alpha1Validator, templateEntityV1beta2Validator, userEntityV1alpha1Validator };
