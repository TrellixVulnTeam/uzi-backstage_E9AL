import { createApiRef, createExternalRouteRef, createRouteRef, createPlugin, createApiFactory, discoveryApiRef, identityApiRef, createRoutableExtension } from '@backstage/core';
import { scmIntegrationsApiRef } from '@backstage/integration-react';
import { ResponseError } from '@backstage/errors';
import ObservableImpl from 'zen-observable';

const scaffolderApiRef = createApiRef({
  id: "plugin.scaffolder.service",
  description: "Used to make requests towards the scaffolder backend"
});
class ScaffolderClient {
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.identityApi = options.identityApi;
    this.scmIntegrationsApi = options.scmIntegrationsApi;
  }
  async getIntegrationsList(options) {
    return [
      ...this.scmIntegrationsApi.azure.list(),
      ...this.scmIntegrationsApi.bitbucket.list(),
      ...this.scmIntegrationsApi.github.list(),
      ...this.scmIntegrationsApi.gitlab.list()
    ].map((c) => ({type: c.type, title: c.title, host: c.config.host})).filter((c) => options.allowedHosts.includes(c.host));
  }
  async getTemplateParameterSchema(templateName) {
    const {namespace, kind, name} = templateName;
    const token = await this.identityApi.getIdToken();
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const templatePath = [namespace, kind, name].map((s) => encodeURIComponent(s)).join("/");
    const url = `${baseUrl}/v2/templates/${templatePath}/parameter-schema`;
    const response = await fetch(url, {
      headers: {
        ...token && {Authorization: `Bearer ${token}`}
      }
    });
    if (!response.ok) {
      throw ResponseError.fromResponse(response);
    }
    const schema = await response.json();
    return schema;
  }
  async scaffold(templateName, values) {
    const token = await this.identityApi.getIdToken();
    const url = `${await this.discoveryApi.getBaseUrl("scaffolder")}/v2/tasks`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...token && {Authorization: `Bearer ${token}`}
      },
      body: JSON.stringify({templateName, values: {...values}})
    });
    if (response.status !== 201) {
      const status = `${response.status} ${response.statusText}`;
      const body = await response.text();
      throw new Error(`Backend request failed, ${status} ${body.trim()}`);
    }
    const {id} = await response.json();
    return id;
  }
  async getTask(taskId) {
    const token = await this.identityApi.getIdToken();
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}`;
    const response = await fetch(url, {
      headers: token ? {Authorization: `Bearer ${token}`} : {}
    });
    if (!response.ok) {
      throw ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  streamLogs({
    taskId,
    after
  }) {
    return new ObservableImpl((subscriber) => {
      const params = new URLSearchParams();
      if (after !== void 0) {
        params.set("after", String(Number(after)));
      }
      this.discoveryApi.getBaseUrl("scaffolder").then((baseUrl) => {
        const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}/eventstream`;
        const eventSource = new EventSource(url, {withCredentials: true});
        eventSource.addEventListener("log", (event) => {
          if (event.data) {
            try {
              subscriber.next(JSON.parse(event.data));
            } catch (ex) {
              subscriber.error(ex);
            }
          }
        });
        eventSource.addEventListener("completion", (event) => {
          if (event.data) {
            try {
              subscriber.next(JSON.parse(event.data));
            } catch (ex) {
              subscriber.error(ex);
            }
          }
          eventSource.close();
          subscriber.complete();
        });
        eventSource.addEventListener("error", (event) => {
          subscriber.error(event);
        });
      }, (error) => {
        subscriber.error(error);
      });
    });
  }
  async listActions() {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await fetch(`${baseUrl}/v2/actions`);
    if (!response.ok) {
      throw ResponseError.fromResponse(response);
    }
    return await response.json();
  }
}

const registerComponentRouteRef = createExternalRouteRef({
  id: "register-component",
  optional: true
});
const rootRouteRef = createRouteRef({
  title: "Create new entity"
});

const scaffolderPlugin = createPlugin({
  id: "scaffolder",
  apis: [
    createApiFactory({
      api: scaffolderApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        identityApi: identityApiRef,
        scmIntegrationsApi: scmIntegrationsApiRef
      },
      factory: ({discoveryApi, identityApi, scmIntegrationsApi}) => new ScaffolderClient({discoveryApi, identityApi, scmIntegrationsApi})
    })
  ],
  routes: {
    root: rootRouteRef
  },
  externalRoutes: {
    registerComponent: registerComponentRouteRef
  }
});
const ScaffolderPage = scaffolderPlugin.provide(createRoutableExtension({
  component: () => import('./Router-d4600cda.esm.js').then((m) => m.Router),
  mountPoint: rootRouteRef
}));

export { ScaffolderPage as S, registerComponentRouteRef as a, scaffolderPlugin as b, ScaffolderClient as c, rootRouteRef as r, scaffolderApiRef as s };
//# sourceMappingURL=index-bc9fd18e.esm.js.map
