'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lunr = require('lunr');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var lunr__default = /*#__PURE__*/_interopDefaultLegacy(lunr);

class IndexBuilder {
  constructor({logger, searchEngine}) {
    this.collators = {};
    this.decorators = {};
    this.logger = logger;
    this.searchEngine = searchEngine;
  }
  getSearchEngine() {
    return this.searchEngine;
  }
  addCollator({
    type,
    collator,
    defaultRefreshIntervalSeconds
  }) {
    this.logger.info(`Added ${collator.constructor.name} collator for type ${type}`);
    this.collators[type] = {
      refreshInterval: defaultRefreshIntervalSeconds,
      collate: collator
    };
  }
  addDecorator({
    types = ["*"],
    decorator
  }) {
    this.logger.info(`Added decorator ${decorator.constructor.name} to types ${types.join(", ")}`);
    types.forEach((type) => {
      if (this.decorators.hasOwnProperty(type)) {
        this.decorators[type].push(decorator);
      } else {
        this.decorators[type] = [decorator];
      }
    });
  }
  async build() {
    const scheduler = new Scheduler({logger: this.logger});
    Object.keys(this.collators).forEach((type) => {
      scheduler.addToSchedule(async () => {
        const decorators = (this.decorators["*"] || []).concat(this.decorators[type] || []);
        this.logger.debug(`Collating documents for ${type} via ${this.collators[type].collate.constructor.name}`);
        let documents = await this.collators[type].collate.execute();
        for (let i = 0; i < decorators.length; i++) {
          this.logger.debug(`Decorating ${type} documents via ${decorators[i].constructor.name}`);
          documents = await decorators[i].execute(documents);
        }
        if (!documents || documents.length === 0) {
          this.logger.debug(`No documents for type "${type}" to index`);
          return;
        }
        this.searchEngine.index(type, documents);
      }, this.collators[type].refreshInterval * 1e3);
    });
    return {
      scheduler
    };
  }
}

class Scheduler {
  constructor({logger}) {
    this.intervalTimeouts = [];
    this.logger = logger;
    this.schedule = [];
  }
  addToSchedule(task, interval) {
    if (this.intervalTimeouts.length) {
      throw new Error("Cannot add task to schedule that has already been started.");
    }
    this.schedule.push({task, interval});
  }
  start() {
    this.logger.info("Starting all scheduled search tasks.");
    this.schedule.forEach(({task, interval}) => {
      this.intervalTimeouts.push(setInterval(() => {
        task();
      }, interval));
    });
  }
  stop() {
    this.logger.info("Stopping all scheduled search tasks.");
    this.intervalTimeouts.forEach((timeout) => {
      clearInterval(timeout);
    });
    this.intervalTimeouts = [];
  }
}

class LunrSearchEngine {
  constructor({logger}) {
    this.lunrIndices = {};
    this.translator = ({
      term,
      filters,
      types
    }) => {
      let lunrQueryFilters;
      if (filters) {
        lunrQueryFilters = Object.entries(filters).map(([key, value]) => ` +${key}:${value}`).join("");
      }
      return {
        lunrQueryString: `${term}${lunrQueryFilters || ""}`,
        documentTypes: types || ["*"]
      };
    };
    this.logger = logger;
    this.docStore = {};
  }
  index(type, documents) {
    const lunrBuilder = new lunr__default['default'].Builder();
    Object.keys(documents[0]).forEach((field) => {
      lunrBuilder.field(field);
    });
    lunrBuilder.ref("location");
    documents.forEach((document) => {
      lunrBuilder.add(document);
      this.docStore[document.location] = document;
    });
    this.lunrIndices[type] = lunrBuilder.build();
  }
  query(query) {
    const {lunrQueryString, documentTypes} = this.translator(query);
    const results = [];
    if (documentTypes.length === 1 && documentTypes[0] === "*") {
      Object.values(this.lunrIndices).forEach((i) => {
        try {
          results.push(...i.search(lunrQueryString));
        } catch (err) {
          if (err instanceof lunr__default['default'].QueryParseError && err.message.startsWith("unrecognised field"))
            return;
        }
      });
    } else {
      Object.keys(this.lunrIndices).filter((d) => documentTypes.includes(d)).forEach((d) => {
        try {
          results.push(...this.lunrIndices[d].search(lunrQueryString));
        } catch (err) {
          if (err instanceof lunr__default['default'].QueryParseError && err.message.startsWith("unrecognised field"))
            return;
        }
      });
    }
    results.sort((doc1, doc2) => {
      return doc2.score - doc1.score;
    });
    const resultSet = {
      results: results.map((d) => {
        return {document: this.docStore[d.ref]};
      })
    };
    return Promise.resolve(resultSet);
  }
}

exports.IndexBuilder = IndexBuilder;
exports.LunrSearchEngine = LunrSearchEngine;
exports.Scheduler = Scheduler;
//# sourceMappingURL=index.cjs.js.map
