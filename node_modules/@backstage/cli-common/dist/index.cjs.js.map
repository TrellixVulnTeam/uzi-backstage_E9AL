{"version":3,"file":"index.cjs.js","sources":["../src/paths.ts"],"sourcesContent":["/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport { dirname, resolve as resolvePath } from 'path';\n\nexport type ResolveFunc = (...paths: string[]) => string;\n\n// Common paths and resolve functions used by the cli.\n// Currently assumes it is being executed within a monorepo.\nexport type Paths = {\n  // Root dir of the cli itself, containing package.json\n  ownDir: string;\n\n  // Monorepo root dir of the cli itself. Only accessible when running inside Backstage repo.\n  ownRoot: string;\n\n  // The location of the app that the cli is being executed in\n  targetDir: string;\n\n  // The monorepo root package of the app that the cli is being executed in.\n  targetRoot: string;\n\n  // Resolve a path relative to own repo\n  resolveOwn: ResolveFunc;\n\n  // Resolve a path relative to own monorepo root. Only accessible when running inside Backstage repo.\n  resolveOwnRoot: ResolveFunc;\n\n  // Resolve a path relative to the app\n  resolveTarget: ResolveFunc;\n\n  // Resolve a path relative to the app repo root\n  resolveTargetRoot: ResolveFunc;\n};\n\n// Looks for a package.json with a workspace config to identify the root of the monorepo\nexport function findRootPath(\n  searchDir: string,\n  filterFunc: (pkgJsonPath: string) => boolean,\n): string | undefined {\n  let path = searchDir;\n\n  // Some sanity check to avoid infinite loop\n  for (let i = 0; i < 1000; i++) {\n    const packagePath = resolvePath(path, 'package.json');\n    const exists = fs.existsSync(packagePath);\n    if (exists && filterFunc(packagePath)) {\n      return path;\n    }\n\n    const newPath = dirname(path);\n    if (newPath === path) {\n      return undefined;\n    }\n    path = newPath;\n  }\n\n  throw new Error(\n    `Iteration limit reached when searching for root package.json at ${searchDir}`,\n  );\n}\n\n// Finds the root of a given package\nexport function findOwnDir(searchDir: string) {\n  const path = findRootPath(searchDir, () => true);\n  if (!path) {\n    throw new Error(\n      `No package.json found while searching for package root of ${searchDir}`,\n    );\n  }\n  return path;\n}\n\n// Finds the root of the monorepo that the package exists in. Only accessible when running inside Backstage repo.\nexport function findOwnRootDir(ownDir: string) {\n  const isLocal = fs.existsSync(resolvePath(ownDir, 'src'));\n  if (!isLocal) {\n    throw new Error(\n      'Tried to access monorepo package root dir outside of Backstage repository',\n    );\n  }\n\n  return resolvePath(ownDir, '../..');\n}\n\n/**\n * Find paths related to a package and its execution context.\n *\n * @example\n *\n * const paths = findPaths(__dirname)\n */\nexport function findPaths(searchDir: string): Paths {\n  const ownDir = findOwnDir(searchDir);\n  // Drive letter can end up being lowercased here on Windows, bring back to uppercase for consistency\n  const targetDir = fs\n    .realpathSync(process.cwd())\n    .replace(/^[a-z]:/, str => str.toUpperCase());\n\n  // Lazy load this as it will throw an error if we're not inside the Backstage repo.\n  let ownRoot = '';\n  const getOwnRoot = () => {\n    if (!ownRoot) {\n      ownRoot = findOwnRootDir(ownDir);\n    }\n    return ownRoot;\n  };\n\n  // We're not always running in a monorepo, so we lazy init this to only crash commands\n  // that require a monorepo when we're not in one.\n  let targetRoot = '';\n  const getTargetRoot = () => {\n    if (!targetRoot) {\n      targetRoot =\n        findRootPath(targetDir, path => {\n          try {\n            const content = fs.readFileSync(path, 'utf8');\n            const data = JSON.parse(content);\n            return Boolean(data.workspaces?.packages);\n          } catch (error) {\n            throw new Error(\n              `Failed to parse package.json file while searching for root, ${error}`,\n            );\n          }\n        }) ?? targetDir; // We didn't find any root package.json, assume we're not in a monorepo\n    }\n    return targetRoot;\n  };\n\n  return {\n    ownDir,\n    get ownRoot() {\n      return getOwnRoot();\n    },\n    targetDir,\n    get targetRoot() {\n      return getTargetRoot();\n    },\n    resolveOwn: (...paths) => resolvePath(ownDir, ...paths),\n    resolveOwnRoot: (...paths) => resolvePath(getOwnRoot(), ...paths),\n    resolveTarget: (...paths) => resolvePath(targetDir, ...paths),\n    resolveTargetRoot: (...paths) => resolvePath(getTargetRoot(), ...paths),\n  };\n}\n"],"names":["resolvePath","dirname"],"mappings":"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"}