{"version":3,"file":"index.cjs.js","sources":["../src/DocsBuilder/BuildMetadataStorage.ts","../src/DocsBuilder/builder.ts","../src/service/router.ts"],"sourcesContent":["/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Entity uid: unix timestamp\nconst lastUpdatedRecord = {} as Record<string, number>;\n\n/**\n * Store timestamps of the most recent TechDocs update of each Entity. This is\n * used to avoid checking for an update on each and every request to TechDocs.\n */\nexport class BuildMetadataStorage {\n  private entityUid: string;\n  private lastUpdatedRecord: Record<string, number>;\n\n  constructor(entityUid: string) {\n    this.entityUid = entityUid;\n    this.lastUpdatedRecord = lastUpdatedRecord;\n  }\n\n  setLastUpdated(): void {\n    this.lastUpdatedRecord[this.entityUid] = Date.now();\n  }\n\n  getLastUpdated(): number | undefined {\n    return this.lastUpdatedRecord[this.entityUid];\n  }\n}\n\n/**\n * Return false if a check for update has happened in last 60 seconds.\n */\nexport const shouldCheckForUpdate = (entityUid: string) => {\n  const lastUpdated = new BuildMetadataStorage(entityUid).getLastUpdated();\n  if (lastUpdated) {\n    // The difference is in milliseconds\n    if (Date.now() - lastUpdated < 60 * 1000) {\n      return false;\n    }\n  }\n  return true;\n};\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Entity,\n  ENTITY_DEFAULT_NAMESPACE,\n  serializeEntityRef,\n} from '@backstage/catalog-model';\nimport { NotModifiedError } from '@backstage/errors';\nimport {\n  GeneratorBase,\n  GeneratorBuilder,\n  getLocationForEntity,\n  PreparerBase,\n  PreparerBuilder,\n  PublisherBase,\n  UrlPreparer,\n} from '@backstage/techdocs-common';\nimport fs from 'fs-extra';\nimport os from 'os';\nimport path from 'path';\nimport { Logger } from 'winston';\nimport { BuildMetadataStorage } from './BuildMetadataStorage';\n\ntype DocsBuilderArguments = {\n  preparers: PreparerBuilder;\n  generators: GeneratorBuilder;\n  publisher: PublisherBase;\n  entity: Entity;\n  logger: Logger;\n};\n\nexport class DocsBuilder {\n  private preparer: PreparerBase;\n  private generator: GeneratorBase;\n  private publisher: PublisherBase;\n  private entity: Entity;\n  private logger: Logger;\n\n  constructor({\n    preparers,\n    generators,\n    publisher,\n    entity,\n    logger,\n  }: DocsBuilderArguments) {\n    this.preparer = preparers.get(entity);\n    this.generator = generators.get(entity);\n    this.publisher = publisher;\n    this.entity = entity;\n    this.logger = logger;\n  }\n\n  public async build(): Promise<void> {\n    if (!this.entity.metadata.uid) {\n      throw new Error(\n        'Trying to build documentation for entity not in service catalog',\n      );\n    }\n\n    /**\n     * Prepare (and cache check)\n     */\n\n    this.logger.info(\n      `Step 1 of 3: Preparing docs for entity ${serializeEntityRef(\n        this.entity,\n      )}`,\n    );\n\n    // If available, use the etag stored in techdocs_metadata.json to\n    // check if docs are outdated and need to be regenerated.\n    let storedEtag: string | undefined;\n    if (await this.publisher.hasDocsBeenGenerated(this.entity)) {\n      try {\n        storedEtag = (\n          await this.publisher.fetchTechDocsMetadata({\n            namespace:\n              this.entity.metadata.namespace ?? ENTITY_DEFAULT_NAMESPACE,\n            kind: this.entity.kind,\n            name: this.entity.metadata.name,\n          })\n        ).etag;\n      } catch (err) {\n        // Proceed with a fresh build\n        this.logger.warn(\n          `Unable to read techdocs_metadata.json, proceeding with fresh build, error ${err}.`,\n        );\n      }\n    }\n\n    let preparedDir: string;\n    let newEtag: string;\n    try {\n      const preparerResponse = await this.preparer.prepare(this.entity, {\n        etag: storedEtag,\n      });\n\n      preparedDir = preparerResponse.preparedDir;\n      newEtag = preparerResponse.etag;\n    } catch (err) {\n      if (err instanceof NotModifiedError) {\n        // No need to prepare anymore since cache is valid.\n        // Set last check happened to now\n        new BuildMetadataStorage(this.entity.metadata.uid).setLastUpdated();\n        this.logger.debug(\n          `Docs for ${serializeEntityRef(\n            this.entity,\n          )} are unmodified. Using cache, skipping generate and prepare`,\n        );\n        return;\n      }\n      throw new Error(err.message);\n    }\n\n    this.logger.info(\n      `Prepare step completed for entity ${serializeEntityRef(\n        this.entity,\n      )}, stored at ${preparedDir}`,\n    );\n\n    /**\n     * Generate\n     */\n\n    this.logger.info(\n      `Step 2 of 3: Generating docs for entity ${serializeEntityRef(\n        this.entity,\n      )}`,\n    );\n\n    // Create a temporary directory to store the generated files in.\n    const tmpdirPath = os.tmpdir();\n    // Fixes a problem with macOS returning a path that is a symlink\n    const tmpdirResolvedPath = fs.realpathSync(tmpdirPath);\n    const outputDir = await fs.mkdtemp(\n      path.join(tmpdirResolvedPath, 'techdocs-tmp-'),\n    );\n    const parsedLocationAnnotation = getLocationForEntity(this.entity);\n    await this.generator.run({\n      inputDir: preparedDir,\n      outputDir,\n      parsedLocationAnnotation,\n      etag: newEtag,\n    });\n\n    // Remove Prepared directory since it is no longer needed.\n    // Caveat: Can not remove prepared directory in case of git preparer since the\n    // local git repository is used to get etag on subsequent requests.\n    if (this.preparer instanceof UrlPreparer) {\n      this.logger.debug(\n        `Removing prepared directory ${preparedDir} since the site has been generated`,\n      );\n      try {\n        // Not a blocker hence no need to await this.\n        fs.remove(preparedDir);\n      } catch (error) {\n        this.logger.debug(`Error removing prepared directory ${error.message}`);\n      }\n    }\n\n    /**\n     * Publish\n     */\n\n    this.logger.info(\n      `Step 3 of 3: Publishing docs for entity ${serializeEntityRef(\n        this.entity,\n      )}`,\n    );\n\n    await this.publisher.publish({\n      entity: this.entity,\n      directory: outputDir,\n    });\n\n    try {\n      // Not a blocker hence no need to await this.\n      fs.remove(outputDir);\n      this.logger.debug(\n        `Removing generated directory ${outputDir} since the site has been published`,\n      );\n    } catch (error) {\n      this.logger.debug(`Error removing generated directory ${error.message}`);\n    }\n\n    // Update the last check time for the entity\n    new BuildMetadataStorage(this.entity.metadata.uid).setLastUpdated();\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PluginEndpointDiscovery } from '@backstage/backend-common';\nimport { Entity, stringifyEntityRef } from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { NotFoundError } from '@backstage/errors';\nimport {\n  GeneratorBuilder,\n  getLocationForEntity,\n  PreparerBuilder,\n  PublisherBase,\n} from '@backstage/techdocs-common';\nimport fetch from 'cross-fetch';\nimport express from 'express';\nimport Router from 'express-promise-router';\nimport { Knex } from 'knex';\nimport { Logger } from 'winston';\nimport { DocsBuilder } from '../DocsBuilder';\nimport { shouldCheckForUpdate } from '../DocsBuilder/BuildMetadataStorage';\n\ntype RouterOptions = {\n  preparers: PreparerBuilder;\n  generators: GeneratorBuilder;\n  publisher: PublisherBase;\n  logger: Logger;\n  discovery: PluginEndpointDiscovery;\n  database?: Knex; // TODO: Make database required when we're implementing database stuff.\n  config: Config;\n};\n\nexport async function createRouter({\n  preparers,\n  generators,\n  publisher,\n  config,\n  logger,\n  discovery,\n}: RouterOptions): Promise<express.Router> {\n  const router = Router();\n\n  router.get('/metadata/techdocs/:namespace/:kind/:name', async (req, res) => {\n    const { kind, namespace, name } = req.params;\n    const entityName = { kind, namespace, name };\n\n    try {\n      const techdocsMetadata = await publisher.fetchTechDocsMetadata(\n        entityName,\n      );\n\n      res.json(techdocsMetadata);\n    } catch (err) {\n      logger.info(\n        `Unable to get metadata for '${stringifyEntityRef(\n          entityName,\n        )}' with error ${err}`,\n      );\n      throw new NotFoundError(\n        `Unable to get metadata for '${stringifyEntityRef(entityName)}'`,\n        err,\n      );\n    }\n  });\n\n  router.get('/metadata/entity/:namespace/:kind/:name', async (req, res) => {\n    const catalogUrl = await discovery.getBaseUrl('catalog');\n\n    const { kind, namespace, name } = req.params;\n    const entityName = { kind, namespace, name };\n\n    try {\n      const token = getBearerToken(req.headers.authorization);\n      // TODO: Consider using the catalog client here\n      const entity = (await (\n        await fetch(\n          `${catalogUrl}/entities/by-name/${kind}/${namespace}/${name}`,\n          {\n            headers: token ? { Authorization: `Bearer ${token}` } : {},\n          },\n        )\n      ).json()) as Entity;\n\n      const locationMetadata = getLocationForEntity(entity);\n      res.json({ ...entity, locationMetadata });\n    } catch (err) {\n      logger.info(\n        `Unable to get metadata for '${stringifyEntityRef(\n          entityName,\n        )}' with error ${err}`,\n      );\n      throw new NotFoundError(\n        `Unable to get metadata for '${stringifyEntityRef(entityName)}'`,\n        err,\n      );\n    }\n  });\n\n  // Check if docs are the latest version and trigger rebuilds if not\n  // Responds with immediate success if rebuild not needed\n  // If a build is required, responds with a success when finished\n  router.get('/sync/:namespace/:kind/:name', async (req, res) => {\n    const { kind, namespace, name } = req.params;\n    const catalogUrl = await discovery.getBaseUrl('catalog');\n    const triple = [kind, namespace, name].map(encodeURIComponent).join('/');\n\n    const token = getBearerToken(req.headers.authorization);\n    const catalogRes = await fetch(`${catalogUrl}/entities/by-name/${triple}`, {\n      headers: token ? { Authorization: `Bearer ${token}` } : {},\n    });\n    if (!catalogRes.ok) {\n      const catalogResText = await catalogRes.text();\n      res.status(catalogRes.status);\n      res.send(catalogResText);\n      return;\n    }\n\n    const entity: Entity = await catalogRes.json();\n\n    if (!entity.metadata.uid) {\n      throw new NotFoundError('Entity metadata UID missing');\n    }\n    if (!shouldCheckForUpdate(entity.metadata.uid)) {\n      res.status(200).json({\n        message: `Last check for documentation update is recent, did not retry.`,\n      });\n      return;\n    }\n\n    let publisherType = '';\n    try {\n      publisherType = config.getString('techdocs.publisher.type');\n    } catch (err) {\n      throw new Error(\n        'Unable to get techdocs.publisher.type in your app config. Set it to either ' +\n          \"'local', 'googleGcs' or other support storage providers. Read more here \" +\n          'https://backstage.io/docs/features/techdocs/architecture',\n      );\n    }\n    // techdocs-backend will only try to build documentation for an entity if techdocs.builder is set to 'local'\n    // If set to 'external', it will assume that an external process (e.g. CI/CD pipeline\n    // of the repository) is responsible for building and publishing documentation to the storage provider\n    if (config.getString('techdocs.builder') !== 'local') {\n      res.status(200).json({\n        message:\n          '`techdocs.builder` app config is not set to `local`, so docs will not be generated locally and sync is not required.',\n      });\n      return;\n    }\n    const docsBuilder = new DocsBuilder({\n      preparers,\n      generators,\n      publisher,\n      logger,\n      entity,\n    });\n    let foundDocs = false;\n    switch (publisherType) {\n      case 'local':\n      case 'awsS3':\n      case 'azureBlobStorage':\n      case 'openStackSwift':\n      case 'googleGcs':\n        // This block should be valid for all storage implementations. So no need to duplicate in future,\n        // add the publisher type in the list here.\n        await docsBuilder.build();\n        // With a maximum of ~5 seconds wait, check if the files got published and if docs will be fetched\n        // on the user's page. If not, respond with a message asking them to check back later.\n        // The delay here is to make sure GCS/AWS/etc. registers newly uploaded files which is usually <1 second\n        for (let attempt = 0; attempt < 5; attempt++) {\n          if (await publisher.hasDocsBeenGenerated(entity)) {\n            foundDocs = true;\n            break;\n          }\n          await new Promise(r => setTimeout(r, 1000));\n        }\n        if (!foundDocs) {\n          logger.error(\n            'Published files are taking longer to show up in storage. Something went wrong.',\n          );\n          throw new NotFoundError(\n            'Sorry! It took too long for the generated docs to show up in storage. Check back later.',\n          );\n        }\n        res\n          .status(201)\n          .json({ message: 'Docs updated or did not need updating' });\n        break;\n      default:\n        throw new NotFoundError(\n          `Publisher type ${publisherType} is not supported by techdocs-backend docs builder.`,\n        );\n    }\n  });\n\n  // Route middleware which serves files from the storage set in the publisher.\n  router.use('/static/docs', publisher.docsRouter());\n\n  return router;\n}\n\nfunction getBearerToken(header?: string): string | undefined {\n  return header?.match(/(?:Bearer)\\s+(\\S+)/i)?.[1];\n}\n"],"names":["serializeEntityRef","ENTITY_DEFAULT_NAMESPACE","NotModifiedError","os","fs","path","getLocationForEntity","UrlPreparer","Router","stringifyEntityRef","NotFoundError","fetch"],"mappings":"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"}