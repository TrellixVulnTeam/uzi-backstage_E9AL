/// <reference types="react" />
import { ApiRef, DiscoveryApi, OAuthApi, IdentityApi, ConfigApi, BackstagePlugin, RouteRef, InfoCardVariants } from '@backstage/core';
import React from 'react';
import { Entity, EntityName } from '@backstage/catalog-model';
import { CatalogApi } from '@backstage/catalog-client';
import { ScmIntegrationRegistry } from '@backstage/integration';
import { TextFieldProps } from '@material-ui/core/TextField/TextField';
import { Control, FieldErrors, UseControllerOptions, UseFormOptions, SubmitHandler, UseFormMethods, UnpackNestedValue } from 'react-hook-form';

declare type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends object ? RecursivePartial<T[P]> : T[P];
};
declare type PartialEntity = RecursivePartial<Entity>;

declare const catalogImportApiRef: ApiRef<CatalogImportApi>;
declare type AnalyzeResult = {
    type: 'locations';
    locations: Array<{
        target: string;
        entities: EntityName[];
    }>;
} | {
    type: 'repository';
    url: string;
    integrationType: string;
    generatedEntities: PartialEntity[];
};
interface CatalogImportApi {
    analyzeUrl(url: string): Promise<AnalyzeResult>;
    submitPullRequest(options: {
        repositoryUrl: string;
        fileContent: string;
        title: string;
        body: string;
    }): Promise<{
        link: string;
        location: string;
    }>;
}

declare class CatalogImportClient implements CatalogImportApi {
    private readonly discoveryApi;
    private readonly identityApi;
    private readonly githubAuthApi;
    private readonly scmIntegrationsApi;
    private readonly catalogApi;
    constructor(options: {
        discoveryApi: DiscoveryApi;
        githubAuthApi: OAuthApi;
        identityApi: IdentityApi;
        scmIntegrationsApi: ScmIntegrationRegistry;
        catalogApi: CatalogApi;
    });
    analyzeUrl(url: string): Promise<AnalyzeResult>;
    submitPullRequest({ repositoryUrl, fileContent, title, body, }: {
        repositoryUrl: string;
        fileContent: string;
        title: string;
        body: string;
    }): Promise<{
        link: string;
        location: string;
    }>;
    private generateEntityDefinitions;
    private checkGitHubForExistingCatalogInfo;
    private submitGitHubPrToRepo;
}

declare type ImportFlows = 'unknown' | 'single-location' | 'multiple-locations' | 'no-location';
declare type PrepareResult = {
    type: 'locations';
    locations: Array<{
        target: string;
        entities: EntityName[];
    }>;
} | {
    type: 'repository';
    url: string;
    integrationType: string;
    pullRequest: {
        url: string;
    };
    locations: Array<{
        target: string;
        entities: EntityName[];
    }>;
};
declare type ReviewResult = {
    type: 'locations';
    locations: Array<{
        target: string;
        entities: Entity[];
    }>;
} | {
    type: 'repository';
    url: string;
    integrationType: string;
    pullRequest: {
        url: string;
    };
    locations: Array<{
        target: string;
        entities: Entity[];
    }>;
};
declare type onAnalysisFn = (flow: ImportFlows, url: string, result: AnalyzeResult, opts?: {
    prepareResult?: PrepareResult;
}) => void;
declare type onPrepareFn = (result: PrepareResult, opts?: {
    notRepeatable?: boolean;
}) => void;
declare type onReviewFn = (result: ReviewResult) => void;
declare type State = {
    activeState: 'analyze';
    onAnalysis: onAnalysisFn;
} | {
    activeState: 'prepare';
    analyzeResult: AnalyzeResult;
    prepareResult?: PrepareResult;
    onPrepare: onPrepareFn;
} | {
    activeState: 'review';
    analyzeResult: AnalyzeResult;
    prepareResult: PrepareResult;
    onReview: onReviewFn;
} | {
    activeState: 'finish';
    analyzeResult: AnalyzeResult;
    prepareResult: PrepareResult;
    reviewResult: ReviewResult;
};
declare type ImportState = State & {
    activeFlow: ImportFlows;
    activeStepNumber: number;
    analysisUrl?: string;
    onGoBack?: () => void;
    onReset: () => void;
};

declare type StepperProviderOpts = {
    pullRequest?: {
        disable?: boolean;
        preparePullRequest?: (apis: StepperApis) => {
            title?: string;
            body?: string;
        };
    };
};
declare type StepperApis = {
    configApi: ConfigApi;
};
declare type StepConfiguration = {
    stepLabel: React.ReactElement;
    content: React.ReactElement;
};
declare type StepperProvider = {
    analyze: (s: Extract<ImportState, {
        activeState: 'analyze';
    }>, opts: {
        apis: StepperApis;
        opts?: StepperProviderOpts;
    }) => StepConfiguration;
    prepare: (s: Extract<ImportState, {
        activeState: 'prepare';
    }>, opts: {
        apis: StepperApis;
        opts?: StepperProviderOpts;
    }) => StepConfiguration;
    review: (s: Extract<ImportState, {
        activeState: 'review';
    }>, opts: {
        apis: StepperApis;
        opts?: StepperProviderOpts;
    }) => StepConfiguration;
    finish: (s: Extract<ImportState, {
        activeState: 'finish';
    }>, opts: {
        apis: StepperApis;
        opts?: StepperProviderOpts;
    }) => StepConfiguration;
};
/**
 * The default stepper generation function.
 *
 * Override this function to customize the import flow. Each flow should at
 * least override the prepare operation.
 *
 * @param flow the name of the active flow
 * @param defaults the default steps
 */
declare function defaultGenerateStepper(flow: ImportFlows, defaults: StepperProvider): StepperProvider;

declare const catalogImportPlugin: BackstagePlugin<{
    importPage: RouteRef<undefined>;
}, {}>;
declare const CatalogImportPage: (opts: StepperProviderOpts) => JSX.Element;

declare const Router: (opts: StepperProviderOpts) => JSX.Element;

declare type Props = {
    initialUrl?: string;
    generateStepper?: (flow: ImportFlows, defaults: StepperProvider) => StepperProvider;
    variant?: InfoCardVariants;
    opts?: StepperProviderOpts;
};
declare const ImportStepper: ({ initialUrl, generateStepper, variant, opts, }: Props) => JSX.Element;

declare type Props$1 = {
    locations: Array<{
        target: string;
        entities: (Entity | EntityName)[];
    }>;
    locationListItemIcon: (target: string) => React.ReactElement;
    collapsed?: boolean;
    firstListItem?: React.ReactElement;
    onItemClick?: (target: string) => void;
    withLinks?: boolean;
};
declare const EntityListComponent: ({ locations, collapsed, locationListItemIcon, onItemClick, firstListItem, withLinks, }: Props$1) => JSX.Element;

declare type Props$2 = {
    onAnalysis: (flow: ImportFlows, url: string, result: AnalyzeResult, opts?: {
        prepareResult?: PrepareResult;
    }) => void;
    disablePullRequest?: boolean;
    analysisUrl?: string;
};
/**
 * A form that lets the user input a url and analyze it for existing locations or potential entities.
 *
 * @param onAnalysis is called when the analysis was successful
 * @param analysisUrl a url that can be used as a default value
 * @param disablePullRequest if true, repositories without entities will abort the wizard
 */
declare const StepInitAnalyzeUrl: ({ onAnalysis, analysisUrl, disablePullRequest, }: Props$2) => JSX.Element;

declare type Props$3<TFieldValue extends string> = {
    name: TFieldValue;
    options: string[];
    required?: boolean;
    control?: Control<Record<string, any>>;
    errors?: FieldErrors<Record<TFieldValue, string>>;
    rules?: UseControllerOptions<Record<TFieldValue, any>>['rules'];
    loading?: boolean;
    loadingText?: string;
    helperText?: React.ReactNode;
    errorHelperText?: string;
    textFieldProps?: Omit<TextFieldProps, 'required' | 'fullWidth'>;
};
declare const AutocompleteTextField: <TFieldValue extends string>({ name, options, required, control, errors, rules, loading, loadingText, helperText, errorHelperText, textFieldProps, }: Props$3<TFieldValue>) => JSX.Element;

declare type Props$4<TFieldValues extends Record<string, any>> = Pick<UseFormOptions<TFieldValues>, 'defaultValues'> & {
    onSubmit: SubmitHandler<TFieldValues>;
    render: (props: Pick<UseFormMethods<TFieldValues>, 'errors' | 'register' | 'control'> & {
        values: UnpackNestedValue<TFieldValues>;
    }) => React.ReactNode;
};
/**
 * A form wrapper that creates a form that is used to prepare a pull request. It
 * hosts the form logic.
 *
 * @param defaultValues the default values of the form
 * @param onSubmit a callback that is executed when the form is submitted
 *   (initiated by a button of type="submit")
 * @param render render the form elements
 */
declare const PreparePullRequestForm: <TFieldValues extends Record<string, any>>({ defaultValues, onSubmit, render, }: Props$4<TFieldValues>) => JSX.Element;

declare type Props$5 = {
    repositoryUrl: string;
    entities: Entity[];
    classes?: {
        card?: string;
        cardContent?: string;
    };
};
declare const PreviewCatalogInfoComponent: ({ repositoryUrl, entities, classes, }: Props$5) => JSX.Element;

declare type Props$6 = {
    title: string;
    description: string;
    classes?: {
        card?: string;
        cardContent?: string;
    };
};
declare const PreviewPullRequestComponent: ({ title, description, classes, }: Props$6) => JSX.Element;

declare type FormData = {
    title: string;
    body: string;
    componentName: string;
    owner: string;
    useCodeowners: boolean;
};
declare type Props$7 = {
    analyzeResult: Extract<AnalyzeResult, {
        type: 'repository';
    }>;
    onPrepare: (result: PrepareResult, opts?: {
        notRepeatable?: boolean;
    }) => void;
    onGoBack?: () => void;
    defaultTitle: string;
    defaultBody: string;
    renderFormFields: (props: Pick<UseFormMethods<FormData>, 'errors' | 'register' | 'control'> & {
        values: UnpackNestedValue<FormData>;
        groups: string[];
        groupsLoading: boolean;
    }) => React.ReactNode;
};
declare const StepPrepareCreatePullRequest: ({ analyzeResult, onPrepare, onGoBack, renderFormFields, defaultTitle, defaultBody, }: Props$7) => JSX.Element;

export { AnalyzeResult, AutocompleteTextField, CatalogImportApi, CatalogImportClient, CatalogImportPage, EntityListComponent, ImportStepper, PreparePullRequestForm, PreviewCatalogInfoComponent, PreviewPullRequestComponent, Router, StepInitAnalyzeUrl, StepPrepareCreatePullRequest, catalogImportApiRef, catalogImportPlugin, defaultGenerateStepper, catalogImportPlugin as plugin };
