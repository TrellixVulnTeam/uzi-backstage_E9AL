'use strict';

var index = require('./index-ce78e402.cjs.js');
var fs = require('fs-extra');
var webpack = require('webpack');
var path = require('path');
var ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');
var HtmlWebpackPlugin = require('html-webpack-plugin');
var ModuleScopePlugin = require('react-dev-utils/ModuleScopePlugin');
var StartServerPlugin = require('start-server-webpack-plugin');
var nodeExternals = require('webpack-node-externals');
var TerserPlugin = require('terser-webpack-plugin');
var parallel = require('./parallel-a4714c72.cjs.js');
var MiniCssExtractPlugin = require('mini-css-extract-plugin');
var svgrTemplate = require('./svgrTemplate-2d0d15cf.cjs.js');
var run = require('./run-646af88e.cjs.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var webpack__default = /*#__PURE__*/_interopDefaultLegacy(webpack);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var ForkTsCheckerWebpackPlugin__default = /*#__PURE__*/_interopDefaultLegacy(ForkTsCheckerWebpackPlugin);
var HtmlWebpackPlugin__default = /*#__PURE__*/_interopDefaultLegacy(HtmlWebpackPlugin);
var ModuleScopePlugin__default = /*#__PURE__*/_interopDefaultLegacy(ModuleScopePlugin);
var StartServerPlugin__default = /*#__PURE__*/_interopDefaultLegacy(StartServerPlugin);
var nodeExternals__default = /*#__PURE__*/_interopDefaultLegacy(nodeExternals);
var TerserPlugin__default = /*#__PURE__*/_interopDefaultLegacy(TerserPlugin);
var MiniCssExtractPlugin__default = /*#__PURE__*/_interopDefaultLegacy(MiniCssExtractPlugin);

const optimization = (options) => {
  const {isDev} = options;
  return {
    minimize: !isDev,
    ...!parallel.isParallelDefault(options.parallel) ? {
      minimizer: [
        new TerserPlugin__default['default']({
          parallel: options.parallel
        })
      ]
    } : {},
    runtimeChunk: "single",
    splitChunks: {
      automaticNameDelimiter: "-",
      cacheGroups: {
        default: false,
        packages: {
          chunks: "initial",
          test: /[\\/]node_modules[\\/]/,
          name(module) {
            const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1];
            return packageName.replace("@", "");
          },
          filename: isDev ? "module-[name].js" : "static/module-[name].[chunkhash:8].js",
          priority: 10,
          minSize: 1e5,
          minChunks: 1,
          maxAsyncRequests: Infinity,
          maxInitialRequests: Infinity
        },
        vendor: {
          chunks: "initial",
          test: /[\\/]node_modules[\\/]/,
          name: "vendor",
          priority: 5,
          enforce: true
        }
      }
    }
  };
};

function isChildPath(base, dir) {
  const relativePath = path__default['default'].relative(base, dir);
  if (relativePath === "") {
    return true;
  }
  const outsideBase = relativePath.startsWith("..");
  const differentDrive = path__default['default'].isAbsolute(relativePath);
  return !outsideBase && !differentDrive;
}
function resolveBundlingPaths(options) {
  const {entry} = options;
  const resolveTargetModule = (pathString) => {
    for (const ext of ["mjs", "js", "ts", "tsx", "jsx"]) {
      const filePath = index.paths.resolveTarget(`${pathString}.${ext}`);
      if (fs__default['default'].pathExistsSync(filePath)) {
        return filePath;
      }
    }
    return index.paths.resolveTarget(`${pathString}.js`);
  };
  let targetPublic = void 0;
  let targetHtml = index.paths.resolveTarget("public/index.html");
  if (fs__default['default'].pathExistsSync(targetHtml)) {
    targetPublic = index.paths.resolveTarget("public");
  } else {
    targetHtml = index.paths.resolveTarget(`${entry}.html`);
    if (!fs__default['default'].pathExistsSync(targetHtml)) {
      targetHtml = index.paths.resolveOwn("templates/serve_index.html");
    }
  }
  const targetRunFile = index.paths.resolveTarget("src/run.ts");
  const runFileExists = fs__default['default'].pathExistsSync(targetRunFile);
  return {
    targetHtml,
    targetPublic,
    targetPath: index.paths.resolveTarget("."),
    targetRunFile: runFileExists ? targetRunFile : void 0,
    targetDist: index.paths.resolveTarget("dist"),
    targetAssets: index.paths.resolveTarget("assets"),
    targetSrc: index.paths.resolveTarget("src"),
    targetDev: index.paths.resolveTarget("dev"),
    targetEntry: resolveTargetModule(entry),
    targetTsConfig: index.paths.resolveTargetRoot("tsconfig.json"),
    targetPackageJson: index.paths.resolveTarget("package.json"),
    rootNodeModules: index.paths.resolveTargetRoot("node_modules"),
    root: index.paths.targetRoot
  };
}

const transforms = (options) => {
  const {isDev} = options;
  const extraTransforms = isDev ? ["react-hot-loader"] : [];
  const loaders = [
    {
      test: /\.(tsx?)$/,
      exclude: /node_modules/,
      loader: require.resolve("@sucrase/webpack-loader"),
      options: {
        transforms: ["typescript", "jsx", ...extraTransforms],
        production: !isDev
      }
    },
    {
      test: /\.(jsx?|mjs)$/,
      exclude: /node_modules/,
      loader: require.resolve("@sucrase/webpack-loader"),
      options: {
        transforms: ["jsx", ...extraTransforms],
        production: !isDev
      }
    },
    {
      test: [/\.icon\.svg$/],
      use: [
        {
          loader: require.resolve("@sucrase/webpack-loader"),
          options: {
            transforms: ["jsx", ...extraTransforms],
            production: !isDev
          }
        },
        {
          loader: require.resolve("@svgr/webpack"),
          options: {babel: false, template: svgrTemplate.svgrTemplate}
        }
      ]
    },
    {
      test: [
        /\.bmp$/,
        /\.gif$/,
        /\.jpe?g$/,
        /\.png$/,
        /\.frag/,
        {and: [/\.svg/, {not: [/\.icon\.svg/]}]},
        /\.xml/
      ],
      loader: require.resolve("url-loader"),
      options: {
        limit: 1e4,
        name: "static/[name].[hash:8].[ext]"
      }
    },
    {
      test: /\.ya?ml$/,
      use: require.resolve("yml-loader")
    },
    {
      include: /\.(md)$/,
      use: require.resolve("raw-loader")
    },
    {
      test: /\.css$/i,
      use: [
        isDev ? require.resolve("style-loader") : MiniCssExtractPlugin__default['default'].loader,
        {
          loader: require.resolve("css-loader"),
          options: {
            sourceMap: true
          }
        }
      ]
    }
  ];
  const plugins = new Array();
  if (isDev) {
    plugins.push(new webpack__default['default'].HotModuleReplacementPlugin());
  } else {
    plugins.push(new MiniCssExtractPlugin__default['default']({
      filename: "static/[name].[contenthash:8].css",
      chunkFilename: "static/[name].[id].[contenthash:8].css"
    }));
  }
  return {loaders, plugins};
};

class LinkedPackageResolvePlugin {
  constructor(targetModules, packages) {
    this.targetModules = targetModules;
    this.packages = packages;
  }
  apply(resolver) {
    resolver.hooks.resolve.tapAsync("LinkedPackageResolvePlugin", (data, context, callback) => {
      var _a;
      const pkg = this.packages.find((pkge) => data.path && isChildPath(pkge.location, data.path));
      if (!pkg) {
        callback();
        return;
      }
      const modulesLocation = path.resolve(this.targetModules, pkg.name);
      const newContext = ((_a = data.context) == null ? void 0 : _a.issuer) ? {
        ...data.context,
        issuer: data.context.issuer.replace(pkg.location, modulesLocation)
      } : data.context;
      resolver.doResolve(resolver.hooks.resolve, {
        ...data,
        context: newContext,
        path: data.path && data.path.replace(pkg.location, modulesLocation)
      }, `resolve ${data.request} in ${modulesLocation}`, context, callback);
    });
  }
}

function resolveBaseUrl(config) {
  const baseUrl = config.getString("app.baseUrl");
  try {
    return new URL(baseUrl);
  } catch (error) {
    throw new Error(`Invalid app.baseUrl, ${error}`);
  }
}
async function readBuildInfo() {
  const timestamp = Date.now();
  let commit = "unknown";
  try {
    commit = await run.runPlain("git", "rev-parse", "HEAD");
  } catch (error) {
    console.warn(`WARNING: Failed to read git commit, ${error}`);
  }
  let gitVersion = "unknown";
  try {
    gitVersion = await run.runPlain("git", "describe", "--always");
  } catch (error) {
    console.warn(`WARNING: Failed to describe git version, ${error}`);
  }
  const {version: packageVersion} = await fs__default['default'].readJson(index.paths.resolveTarget("package.json"));
  return {
    cliVersion: index.version,
    gitVersion,
    packageVersion,
    timestamp,
    commit
  };
}
async function loadLernaPackages() {
  const {Project} = require("@lerna/project");
  const project = new Project(index.paths.targetDir);
  return project.getPackages();
}
async function createConfig(paths, options) {
  const {checksEnabled, isDev, frontendConfig} = options;
  const packages = await loadLernaPackages();
  const {plugins, loaders} = transforms(options);
  const externalPkgs = packages.filter((p) => !isChildPath(paths.root, p.location));
  const baseUrl = frontendConfig.getString("app.baseUrl");
  const validBaseUrl = new URL(baseUrl);
  if (checksEnabled) {
    plugins.push(new ForkTsCheckerWebpackPlugin__default['default']({
      typescript: {
        configFile: paths.targetTsConfig
      },
      eslint: {
        files: ["**", "!**/__tests__/**", "!**/?(*.)(spec|test).*"],
        options: {
          parserOptions: {
            project: paths.targetTsConfig,
            tsconfigRootDir: paths.targetPath
          }
        }
      }
    }));
  }
  plugins.push(new webpack__default['default'].EnvironmentPlugin({
    APP_CONFIG: options.frontendAppConfigs
  }));
  plugins.push(new HtmlWebpackPlugin__default['default']({
    template: paths.targetHtml,
    templateParameters: {
      publicPath: validBaseUrl.pathname.replace(/\/$/, ""),
      app: {
        title: frontendConfig.getString("app.title"),
        baseUrl: validBaseUrl.href,
        googleAnalyticsTrackingId: frontendConfig.getOptionalString("app.googleAnalyticsTrackingId"),
        datadogRum: {
          env: frontendConfig.getOptionalString("app.datadogRum.env"),
          clientToken: frontendConfig.getOptionalString("app.datadogRum.clientToken"),
          applicationId: frontendConfig.getOptionalString("app.datadogRum.applicationId"),
          site: frontendConfig.getOptionalString("app.datadogRum.site")
        }
      }
    }
  }));
  const buildInfo = await readBuildInfo();
  plugins.push(new webpack__default['default'].DefinePlugin({
    "process.env.BUILD_INFO": JSON.stringify(buildInfo)
  }));
  return {
    mode: isDev ? "development" : "production",
    profile: false,
    node: {
      module: "empty",
      dgram: "empty",
      dns: "mock",
      fs: "empty",
      http2: "empty",
      net: "empty",
      tls: "empty",
      child_process: "empty"
    },
    optimization: optimization(options),
    bail: false,
    performance: {
      hints: false
    },
    devtool: isDev ? "cheap-module-eval-source-map" : "source-map",
    context: paths.targetPath,
    entry: [require.resolve("react-hot-loader/patch"), paths.targetEntry],
    resolve: {
      extensions: [".ts", ".tsx", ".mjs", ".js", ".jsx"],
      mainFields: ["browser", "module", "main"],
      plugins: [
        new LinkedPackageResolvePlugin(paths.rootNodeModules, externalPkgs),
        new ModuleScopePlugin__default['default']([paths.targetSrc, paths.targetDev], [paths.targetPackageJson])
      ],
      alias: {
        "react-dom": "@hot-loader/react-dom"
      }
    },
    module: {
      rules: loaders
    },
    output: {
      path: paths.targetDist,
      publicPath: validBaseUrl.pathname,
      filename: isDev ? "[name].js" : "static/[name].[hash:8].js",
      chunkFilename: isDev ? "[name].chunk.js" : "static/[name].[chunkhash:8].chunk.js"
    },
    plugins
  };
}
async function createBackendConfig(paths, options) {
  const {checksEnabled, isDev} = options;
  const packages = await await loadLernaPackages();
  const localPackageNames = packages.map((p) => p.name);
  const moduleDirs = packages.map((p) => path.resolve(p.location, "node_modules"));
  const externalPkgs = packages.filter((p) => !isChildPath(paths.root, p.location));
  const {loaders} = transforms(options);
  return {
    mode: isDev ? "development" : "production",
    profile: false,
    ...isDev ? {
      watch: true,
      watchOptions: {
        ignored: [/node_modules\/(?!\@backstage)/]
      }
    } : {},
    externals: [
      nodeExternalsWithResolve({
        modulesDir: paths.rootNodeModules,
        additionalModuleDirs: moduleDirs,
        allowlist: ["webpack/hot/poll?100", ...localPackageNames]
      })
    ],
    target: "node",
    node: {
      __dirname: true,
      __filename: true,
      global: true
    },
    bail: false,
    performance: {
      hints: false
    },
    devtool: isDev ? "cheap-module-eval-source-map" : "source-map",
    context: paths.targetPath,
    entry: [
      "webpack/hot/poll?100",
      paths.targetRunFile ? paths.targetRunFile : paths.targetEntry
    ],
    resolve: {
      extensions: [".ts", ".tsx", ".mjs", ".js", ".jsx"],
      mainFields: ["browser", "module", "main"],
      modules: [paths.rootNodeModules, ...moduleDirs],
      plugins: [
        new LinkedPackageResolvePlugin(paths.rootNodeModules, externalPkgs),
        new ModuleScopePlugin__default['default']([paths.targetSrc, paths.targetDev], [paths.targetPackageJson])
      ],
      alias: {
        "react-dom": "@hot-loader/react-dom"
      }
    },
    module: {
      rules: loaders
    },
    output: {
      path: paths.targetDist,
      filename: isDev ? "[name].js" : "[name].[hash:8].js",
      chunkFilename: isDev ? "[name].chunk.js" : "[name].[chunkhash:8].chunk.js",
      ...isDev ? {
        devtoolModuleFilenameTemplate: "file:///[absolute-resource-path]"
      } : {}
    },
    plugins: [
      new StartServerPlugin__default['default']({
        name: "main.js",
        nodeArgs: options.inspectEnabled ? ["--inspect"] : void 0
      }),
      new webpack__default['default'].HotModuleReplacementPlugin(),
      ...checksEnabled ? [
        new ForkTsCheckerWebpackPlugin__default['default']({
          typescript: {
            configFile: paths.targetTsConfig
          },
          eslint: {
            files: ["**", "!**/__tests__/**", "!**/?(*.)(spec|test).*"],
            options: {
              parserOptions: {
                project: paths.targetTsConfig,
                tsconfigRootDir: paths.targetPath
              }
            }
          }
        })
      ] : []
    ]
  };
}
function nodeExternalsWithResolve(options) {
  let currentContext;
  const externals = nodeExternals__default['default']({
    ...options,
    importType(request) {
      const resolved = require.resolve(request, {
        paths: [currentContext]
      });
      return `commonjs ${resolved}`;
    }
  });
  return (context, request, callback) => {
    currentContext = context;
    return externals(context, request, callback);
  };
}

exports.createBackendConfig = createBackendConfig;
exports.createConfig = createConfig;
exports.resolveBaseUrl = resolveBaseUrl;
exports.resolveBundlingPaths = resolveBundlingPaths;
//# sourceMappingURL=config-ead78a79.cjs.js.map
