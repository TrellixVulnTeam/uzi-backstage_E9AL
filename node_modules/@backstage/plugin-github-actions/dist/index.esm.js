import { createApiRef, createRouteRef, createPlugin, createApiFactory, configApiRef, githubAuthApiRef, createRoutableExtension, createComponentExtension, StatusPending, StatusOK, StatusError, StatusWarning, StatusAborted, StatusRunning, useApi, useRouteRefParams, Breadcrumbs, Link, errorApiRef, EmptyState, Table as Table$1, MissingAnnotationEmptyState, InfoCard, StructuredMetadataTable } from '@backstage/core';
import { readGitHubIntegrationConfigs } from '@backstage/integration';
import { Octokit } from '@octokit/rest';
import React, { Suspense, useState, useEffect } from 'react';
import { useEntity } from '@backstage/plugin-catalog-react';
import { Routes, Route } from 'react-router';
import { makeStyles, Accordion, AccordionSummary, Typography, CircularProgress, Tooltip, Zoom, Modal, Fade, LinearProgress, Box, TableContainer, Paper, Table, TableBody, TableRow, TableCell, Link as Link$1, AccordionDetails, ListItemText, Button, IconButton } from '@material-ui/core';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import ExternalLinkIcon from '@material-ui/icons/Launch';
import moment from 'moment';
import { useAsync, useAsyncRetry } from 'react-use';
import DescriptionIcon from '@material-ui/icons/Description';
import RetryIcon from '@material-ui/icons/Replay';
import GitHubIcon from '@material-ui/icons/GitHub';
import { Link as Link$2, generatePath } from 'react-router-dom';
import SyncIcon from '@material-ui/icons/Sync';

const githubActionsApiRef = createApiRef({
  id: "plugin.githubactions.service",
  description: "Used by the GitHub Actions plugin to make requests"
});

class GithubActionsClient {
  constructor(options) {
    this.configApi = options.configApi;
    this.githubAuthApi = options.githubAuthApi;
  }
  async getOctokit(hostname) {
    var _a;
    const token = await this.githubAuthApi.getAccessToken(["repo"]);
    const configs = readGitHubIntegrationConfigs((_a = this.configApi.getOptionalConfigArray("integrations.github")) != null ? _a : []);
    const githubIntegrationConfig = configs.find((v) => v.host === hostname);
    const baseUrl = githubIntegrationConfig == null ? void 0 : githubIntegrationConfig.apiBaseUrl;
    return new Octokit({auth: token, baseUrl});
  }
  async reRunWorkflow({
    hostname,
    owner,
    repo,
    runId
  }) {
    const octokit = await this.getOctokit(hostname);
    return octokit.actions.reRunWorkflow({
      owner,
      repo,
      run_id: runId
    });
  }
  async listWorkflowRuns({
    hostname,
    owner,
    repo,
    pageSize = 100,
    page = 0,
    branch
  }) {
    const octokit = await this.getOctokit(hostname);
    const workflowRuns = await octokit.actions.listWorkflowRunsForRepo({
      owner,
      repo,
      per_page: pageSize,
      page,
      ...branch ? {branch} : {}
    });
    return workflowRuns.data;
  }
  async getWorkflow({
    hostname,
    owner,
    repo,
    id
  }) {
    const octokit = await this.getOctokit(hostname);
    const workflow = await octokit.actions.getWorkflow({
      owner,
      repo,
      workflow_id: id
    });
    return workflow.data;
  }
  async getWorkflowRun({
    hostname,
    owner,
    repo,
    id
  }) {
    const octokit = await this.getOctokit(hostname);
    const run = await octokit.actions.getWorkflowRun({
      owner,
      repo,
      run_id: id
    });
    return run.data;
  }
  async downloadJobLogsForWorkflowRun({
    hostname,
    owner,
    repo,
    runId
  }) {
    const octokit = await this.getOctokit(hostname);
    const workflow = await octokit.actions.downloadJobLogsForWorkflowRun({
      owner,
      repo,
      job_id: runId
    });
    return workflow.data;
  }
}

var BuildStatus;
(function(BuildStatus2) {
  BuildStatus2[BuildStatus2["success"] = 0] = "success";
  BuildStatus2[BuildStatus2["failure"] = 1] = "failure";
  BuildStatus2[BuildStatus2["pending"] = 2] = "pending";
  BuildStatus2[BuildStatus2["running"] = 3] = "running";
})(BuildStatus || (BuildStatus = {}));

const rootRouteRef = createRouteRef({
  path: "",
  title: "GitHub Actions"
});
const buildRouteRef = createRouteRef({
  path: ":id",
  params: ["id"],
  title: "GitHub Actions Workflow Run"
});

const githubActionsPlugin = createPlugin({
  id: "github-actions",
  apis: [
    createApiFactory({
      api: githubActionsApiRef,
      deps: {configApi: configApiRef, githubAuthApi: githubAuthApiRef},
      factory: ({configApi, githubAuthApi}) => new GithubActionsClient({configApi, githubAuthApi})
    })
  ],
  routes: {
    entityContent: rootRouteRef
  }
});
const EntityGithubActionsContent = githubActionsPlugin.provide(createRoutableExtension({
  component: () => Promise.resolve().then(function () { return Router$1; }).then((m) => m.Router),
  mountPoint: rootRouteRef
}));
const EntityLatestGithubActionRunCard = githubActionsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./esm/index-dd6083b6.esm.js').then((m) => m.LatestWorkflowRunCard)
  }
}));
const EntityLatestGithubActionsForBranchCard = githubActionsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./esm/index-dd6083b6.esm.js').then((m) => m.LatestWorkflowsForBranchCard)
  }
}));
const EntityRecentGithubActionsRunsCard = githubActionsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./esm/index-dd6083b6.esm.js').then((m) => m.RecentWorkflowRunsCard)
  }
}));

const GITHUB_ACTIONS_ANNOTATION = "github.com/project-slug";
const useProjectName = (entity) => {
  const {value, loading, error} = useAsync(async () => {
    var _a, _b;
    return (_b = (_a = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _a[GITHUB_ACTIONS_ANNOTATION]) != null ? _b : "";
  });
  return {value, loading, error};
};

const WorkflowRunStatus = ({
  status,
  conclusion
}) => {
  if (status === void 0)
    return null;
  switch (status.toLocaleLowerCase("en-US")) {
    case "queued":
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusPending, null), " Queued");
    case "in_progress":
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusRunning, null), " In progress");
    case "completed":
      switch (conclusion == null ? void 0 : conclusion.toLocaleLowerCase("en-US")) {
        case "skipped":
          return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusAborted, null), " Aborted");
        case "timed_out":
          return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusWarning, null), " Timed out");
        case "failure":
          return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusError, null), " Error");
        default:
          return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusOK, null), " Completed");
      }
    default:
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusPending, null), " Pending");
  }
};

const useWorkflowRunJobs = (jobsUrl) => {
  const jobs = useAsync(async () => {
    if (jobsUrl === void 0) {
      return {
        total_count: 0,
        jobs: []
      };
    }
    const data = await fetch(jobsUrl).then((d) => d.json());
    return data;
  }, [jobsUrl]);
  return jobs;
};

const useWorkflowRunsDetails = ({
  hostname,
  owner,
  repo
}) => {
  const api = useApi(githubActionsApiRef);
  const {id} = useRouteRefParams(buildRouteRef);
  const details = useAsync(async () => {
    return repo && owner ? api.getWorkflowRun({
      hostname,
      owner,
      repo,
      id: parseInt(id, 10)
    }) : Promise.reject("No repo/owner provided");
  }, [repo, owner, id]);
  return details;
};

const useDownloadWorkflowRunLogs = ({
  hostname,
  owner,
  repo,
  id
}) => {
  const api = useApi(githubActionsApiRef);
  const details = useAsync(async () => {
    return repo && owner ? api.downloadJobLogsForWorkflowRun({
      hostname,
      owner,
      repo,
      runId: parseInt(id, 10)
    }) : Promise.reject("No repo/owner provided");
  }, [repo, owner, id]);
  return details;
};

const LazyLog = React.lazy(() => import('react-lazylog/build/LazyLog'));
const LinePart = React.lazy(() => import('react-lazylog/build/LinePart'));
const useStyles = makeStyles(() => ({
  button: {
    order: -1,
    marginRight: 0,
    marginLeft: "-20px"
  },
  modal: {
    display: "flex",
    alignItems: "center",
    width: "85%",
    height: "85%",
    justifyContent: "center",
    margin: "auto"
  },
  normalLog: {
    height: "75vh",
    width: "100%"
  },
  modalLog: {
    height: "100%",
    width: "100%"
  }
}));
const DisplayLog = ({
  jobLogs,
  className
}) => {
  return /* @__PURE__ */ React.createElement(Suspense, {
    fallback: /* @__PURE__ */ React.createElement(LinearProgress, null)
  }, /* @__PURE__ */ React.createElement("div", {
    className
  }, /* @__PURE__ */ React.createElement(LazyLog, {
    text: jobLogs != null ? jobLogs : "No Values Found",
    extraLines: 1,
    caseInsensitive: true,
    enableSearch: true,
    formatPart: (line) => {
      if (line.toLocaleLowerCase().includes("error") || line.toLocaleLowerCase().includes("failed") || line.toLocaleLowerCase().includes("failure")) {
        return /* @__PURE__ */ React.createElement(LinePart, {
          style: {color: "red"},
          part: {text: line}
        });
      }
      return line;
    }
  })));
};
const WorkflowRunLogs = ({
  entity,
  runId,
  inProgress
}) => {
  var _a;
  const config = useApi(configApiRef);
  const classes = useStyles();
  const projectName = useProjectName(entity);
  const hostname = readGitHubIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.github")) != null ? _a : [])[0].host;
  const [owner, repo] = projectName.value ? projectName.value.split("/") : [];
  const jobLogs = useDownloadWorkflowRunLogs({
    hostname,
    owner,
    repo,
    id: runId
  });
  const [open, setOpen] = React.useState(false);
  const handleOpen = () => {
    setOpen(true);
  };
  const handleClose = () => {
    setOpen(false);
  };
  return /* @__PURE__ */ React.createElement(Accordion, {
    TransitionProps: {unmountOnExit: true},
    disabled: inProgress
  }, /* @__PURE__ */ React.createElement(AccordionSummary, {
    expandIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, null),
    "aria-controls": `panel-${name}-content`,
    id: `panel-${name}-header`,
    IconButtonProps: {
      className: classes.button
    }
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "button"
  }, jobLogs.loading ? /* @__PURE__ */ React.createElement(CircularProgress, null) : "Job Log"), /* @__PURE__ */ React.createElement(Tooltip, {
    title: "Open Log",
    TransitionComponent: Zoom,
    arrow: true
  }, /* @__PURE__ */ React.createElement(DescriptionIcon, {
    onClick: (event) => {
      event.stopPropagation();
      handleOpen();
    },
    style: {marginLeft: "auto"}
  })), /* @__PURE__ */ React.createElement(Modal, {
    className: classes.modal,
    onClick: (event) => event.stopPropagation(),
    open,
    onClose: handleClose
  }, /* @__PURE__ */ React.createElement(Fade, {
    in: open
  }, /* @__PURE__ */ React.createElement(DisplayLog, {
    jobLogs: jobLogs.value || void 0,
    className: classes.modalLog
  })))), jobLogs.value && /* @__PURE__ */ React.createElement(DisplayLog, {
    jobLogs: jobLogs.value || void 0,
    className: classes.normalLog
  }));
};

const useStyles$1 = makeStyles((theme) => ({
  root: {
    maxWidth: 720,
    margin: theme.spacing(2)
  },
  title: {
    padding: theme.spacing(1, 0, 2, 0)
  },
  table: {
    padding: theme.spacing(1)
  },
  accordionDetails: {
    padding: 0
  },
  button: {
    order: -1,
    marginRight: 0,
    marginLeft: "-20px"
  },
  externalLinkIcon: {
    fontSize: "inherit",
    verticalAlign: "bottom"
  }
}));
const getElapsedTime = (start, end) => {
  const diff = moment(moment(end || moment()).diff(moment(start)));
  const timeElapsed = diff.format("m [minutes] s [seconds]");
  return timeElapsed;
};
const StepView = ({step}) => {
  var _a;
  return /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(ListItemText, {
    primary: step.name,
    secondary: getElapsedTime(step.started_at, step.completed_at)
  })), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(WorkflowRunStatus, {
    status: step.status.toLocaleUpperCase("en-US"),
    conclusion: (_a = step.conclusion) == null ? void 0 : _a.toLocaleUpperCase("en-US")
  })));
};
const JobListItem = ({
  job,
  className,
  entity
}) => {
  const classes = useStyles$1();
  return /* @__PURE__ */ React.createElement(Accordion, {
    TransitionProps: {unmountOnExit: true},
    className
  }, /* @__PURE__ */ React.createElement(AccordionSummary, {
    expandIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, null),
    "aria-controls": `panel-${name}-content`,
    id: `panel-${name}-header`,
    IconButtonProps: {
      className: classes.button
    }
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "button"
  }, job.name, " (", getElapsedTime(job.started_at, job.completed_at), ")")), /* @__PURE__ */ React.createElement(AccordionDetails, {
    className: classes.accordionDetails
  }, /* @__PURE__ */ React.createElement(TableContainer, null, /* @__PURE__ */ React.createElement(Table, null, job.steps.map((step) => /* @__PURE__ */ React.createElement(StepView, {
    key: step.number,
    step
  }))))), job.status === "queued" || job.status === "in_progress" ? /* @__PURE__ */ React.createElement(WorkflowRunLogs, {
    runId: job.id,
    inProgress: true,
    entity
  }) : /* @__PURE__ */ React.createElement(WorkflowRunLogs, {
    runId: job.id,
    inProgress: false,
    entity
  }));
};
const JobsList = ({jobs, entity}) => {
  const classes = useStyles$1();
  return /* @__PURE__ */ React.createElement(Box, null, jobs && jobs.total_count > 0 && jobs.jobs.map((job) => /* @__PURE__ */ React.createElement(JobListItem, {
    key: job.id,
    job,
    className: job.status !== "success" ? classes.failed : classes.success,
    entity
  })));
};
const WorkflowRunDetails = ({entity}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  const config = useApi(configApiRef);
  const projectName = useProjectName(entity);
  const hostname = readGitHubIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.github")) != null ? _a : [])[0].host;
  const [owner, repo] = projectName.value ? projectName.value.split("/") : [];
  const details = useWorkflowRunsDetails({hostname, owner, repo});
  const jobs = useWorkflowRunJobs((_b = details.value) == null ? void 0 : _b.jobs_url);
  const error = projectName.error || projectName.value && details.error;
  const classes = useStyles$1();
  if (error) {
    return /* @__PURE__ */ React.createElement(Typography, {
      variant: "h6",
      color: "error"
    }, "Failed to load build, ", error.message);
  } else if (projectName.loading || details.loading) {
    return /* @__PURE__ */ React.createElement(LinearProgress, null);
  }
  return /* @__PURE__ */ React.createElement("div", {
    className: classes.root
  }, /* @__PURE__ */ React.createElement(Box, {
    mb: 3
  }, /* @__PURE__ */ React.createElement(Breadcrumbs, {
    "aria-label": "breadcrumb"
  }, /* @__PURE__ */ React.createElement(Link, {
    to: ".."
  }, "Workflow runs"), /* @__PURE__ */ React.createElement(Typography, null, "Workflow run details"))), /* @__PURE__ */ React.createElement(TableContainer, {
    component: Paper,
    className: classes.table
  }, /* @__PURE__ */ React.createElement(Table, null, /* @__PURE__ */ React.createElement(TableBody, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Branch")), /* @__PURE__ */ React.createElement(TableCell, null, (_c = details.value) == null ? void 0 : _c.head_branch)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Message")), /* @__PURE__ */ React.createElement(TableCell, null, (_e = (_d = details.value) == null ? void 0 : _d.head_commit) == null ? void 0 : _e.message)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Commit ID")), /* @__PURE__ */ React.createElement(TableCell, null, (_g = (_f = details.value) == null ? void 0 : _f.head_commit) == null ? void 0 : _g.id)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Workflow")), /* @__PURE__ */ React.createElement(TableCell, null, (_h = details.value) == null ? void 0 : _h.name)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Status")), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(WorkflowRunStatus, {
    status: ((_i = details.value) == null ? void 0 : _i.status) || void 0,
    conclusion: ((_j = details.value) == null ? void 0 : _j.conclusion) || void 0
  }))), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Author")), /* @__PURE__ */ React.createElement(TableCell, null, `${(_m = (_l = (_k = details.value) == null ? void 0 : _k.head_commit) == null ? void 0 : _l.author) == null ? void 0 : _m.name} (${(_p = (_o = (_n = details.value) == null ? void 0 : _n.head_commit) == null ? void 0 : _o.author) == null ? void 0 : _p.email})`)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Links")), /* @__PURE__ */ React.createElement(TableCell, null, ((_q = details.value) == null ? void 0 : _q.html_url) && /* @__PURE__ */ React.createElement(Link$1, {
    target: "_blank",
    href: details.value.html_url
  }, "Workflow runs on GitHub", " ", /* @__PURE__ */ React.createElement(ExternalLinkIcon, {
    className: classes.externalLinkIcon
  })))), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, {
    colSpan: 2
  }, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Jobs"), jobs.loading ? /* @__PURE__ */ React.createElement(CircularProgress, null) : /* @__PURE__ */ React.createElement(JobsList, {
    jobs: jobs.value,
    entity
  })))))));
};

function useWorkflowRuns({
  hostname,
  owner,
  repo,
  branch,
  initialPageSize = 5
}) {
  const api = useApi(githubActionsApiRef);
  const errorApi = useApi(errorApiRef);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(0);
  const [pageSize, setPageSize] = useState(initialPageSize);
  const {loading, value: runs, retry, error} = useAsyncRetry(async () => {
    const workflowRunsData = await api.listWorkflowRuns({
      hostname,
      owner,
      repo,
      pageSize,
      page: page + 1,
      branch
    });
    setTotal(workflowRunsData.total_count);
    return workflowRunsData.workflow_runs.map((run) => {
      var _a, _b;
      return {
        workflowName: run.name,
        message: run.head_commit.message,
        id: `${run.id}`,
        onReRunClick: async () => {
          try {
            await api.reRunWorkflow({
              hostname,
              owner,
              repo,
              runId: run.id
            });
          } catch (e) {
            errorApi.post(e);
          }
        },
        source: {
          branchName: run.head_branch,
          commit: {
            hash: run.head_commit.id,
            url: (_b = (_a = run.head_repository) == null ? void 0 : _a.branches_url) == null ? void 0 : _b.replace("{/branch}", run.head_branch)
          }
        },
        status: run.status,
        conclusion: run.conclusion,
        url: run.url,
        githubUrl: run.html_url
      };
    });
  }, [page, pageSize, repo, owner]);
  return [
    {
      page,
      pageSize,
      loading,
      runs,
      projectName: `${owner}/${repo}`,
      total,
      error
    },
    {
      runs,
      setPage,
      setPageSize,
      retry
    }
  ];
}

const generatedColumns = [
  {
    title: "ID",
    field: "id",
    type: "numeric",
    width: "150px"
  },
  {
    title: "Message",
    field: "message",
    highlight: true,
    render: (row) => /* @__PURE__ */ React.createElement(Link$1, {
      component: Link$2,
      to: generatePath(buildRouteRef.path, {id: row.id})
    }, row.message)
  },
  {
    title: "Source",
    render: (row) => {
      var _a, _b;
      return /* @__PURE__ */ React.createElement(Typography, {
        variant: "body2",
        noWrap: true
      }, /* @__PURE__ */ React.createElement("p", null, (_a = row.source) == null ? void 0 : _a.branchName), /* @__PURE__ */ React.createElement("p", null, (_b = row.source) == null ? void 0 : _b.commit.hash));
    }
  },
  {
    title: "Workflow",
    field: "workflowName"
  },
  {
    title: "Status",
    width: "150px",
    render: (row) => /* @__PURE__ */ React.createElement(Box, {
      display: "flex",
      alignItems: "center"
    }, /* @__PURE__ */ React.createElement(WorkflowRunStatus, {
      status: row.status,
      conclusion: row.conclusion
    }))
  },
  {
    title: "Actions",
    render: (row) => /* @__PURE__ */ React.createElement(Tooltip, {
      title: "Rerun workflow"
    }, /* @__PURE__ */ React.createElement(IconButton, {
      onClick: row.onReRunClick
    }, /* @__PURE__ */ React.createElement(RetryIcon, null))),
    width: "10%"
  }
];
const WorkflowRunsTableView = ({
  projectName,
  loading,
  pageSize,
  page,
  retry,
  runs,
  onChangePage,
  onChangePageSize,
  total
}) => {
  return /* @__PURE__ */ React.createElement(Table$1, {
    isLoading: loading,
    options: {paging: true, pageSize, padding: "dense"},
    totalCount: total,
    page,
    actions: [
      {
        icon: () => /* @__PURE__ */ React.createElement(SyncIcon, null),
        tooltip: "Reload workflow runs",
        isFreeAction: true,
        onClick: () => retry()
      }
    ],
    data: runs != null ? runs : [],
    onChangePage,
    onChangeRowsPerPage: onChangePageSize,
    style: {width: "100%"},
    title: /* @__PURE__ */ React.createElement(Box, {
      display: "flex",
      alignItems: "center"
    }, /* @__PURE__ */ React.createElement(GitHubIcon, null), /* @__PURE__ */ React.createElement(Box, {
      mr: 1
    }), /* @__PURE__ */ React.createElement(Typography, {
      variant: "h6"
    }, projectName)),
    columns: generatedColumns
  });
};
const WorkflowRunsTable = ({
  entity,
  branch
}) => {
  var _a;
  const config = useApi(configApiRef);
  const {value: projectName, loading} = useProjectName(entity);
  const hostname = readGitHubIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.github")) != null ? _a : [])[0].host;
  const [owner, repo] = (projectName != null ? projectName : "/").split("/");
  const [
    {runs, ...tableProps},
    {retry, setPage, setPageSize}
  ] = useWorkflowRuns({
    hostname,
    owner,
    repo,
    branch
  });
  const githubHost = hostname || "github.com";
  return !runs ? /* @__PURE__ */ React.createElement(EmptyState, {
    missing: "data",
    title: "No Workflow Data",
    description: "This component has GitHub Actions enabled, but no data was found. Have you created any Workflows? Click the button below to create a new Workflow.",
    action: /* @__PURE__ */ React.createElement(Button, {
      variant: "contained",
      color: "primary",
      href: `https://${githubHost}/${projectName}/actions/new`
    }, "Create new Workflow")
  }) : /* @__PURE__ */ React.createElement(WorkflowRunsTableView, {
    ...tableProps,
    runs,
    loading: loading || tableProps.loading,
    retry,
    onChangePageSize: setPageSize,
    onChangePage: setPage
  });
};

const isGithubActionsAvailable = (entity) => {
  var _a;
  return Boolean((_a = entity.metadata.annotations) == null ? void 0 : _a[GITHUB_ACTIONS_ANNOTATION]);
};
const Router = (_props) => {
  const {entity} = useEntity();
  if (!isGithubActionsAvailable(entity)) {
    return /* @__PURE__ */ React.createElement(MissingAnnotationEmptyState, {
      annotation: GITHUB_ACTIONS_ANNOTATION
    });
  }
  return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
    path: `/${rootRouteRef.path}`,
    element: /* @__PURE__ */ React.createElement(WorkflowRunsTable, {
      entity
    })
  }), /* @__PURE__ */ React.createElement(Route, {
    path: `/${buildRouteRef.path}`,
    element: /* @__PURE__ */ React.createElement(WorkflowRunDetails, {
      entity
    })
  }), ")");
};

var Router$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isGithubActionsAvailable: isGithubActionsAvailable,
  Router: Router
});

const useStyles$2 = makeStyles({
  externalLinkIcon: {
    fontSize: "inherit",
    verticalAlign: "bottom"
  }
});
const WidgetContent = ({
  error,
  loading,
  lastRun,
  branch
}) => {
  const classes = useStyles$2();
  if (error)
    return /* @__PURE__ */ React.createElement(Typography, null, "Couldn't fetch latest ", branch, " run");
  if (loading)
    return /* @__PURE__ */ React.createElement(LinearProgress, null);
  return /* @__PURE__ */ React.createElement(StructuredMetadataTable, {
    metadata: {
      status: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(WorkflowRunStatus, {
        status: lastRun.status,
        conclusion: lastRun.conclusion
      })),
      message: lastRun.message,
      url: /* @__PURE__ */ React.createElement(Link$1, {
        href: lastRun.githubUrl,
        target: "_blank"
      }, "See more on GitHub", " ", /* @__PURE__ */ React.createElement(ExternalLinkIcon, {
        className: classes.externalLinkIcon
      }))
    }
  });
};
const LatestWorkflowRunCard = ({
  branch = "master",
  variant
}) => {
  var _a, _b, _c, _d;
  const {entity} = useEntity();
  const config = useApi(configApiRef);
  const errorApi = useApi(errorApiRef);
  const hostname = readGitHubIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.github")) != null ? _a : [])[0].host;
  const [owner, repo] = ((_c = (_b = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _b[GITHUB_ACTIONS_ANNOTATION]) != null ? _c : "/").split("/");
  const [{runs, loading, error}] = useWorkflowRuns({
    hostname,
    owner,
    repo,
    branch
  });
  const lastRun = (_d = runs == null ? void 0 : runs[0]) != null ? _d : {};
  useEffect(() => {
    if (error) {
      errorApi.post(error);
    }
  }, [error, errorApi]);
  return /* @__PURE__ */ React.createElement(InfoCard, {
    title: `Last ${branch} build`,
    variant
  }, /* @__PURE__ */ React.createElement(WidgetContent, {
    error,
    loading,
    branch,
    lastRun
  }));
};
const LatestWorkflowsForBranchCard = ({
  branch = "master",
  variant
}) => {
  const {entity} = useEntity();
  return /* @__PURE__ */ React.createElement(InfoCard, {
    title: `Last ${branch} build`,
    variant
  }, /* @__PURE__ */ React.createElement(WorkflowRunsTable, {
    branch,
    entity
  }));
};

const firstLine = (message) => message.split("\n")[0];
const RecentWorkflowRunsCard = ({
  branch,
  dense = false,
  limit = 5,
  variant
}) => {
  var _a, _b, _c;
  const {entity} = useEntity();
  const config = useApi(configApiRef);
  const errorApi = useApi(errorApiRef);
  const hostname = readGitHubIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.github")) != null ? _a : [])[0].host;
  const [owner, repo] = ((_c = (_b = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _b[GITHUB_ACTIONS_ANNOTATION]) != null ? _c : "/").split("/");
  const [{runs = [], loading, error}] = useWorkflowRuns({
    hostname,
    owner,
    repo,
    branch,
    initialPageSize: limit
  });
  useEffect(() => {
    if (error) {
      errorApi.post(error);
    }
  }, [error, errorApi]);
  const githubHost = hostname || "github.com";
  return /* @__PURE__ */ React.createElement(InfoCard, {
    title: "Recent Workflow Runs",
    subheader: branch ? `Branch: ${branch}` : "All Branches",
    noPadding: true,
    variant
  }, !runs.length ? /* @__PURE__ */ React.createElement("div", {
    style: {textAlign: "center"}
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "body1"
  }, "This component has GitHub Actions enabled, but no workflows were found."), /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2"
  }, /* @__PURE__ */ React.createElement(Link, {
    to: `https://${githubHost}/${owner}/${repo}/actions/new`
  }, "Create a new workflow"))) : /* @__PURE__ */ React.createElement(Table$1, {
    isLoading: loading,
    options: {
      search: false,
      paging: false,
      padding: dense ? "dense" : "default",
      toolbar: false
    },
    columns: [
      {
        title: "Commit Message",
        field: "message",
        render: (data) => /* @__PURE__ */ React.createElement(Link, {
          component: Link$2,
          to: generatePath("./ci-cd/:id", {id: data.id})
        }, firstLine(data.message))
      },
      {title: "Branch", field: "source.branchName"},
      {title: "Status", field: "status", render: WorkflowRunStatus}
    ],
    data: runs
  }));
};

export { BuildStatus, EntityGithubActionsContent, EntityLatestGithubActionRunCard, EntityLatestGithubActionsForBranchCard, EntityRecentGithubActionsRunsCard, GITHUB_ACTIONS_ANNOTATION, GithubActionsClient, LatestWorkflowRunCard, LatestWorkflowsForBranchCard, RecentWorkflowRunsCard, Router, githubActionsApiRef, githubActionsPlugin, isGithubActionsAvailable, isGithubActionsAvailable as isPluginApplicableToEntity, githubActionsPlugin as plugin };
//# sourceMappingURL=index.esm.js.map
