{"version":3,"file":"index-bc9fd18e.esm.js","sources":["../../src/api.ts","../../src/routes.ts","../../src/plugin.ts"],"sourcesContent":["/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EntityName } from '@backstage/catalog-model';\nimport { JsonObject } from '@backstage/config';\nimport {\n  createApiRef,\n  DiscoveryApi,\n  IdentityApi,\n  Observable,\n} from '@backstage/core';\nimport { ResponseError } from '@backstage/errors';\nimport { ScmIntegrationRegistry } from '@backstage/integration';\nimport ObservableImpl from 'zen-observable';\nimport { ListActionsResponse, ScaffolderTask, Status } from './types';\n\nexport const scaffolderApiRef = createApiRef<ScaffolderApi>({\n  id: 'plugin.scaffolder.service',\n  description: 'Used to make requests towards the scaffolder backend',\n});\n\ntype TemplateParameterSchema = {\n  title: string;\n  steps: Array<{\n    title: string;\n    schema: JsonObject;\n  }>;\n};\n\nexport type LogEvent = {\n  type: 'log' | 'completion';\n  body: {\n    message: string;\n    stepId?: string;\n    status?: Status;\n  };\n  createdAt: string;\n  id: string;\n  taskId: string;\n};\n\nexport interface ScaffolderApi {\n  getTemplateParameterSchema(\n    templateName: EntityName,\n  ): Promise<TemplateParameterSchema>;\n\n  /**\n   * Executes the scaffolding of a component, given a template and its\n   * parameter values.\n   *\n   * @param templateName Name of the Template entity for the scaffolder to use. New project is going to be created out of this template.\n   * @param values Parameters for the template, e.g. name, description\n   */\n  scaffold(templateName: string, values: Record<string, any>): Promise<string>;\n\n  getTask(taskId: string): Promise<ScaffolderTask>;\n\n  getIntegrationsList(options: {\n    allowedHosts: string[];\n  }): Promise<{ type: string; title: string; host: string }[]>;\n\n  // Returns a list of all installed actions.\n  listActions(): Promise<ListActionsResponse>;\n\n  streamLogs({\n    taskId,\n    after,\n  }: {\n    taskId: string;\n    after?: number;\n  }): Observable<LogEvent>;\n}\n\nexport class ScaffolderClient implements ScaffolderApi {\n  private readonly discoveryApi: DiscoveryApi;\n  private readonly identityApi: IdentityApi;\n  private readonly scmIntegrationsApi: ScmIntegrationRegistry;\n\n  constructor(options: {\n    discoveryApi: DiscoveryApi;\n    identityApi: IdentityApi;\n    scmIntegrationsApi: ScmIntegrationRegistry;\n  }) {\n    this.discoveryApi = options.discoveryApi;\n    this.identityApi = options.identityApi;\n    this.scmIntegrationsApi = options.scmIntegrationsApi;\n  }\n\n  async getIntegrationsList(options: { allowedHosts: string[] }) {\n    return [\n      ...this.scmIntegrationsApi.azure.list(),\n      ...this.scmIntegrationsApi.bitbucket.list(),\n      ...this.scmIntegrationsApi.github.list(),\n      ...this.scmIntegrationsApi.gitlab.list(),\n    ]\n      .map(c => ({ type: c.type, title: c.title, host: c.config.host }))\n      .filter(c => options.allowedHosts.includes(c.host));\n  }\n\n  async getTemplateParameterSchema(\n    templateName: EntityName,\n  ): Promise<TemplateParameterSchema> {\n    const { namespace, kind, name } = templateName;\n\n    const token = await this.identityApi.getIdToken();\n    const baseUrl = await this.discoveryApi.getBaseUrl('scaffolder');\n    const templatePath = [namespace, kind, name]\n      .map(s => encodeURIComponent(s))\n      .join('/');\n    const url = `${baseUrl}/v2/templates/${templatePath}/parameter-schema`;\n\n    const response = await fetch(url, {\n      headers: {\n        ...(token && { Authorization: `Bearer ${token}` }),\n      },\n    });\n\n    if (!response.ok) {\n      throw ResponseError.fromResponse(response);\n    }\n\n    const schema: TemplateParameterSchema = await response.json();\n    return schema;\n  }\n\n  /**\n   * Executes the scaffolding of a component, given a template and its\n   * parameter values.\n   *\n   * @param templateName Template name for the scaffolder to use. New project is going to be created out of this template.\n   * @param values Parameters for the template, e.g. name, description\n   */\n  async scaffold(\n    templateName: string,\n    values: Record<string, any>,\n  ): Promise<string> {\n    const token = await this.identityApi.getIdToken();\n    const url = `${await this.discoveryApi.getBaseUrl('scaffolder')}/v2/tasks`;\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        ...(token && { Authorization: `Bearer ${token}` }),\n      },\n      body: JSON.stringify({ templateName, values: { ...values } }),\n    });\n\n    if (response.status !== 201) {\n      const status = `${response.status} ${response.statusText}`;\n      const body = await response.text();\n      throw new Error(`Backend request failed, ${status} ${body.trim()}`);\n    }\n\n    const { id } = (await response.json()) as { id: string };\n    return id;\n  }\n\n  async getTask(taskId: string) {\n    const token = await this.identityApi.getIdToken();\n    const baseUrl = await this.discoveryApi.getBaseUrl('scaffolder');\n    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}`;\n    const response = await fetch(url, {\n      headers: token ? { Authorization: `Bearer ${token}` } : {},\n    });\n\n    if (!response.ok) {\n      throw ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n\n  streamLogs({\n    taskId,\n    after,\n  }: {\n    taskId: string;\n    after?: number;\n  }): Observable<LogEvent> {\n    return new ObservableImpl(subscriber => {\n      const params = new URLSearchParams();\n      if (after !== undefined) {\n        params.set('after', String(Number(after)));\n      }\n\n      this.discoveryApi.getBaseUrl('scaffolder').then(\n        baseUrl => {\n          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(\n            taskId,\n          )}/eventstream`;\n          const eventSource = new EventSource(url, { withCredentials: true });\n          eventSource.addEventListener('log', (event: any) => {\n            if (event.data) {\n              try {\n                subscriber.next(JSON.parse(event.data));\n              } catch (ex) {\n                subscriber.error(ex);\n              }\n            }\n          });\n          eventSource.addEventListener('completion', (event: any) => {\n            if (event.data) {\n              try {\n                subscriber.next(JSON.parse(event.data));\n              } catch (ex) {\n                subscriber.error(ex);\n              }\n            }\n            eventSource.close();\n            subscriber.complete();\n          });\n          eventSource.addEventListener('error', event => {\n            subscriber.error(event);\n          });\n        },\n        error => {\n          subscriber.error(error);\n        },\n      );\n    });\n  }\n\n  /**\n   * @returns ListActionsResponse containing all registered actions.\n   */\n  async listActions(): Promise<ListActionsResponse> {\n    const baseUrl = await this.discoveryApi.getBaseUrl('scaffolder');\n    const response = await fetch(`${baseUrl}/v2/actions`);\n\n    if (!response.ok) {\n      throw ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createExternalRouteRef, createRouteRef } from '@backstage/core';\n\nexport const registerComponentRouteRef = createExternalRouteRef({\n  id: 'register-component',\n  optional: true,\n});\n\nexport const rootRouteRef = createRouteRef({\n  title: 'Create new entity',\n});\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createApiFactory,\n  createPlugin,\n  createRoutableExtension,\n  discoveryApiRef,\n  identityApiRef,\n} from '@backstage/core';\nimport { scmIntegrationsApiRef } from '@backstage/integration-react';\nimport { scaffolderApiRef, ScaffolderClient } from './api';\nimport { rootRouteRef, registerComponentRouteRef } from './routes';\n\nexport const scaffolderPlugin = createPlugin({\n  id: 'scaffolder',\n  apis: [\n    createApiFactory({\n      api: scaffolderApiRef,\n      deps: {\n        discoveryApi: discoveryApiRef,\n        identityApi: identityApiRef,\n        scmIntegrationsApi: scmIntegrationsApiRef,\n      },\n      factory: ({ discoveryApi, identityApi, scmIntegrationsApi }) =>\n        new ScaffolderClient({ discoveryApi, identityApi, scmIntegrationsApi }),\n    }),\n  ],\n  routes: {\n    root: rootRouteRef,\n  },\n  externalRoutes: {\n    registerComponent: registerComponentRouteRef,\n  },\n});\n\nexport const ScaffolderPage = scaffolderPlugin.provide(\n  createRoutableExtension({\n    component: () => import('./components/Router').then(m => m.Router),\n    mountPoint: rootRouteRef,\n  }),\n);\n"],"names":[],"mappings":"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"}