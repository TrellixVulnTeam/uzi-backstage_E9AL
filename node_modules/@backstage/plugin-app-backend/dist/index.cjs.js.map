{"version":3,"file":"index.cjs.js","sources":["../src/lib/config.ts","../src/service/router.ts"],"sourcesContent":["/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport { resolve as resolvePath } from 'path';\nimport { Logger } from 'winston';\nimport { AppConfig, Config, JsonObject } from '@backstage/config';\nimport { loadConfigSchema, readEnvConfig } from '@backstage/config-loader';\n\ntype InjectOptions = {\n  appConfigs: AppConfig[];\n  // Directory of the static JS files to search for file to inject\n  staticDir: string;\n  logger: Logger;\n};\n\n/**\n * Injects configs into the app bundle, replacing any existing injected config.\n */\nexport async function injectConfig(options: InjectOptions) {\n  const { staticDir, logger, appConfigs } = options;\n\n  const files = await fs.readdir(staticDir);\n  const jsFiles = files.filter(file => file.endsWith('.js'));\n\n  const escapedData = JSON.stringify(appConfigs).replace(/(\"|'|\\\\)/g, '\\\\$1');\n  const injected = `/*__APP_INJECTED_CONFIG_MARKER__*/\"${escapedData}\"/*__INJECTED_END__*/`;\n\n  for (const jsFile of jsFiles) {\n    const path = resolvePath(staticDir, jsFile);\n\n    const content = await fs.readFile(path, 'utf8');\n    if (content.includes('__APP_INJECTED_RUNTIME_CONFIG__')) {\n      logger.info(`Injecting env config into ${jsFile}`);\n\n      const newContent = content.replace(\n        '\"__APP_INJECTED_RUNTIME_CONFIG__\"',\n        injected,\n      );\n      await fs.writeFile(path, newContent, 'utf8');\n      return;\n    } else if (content.includes('__APP_INJECTED_CONFIG_MARKER__')) {\n      logger.info(`Replacing injected env config in ${jsFile}`);\n\n      const newContent = content.replace(\n        /\\/\\*__APP_INJECTED_CONFIG_MARKER__\\*\\/.*\\/\\*__INJECTED_END__\\*\\//,\n        injected,\n      );\n      await fs.writeFile(path, newContent, 'utf8');\n      return;\n    }\n  }\n  logger.info('Env config not injected');\n}\n\ntype ReadOptions = {\n  env: { [name: string]: string | undefined };\n  appDistDir: string;\n  config: Config;\n};\n\n/**\n * Read config from environment and process the backend config using the\n * schema that is embedded in the frontend build.\n */\nexport async function readConfigs(options: ReadOptions): Promise<AppConfig[]> {\n  const { env, appDistDir, config } = options;\n\n  const appConfigs = readEnvConfig(env);\n\n  const schemaPath = resolvePath(appDistDir, '.config-schema.json');\n  if (await fs.pathExists(schemaPath)) {\n    const serializedSchema = await fs.readJson(schemaPath);\n\n    try {\n      const schema = await loadConfigSchema({ serialized: serializedSchema });\n\n      const frontendConfigs = await schema.process(\n        [{ data: config.get() as JsonObject, context: 'app' }],\n        { visibility: ['frontend'] },\n      );\n      appConfigs.push(...frontendConfigs);\n    } catch (error) {\n      throw new Error(\n        'Invalid app bundle schema. If this error is unexpected you need to run `yarn build` in the app. ' +\n          `If that doesn't help you should make sure your config schema is correct and rebuild the app bundle again. ` +\n          `Caused by the following schema error, ${error}`,\n      );\n    }\n  }\n\n  return appConfigs;\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { notFoundHandler, resolvePackagePath } from '@backstage/backend-common';\nimport { Config } from '@backstage/config';\nimport express from 'express';\nimport Router from 'express-promise-router';\nimport fs from 'fs-extra';\nimport { resolve as resolvePath } from 'path';\nimport { Logger } from 'winston';\nimport { injectConfig, readConfigs } from '../lib/config';\n\n// express uses mime v1 while we only have types for mime v2\ntype Mime = { lookup(arg0: string): string };\n\nexport interface RouterOptions {\n  config: Config;\n  logger: Logger;\n\n  /**\n   * The name of the app package that content should be served from. The same app package should be\n   * added as a dependency to the backend package in order for it to be accessible at runtime.\n   *\n   * In a typical setup with a single app package this would be set to 'app'.\n   */\n  appPackageName: string;\n\n  /**\n   * A request handler to handle requests for static content that are not present in the app bundle.\n   *\n   * This can be used to avoid issues with clients on older deployment versions trying to access lazy\n   * loaded content that is no longer present. Typically the requests would fall back to a long-term\n   * object store where all recently deployed versions of the app are present.\n   */\n  staticFallbackHandler?: express.Handler;\n\n  /**\n   * Disables the configuration injection. This can be useful if you're running in an environment\n   * with a read-only filesystem, or for some other reason don't want configuration to be injected.\n   *\n   * Note that this will cause the configuration used when building the app bundle to be used, unless\n   * a separate configuration loading strategy is set up.\n   *\n   * This also disables configuration injection though `APP_CONFIG_` environment variables.\n   */\n  disableConfigInjection?: boolean;\n}\n\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const { config, logger, appPackageName, staticFallbackHandler } = options;\n\n  const appDistDir = resolvePackagePath(appPackageName, 'dist');\n  const staticDir = resolvePath(appDistDir, 'static');\n\n  if (!(await fs.pathExists(staticDir))) {\n    logger.warn(\n      `Can't serve static app content from ${staticDir}, directory doesn't exist`,\n    );\n\n    return Router();\n  }\n\n  logger.info(`Serving static app content from ${appDistDir}`);\n\n  if (!options.disableConfigInjection) {\n    const appConfigs = await readConfigs({\n      config,\n      appDistDir,\n      env: process.env,\n    });\n\n    await injectConfig({ appConfigs, logger, staticDir });\n  }\n\n  const router = Router();\n\n  // Use a separate router for static content so that a fallback can be provided by backend\n  const staticRouter = Router();\n  staticRouter.use(express.static(resolvePath(appDistDir, 'static')));\n  if (staticFallbackHandler) {\n    staticRouter.use(staticFallbackHandler);\n  }\n  staticRouter.use(notFoundHandler());\n\n  router.use('/static', staticRouter);\n  router.use(\n    express.static(appDistDir, {\n      setHeaders: (res, path) => {\n        // The Cache-Control header instructs the browser to not cache html files since it might\n        // link to static assets from recently deployed versions.\n        if (\n          ((express.static.mime as unknown) as Mime).lookup(path) ===\n          'text/html'\n        ) {\n          res.setHeader('Cache-Control', 'no-store, max-age=0');\n        }\n      },\n    }),\n  );\n  router.get('/*', (_req, res) => {\n    res.sendFile(resolvePath(appDistDir, 'index.html'), {\n      headers: {\n        // The Cache-Control header instructs the browser to not cache the index.html since it might\n        // link to static assets from recently deployed versions.\n        'cache-control': 'no-store, max-age=0',\n      },\n    });\n  });\n\n  return router;\n}\n"],"names":["fs","path","resolvePath","readEnvConfig","loadConfigSchema","resolvePackagePath","Router","express","notFoundHandler"],"mappings":";;;;;;;;;;;;;;;;;4BAgCmC,SAAwB;AACzD,QAAM,CAAE,WAAW,QAAQ,cAAe;AAE1C,QAAM,QAAQ,MAAMA,uBAAG,QAAQ;AAC/B,QAAM,UAAU,MAAM,OAAO,UAAQ,KAAK,SAAS;AAEnD,QAAM,cAAc,KAAK,UAAU,YAAY,QAAQ,aAAa;AACpE,QAAM,WAAW,sCAAsC;AAEvD,aAAW,UAAU,SAAS;AAC5B,UAAMC,SAAOC,aAAY,WAAW;AAEpC,UAAM,UAAU,MAAMF,uBAAG,SAASC,QAAM;AACxC,QAAI,QAAQ,SAAS,oCAAoC;AACvD,aAAO,KAAK,6BAA6B;AAEzC,YAAM,aAAa,QAAQ,QACzB,qCACA;AAEF,YAAMD,uBAAG,UAAUC,QAAM,YAAY;AACrC;AAAA,eACS,QAAQ,SAAS,mCAAmC;AAC7D,aAAO,KAAK,oCAAoC;AAEhD,YAAM,aAAa,QAAQ,QACzB,oEACA;AAEF,YAAMD,uBAAG,UAAUC,QAAM,YAAY;AACrC;AAAA;AAAA;AAGJ,SAAO,KAAK;AAAA;2BAaoB,SAA4C;AAC5E,QAAM,CAAE,KAAK,YAAY,UAAW;AAEpC,QAAM,aAAaE,2BAAc;AAEjC,QAAM,aAAaD,aAAY,YAAY;AAC3C,MAAI,MAAMF,uBAAG,WAAW,aAAa;AACnC,UAAM,mBAAmB,MAAMA,uBAAG,SAAS;AAE3C,QAAI;AACF,YAAM,SAAS,MAAMI,8BAAiB,CAAE,YAAY;AAEpD,YAAM,kBAAkB,MAAM,OAAO,QACnC,CAAC,CAAE,MAAM,OAAO,OAAqB,SAAS,SAC9C,CAAE,YAAY,CAAC;AAEjB,iBAAW,KAAK,GAAG;AAAA,aACZ,OAAP;AACA,YAAM,IAAI,MACR,qPAE2C;AAAA;AAAA;AAKjD,SAAO;AAAA;;4BC1CP,SACyB;AACzB,QAAM,CAAE,QAAQ,QAAQ,gBAAgB,yBAA0B;AAElE,QAAM,aAAaC,iCAAmB,gBAAgB;AACtD,QAAM,YAAYH,aAAY,YAAY;AAE1C,MAAI,CAAE,MAAMF,uBAAG,WAAW,YAAa;AACrC,WAAO,KACL,uCAAuC;AAGzC,WAAOM;AAAA;AAGT,SAAO,KAAK,mCAAmC;AAE/C,MAAI,CAAC,QAAQ,wBAAwB;AACnC,UAAM,aAAa,MAAM,YAAY;AAAA,MACnC;AAAA,MACA;AAAA,MACA,KAAK,QAAQ;AAAA;AAGf,UAAM,aAAa,CAAE,YAAY,QAAQ;AAAA;AAG3C,QAAM,SAASA;AAGf,QAAM,eAAeA;AACrB,eAAa,IAAIC,4BAAQ,OAAOL,aAAY,YAAY;AACxD,MAAI,uBAAuB;AACzB,iBAAa,IAAI;AAAA;AAEnB,eAAa,IAAIM;AAEjB,SAAO,IAAI,WAAW;AACtB,SAAO,IACLD,4BAAQ,OAAO,YAAY;AAAA,IACzB,YAAY,CAAC,KAAK,SAAS;AAGzB,UACIA,4BAAQ,OAAO,KAA0B,OAAO,UAClD,aACA;AACA,YAAI,UAAU,iBAAiB;AAAA;AAAA;AAAA;AAKvC,SAAO,IAAI,MAAM,CAAC,MAAM,QAAQ;AAC9B,QAAI,SAASL,aAAY,YAAY,eAAe;AAAA,MAClD,SAAS;AAAA,QAGP,iBAAiB;AAAA;AAAA;AAAA;AAKvB,SAAO;AAAA;;;;"}