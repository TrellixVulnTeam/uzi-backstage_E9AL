import express from 'express';
import { Logger } from 'winston';
import { PluginEndpointDiscovery, PluginDatabaseManager } from '@backstage/backend-common';
import { CatalogApi } from '@backstage/catalog-client';
import { Config } from '@backstage/config';
import { JSONWebKey } from 'jose';
import { Profile } from 'passport';

/** Represents any form of serializable JWK */
interface AnyJWK extends Record<string, string> {
    use: 'sig';
    alg: string;
    kid: string;
    kty: string;
}
/** Parameters used to issue new ID Tokens */
declare type TokenParams = {
    /** The claims that will be embedded within the token */
    claims: {
        /** The token subject, i.e. User ID */
        sub: string;
    };
};
/**
 * A TokenIssuer is able to issue verifiable ID Tokens on demand.
 */
declare type TokenIssuer = {
    /**
     * Issues a new ID Token
     */
    issueToken(params: TokenParams): Promise<string>;
    /**
     * List all public keys that are currently being used to sign tokens, or have been used
     * in the past within the token expiration time, including a grace period.
     */
    listPublicKeys(): Promise<{
        keys: AnyJWK[];
    }>;
};

declare type AuthProviderConfig = {
    /**
     * The protocol://domain[:port] where the app is hosted. This is used to construct the
     * callbackURL to redirect to once the user signs in to the auth provider.
     */
    baseUrl: string;
    /**
     * The base URL of the app as provided by app.baseUrl
     */
    appUrl: string;
};
declare type RedirectInfo = {
    /**
     * URL to redirect to
     */
    url: string;
    /**
     * Status code to use for the redirect
     */
    status?: number;
};
/**
 * Any Auth provider needs to implement this interface which handles the routes in the
 * auth backend. Any auth API requests from the frontend reaches these methods.
 *
 * The routes in the auth backend API are tied to these methods like below
 *
 * /auth/[provider]/start -> start
 * /auth/[provider]/handler/frame -> frameHandler
 * /auth/[provider]/refresh -> refresh
 * /auth/[provider]/logout -> logout
 */
interface AuthProviderRouteHandlers {
    /**
     * Handles the start route of the API. This initiates a sign in request with an auth provider.
     *
     * Request
     * - scopes for the auth request (Optional)
     * Response
     * - redirect to the auth provider for the user to sign in or consent.
     * - sets a nonce cookie and also pass the nonce as 'state' query parameter in the redirect request
     *
     * @param {express.Request} req
     * @param {express.Response} res
     */
    start(req: express.Request, res: express.Response): Promise<void>;
    /**
     * Once the user signs in or consents in the OAuth screen, the auth provider redirects to the
     * callbackURL which is handled by this method.
     *
     * Request
     * - to contain a nonce cookie and a 'state' query parameter
     * Response
     * - postMessage to the window with a payload that contains accessToken, expiryInSeconds?, idToken? and scope.
     * - sets a refresh token cookie if the auth provider supports refresh tokens
     *
     * @param {express.Request} req
     * @param {express.Response} res
     */
    frameHandler(req: express.Request, res: express.Response): Promise<void>;
    /**
     * (Optional) If the auth provider supports refresh tokens then this method handles
     * requests to get a new access token.
     *
     * Request
     * - to contain a refresh token cookie and scope (Optional) query parameter.
     * Response
     * - payload with accessToken, expiryInSeconds?, idToken?, scope and user profile information.
     *
     * @param {express.Request} req
     * @param {express.Response} res
     */
    refresh?(req: express.Request, res: express.Response): Promise<void>;
    /**
     * (Optional) Handles sign out requests
     *
     * Response
     * - removes the refresh token cookie
     *
     * @param {express.Request} req
     * @param {express.Response} res
     */
    logout?(req: express.Request, res: express.Response): Promise<void>;
}
/**
 * EXPERIMENTAL - this will almost certainly break in a future release.
 *
 * Used to resolve an identity from auth information in some auth providers.
 */
declare type ExperimentalIdentityResolver = (
/**
 * An object containing information specific to the auth provider.
 */
payload: object, catalogApi: CatalogApi) => Promise<AuthResponse<any>>;
declare type AuthProviderFactoryOptions = {
    providerId: string;
    globalConfig: AuthProviderConfig;
    config: Config;
    logger: Logger;
    tokenIssuer: TokenIssuer;
    discovery: PluginEndpointDiscovery;
    catalogApi: CatalogApi;
    identityResolver?: ExperimentalIdentityResolver;
};
declare type AuthProviderFactory = (options: AuthProviderFactoryOptions) => AuthProviderRouteHandlers;
declare type AuthResponse<ProviderInfo> = {
    providerInfo: ProviderInfo;
    profile: ProfileInfo;
    backstageIdentity?: BackstageIdentity;
};
declare type BackstageIdentity = {
    /**
     * The backstage user ID.
     */
    id: string;
    /**
     * An ID token that can be used to authenticate the user within Backstage.
     */
    idToken?: string;
};
/**
 * Used to display login information to user, i.e. sidebar popup.
 *
 * It is also temporarily used as the profile of the signed-in user's Backstage
 * identity, but we want to replace that with data from identity and/org catalog service
 */
declare type ProfileInfo = {
    /**
     * Email ID of the signed in user.
     */
    email?: string;
    /**
     * Display name that can be presented to the signed in user.
     */
    displayName?: string;
    /**
     * URL to an image that can be used as the display image or avatar of the
     * signed in user.
     */
    picture?: string;
};

declare const factories: {
    [providerId: string]: AuthProviderFactory;
};

declare type ProviderFactories = {
    [s: string]: AuthProviderFactory;
};
interface RouterOptions {
    logger: Logger;
    database: PluginDatabaseManager;
    config: Config;
    discovery: PluginEndpointDiscovery;
    providerFactories?: ProviderFactories;
}
declare function createRouter({ logger, config, discovery, database, providerFactories, }: RouterOptions): Promise<express.Router>;

/**
 * A identity client to interact with auth-backend
 * and authenticate backstage identity tokens
 *
 * @experimental This is not a stable API yet
 */
declare class IdentityClient {
    private readonly discovery;
    private readonly issuer;
    private keyStore;
    private keyStoreUpdated;
    constructor(options: {
        discovery: PluginEndpointDiscovery;
        issuer: string;
    });
    /**
     * Verifies the given backstage identity token
     * Returns a BackstageIdentity (user) matching the token.
     * The method throws an error if verification fails.
     */
    authenticate(token: string | undefined): Promise<BackstageIdentity>;
    /**
     * Parses the given authorization header and returns
     * the bearer token, or null if no bearer token is given
     */
    static getBearerToken(authorizationHeader: string | undefined): string | undefined;
    /**
     * Returns the public signing key matching the given jwt token,
     * or null if no matching key was found
     */
    private getKey;
    /**
     * Lists public part of keys used to sign Backstage Identity tokens
     */
    listPublicKeys(): Promise<{
        keys: JSONWebKey[];
    }>;
    /**
     * Fetches public keys and caches them locally
     */
    private refreshKeyStore;
}

/**
 * Payload sent as a post message after the auth request is complete.
 * If successful then has a valid payload with Auth information else contains an error.
 */
declare type WebMessageResponse = {
    type: 'authorization_response';
    response: AuthResponse<unknown>;
} | {
    type: 'authorization_response';
    error: Error;
};

declare const postMessageResponse: (res: express.Response, appOrigin: string, response: WebMessageResponse) => void;
declare const ensuresXRequestedWith: (req: express.Request) => boolean;

declare class OAuthEnvironmentHandler implements AuthProviderRouteHandlers {
    private readonly handlers;
    static mapConfig(config: Config, factoryFunc: (envConfig: Config) => AuthProviderRouteHandlers): OAuthEnvironmentHandler;
    constructor(handlers: Map<string, AuthProviderRouteHandlers>);
    start(req: express.Request, res: express.Response): Promise<void>;
    frameHandler(req: express.Request, res: express.Response): Promise<void>;
    refresh(req: express.Request, res: express.Response): Promise<void>;
    logout(req: express.Request, res: express.Response): Promise<void>;
    private getRequestFromEnv;
    private getProviderForEnv;
}

/**
 * Common options for passport.js-based OAuth providers
 */
declare type OAuthProviderOptions = {
    /**
     * Client ID of the auth provider.
     */
    clientId: string;
    /**
     * Client Secret of the auth provider.
     */
    clientSecret: string;
    /**
     * Callback URL to be passed to the auth provider to redirect to after the user signs in.
     */
    callbackUrl: string;
};
declare type OAuthResult = {
    fullProfile: Profile;
    params: {
        id_token?: string;
        scope: string;
        expires_in: number;
    };
    accessToken: string;
    refreshToken?: string;
};
declare type OAuthResponse = AuthResponse<OAuthProviderInfo>;
declare type OAuthProviderInfo = {
    /**
     * An access token issued for the signed in user.
     */
    accessToken: string;
    /**
     * (Optional) Id token issued for the signed in user.
     */
    idToken?: string;
    /**
     * Expiry of the access token in seconds.
     */
    expiresInSeconds?: number;
    /**
     * Scopes granted for the access token.
     */
    scope: string;
    /**
     * A refresh token issued for the signed in user
     */
    refreshToken?: string;
};
declare type OAuthState = {
    nonce: string;
    env: string;
};
declare type OAuthStartRequest = express.Request<{}> & {
    scope: string;
    state: OAuthState;
};
declare type OAuthRefreshRequest = express.Request<{}> & {
    scope: string;
    refreshToken: string;
};
/**
 * Any OAuth provider needs to implement this interface which has provider specific
 * handlers for different methods to perform authentication, get access tokens,
 * refresh tokens and perform sign out.
 */
interface OAuthHandlers {
    /**
     * This method initiates a sign in request with an auth provider.
     * @param {express.Request} req
     * @param options
     */
    start(req: OAuthStartRequest): Promise<RedirectInfo>;
    /**
     * Handles the redirect from the auth provider when the user has signed in.
     * @param {express.Request} req
     */
    handler(req: express.Request): Promise<{
        response: AuthResponse<OAuthProviderInfo>;
        refreshToken?: string;
    }>;
    /**
     * (Optional) Given a refresh token and scope fetches a new access token from the auth provider.
     * @param {string} refreshToken
     * @param {string} scope
     */
    refresh?(req: OAuthRefreshRequest): Promise<AuthResponse<OAuthProviderInfo>>;
    /**
     * (Optional) Sign out of the auth provider.
     */
    logout?(): Promise<void>;
}

declare type Options = {
    providerId: string;
    secure: boolean;
    disableRefresh?: boolean;
    persistScopes?: boolean;
    cookieDomain: string;
    cookiePath: string;
    appOrigin: string;
    tokenIssuer: TokenIssuer;
};
declare class OAuthAdapter implements AuthProviderRouteHandlers {
    private readonly handlers;
    private readonly options;
    static fromConfig(config: AuthProviderConfig, handlers: OAuthHandlers, options: Pick<Options, 'providerId' | 'persistScopes' | 'disableRefresh' | 'tokenIssuer'>): OAuthAdapter;
    constructor(handlers: OAuthHandlers, options: Options);
    start(req: express.Request, res: express.Response): Promise<void>;
    frameHandler(req: express.Request, res: express.Response): Promise<void>;
    logout(req: express.Request, res: express.Response): Promise<void>;
    refresh(req: express.Request, res: express.Response): Promise<void>;
    /**
     * If the response from the OAuth provider includes a Backstage identity, we
     * make sure it's populated with all the information we can derive from the user ID.
     */
    private populateIdentity;
    private setNonceCookie;
    private setScopesCookie;
    private getScopesFromCookie;
    private setRefreshTokenCookie;
    private removeRefreshTokenCookie;
}

declare const readState: (stateString: string) => OAuthState;
declare const encodeState: (state: OAuthState) => string;
declare const verifyNonce: (req: express.Request, providerId: string) => void;

export { AuthProviderFactory, AuthProviderFactoryOptions, AuthProviderRouteHandlers, AuthResponse, BackstageIdentity, IdentityClient, OAuthAdapter, OAuthEnvironmentHandler, OAuthHandlers, OAuthProviderInfo, OAuthProviderOptions, OAuthRefreshRequest, OAuthResponse, OAuthResult, OAuthStartRequest, OAuthState, ProfileInfo, RouterOptions, WebMessageResponse, createRouter, factories as defaultAuthProviderFactories, encodeState, ensuresXRequestedWith, postMessageResponse, readState, verifyNonce };
