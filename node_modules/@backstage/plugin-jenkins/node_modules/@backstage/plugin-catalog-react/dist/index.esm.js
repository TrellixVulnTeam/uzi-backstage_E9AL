import { createApiRef, createRouteRef, useRouteRefParams, useApi, errorApiRef, identityApiRef, storageApiRef, Link, OverflowTooltip, Table, alertApiRef, Select, configApiRef } from '@backstage/core';
import React, { createContext, useEffect, useContext, useState, useCallback, useMemo, forwardRef, Fragment } from 'react';
import { Alert, Autocomplete } from '@material-ui/lab';
import { useNavigate, generatePath } from 'react-router';
import { useAsync, useAsyncFn, useDebounce, useObservable } from 'react-use';
import { ENTITY_DEFAULT_NAMESPACE, RELATION_MEMBER_OF, getEntityName, RELATION_OWNED_BY, serializeEntityRef, RELATION_PART_OF } from '@backstage/catalog-model';
import { compact, isEqual, groupBy, chunk, capitalize } from 'lodash';
import { makeStyles, Typography, FormControlLabel, Checkbox, TextField, Box, Card, List, MenuItem, ListItemIcon, ListItemText, ListItemSecondaryAction } from '@material-ui/core';
import CheckBoxOutlineBlankIcon from '@material-ui/icons/CheckBoxOutlineBlank';
import CheckBoxIcon from '@material-ui/icons/CheckBox';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import SettingsIcon from '@material-ui/icons/Settings';
import StarIcon from '@material-ui/icons/Star';

const catalogApiRef = createApiRef({
  id: "plugin.catalog.service",
  description: "Used by the Catalog plugin to make requests to accompanying backend"
});

const NoIcon = () => null;
const rootRoute = createRouteRef({
  icon: NoIcon,
  path: "",
  title: "Catalog"
});
const catalogRouteRef = rootRoute;
const entityRoute = createRouteRef({
  icon: NoIcon,
  path: ":namespace/:kind/:name/*",
  title: "Entity",
  params: ["namespace", "kind", "name"]
});
const entityRouteRef = entityRoute;
function entityRouteParams(entity) {
  var _a, _b;
  return {
    kind: entity.kind.toLowerCase(),
    namespace: (_b = (_a = entity.metadata.namespace) == null ? void 0 : _a.toLowerCase()) != null ? _b : ENTITY_DEFAULT_NAMESPACE,
    name: entity.metadata.name
  };
}

const useEntityCompoundName = () => {
  const {kind, namespace, name} = useRouteRefParams(entityRouteRef);
  return {kind, namespace, name};
};

const EntityContext = createContext({
  entity: void 0,
  loading: true,
  error: void 0
});
const useEntityFromUrl = () => {
  const {kind, namespace, name} = useEntityCompoundName();
  const navigate = useNavigate();
  const errorApi = useApi(errorApiRef);
  const catalogApi = useApi(catalogApiRef);
  const {value: entity, error, loading} = useAsync(() => catalogApi.getEntityByName({kind, namespace, name}), [catalogApi, kind, namespace, name]);
  useEffect(() => {
    if (!name) {
      errorApi.post(new Error("No name provided!"));
      navigate("/");
    }
  }, [errorApi, navigate, error, loading, entity, name]);
  return {entity, loading, error};
};
function useEntity() {
  const {entity, loading, error} = useContext(EntityContext);
  return {entity, loading, error};
}

function reduceCatalogFilters(filters) {
  return filters.reduce((compoundFilter, filter) => {
    return {
      ...compoundFilter,
      ...filter.getCatalogFilters ? filter.getCatalogFilters() : {}
    };
  }, {});
}
function reduceEntityFilters(filters) {
  return (entity) => filters.every((filter) => !filter.filterEntity || filter.filterEntity(entity));
}

function getEntityRelations(entity, relationType, filter) {
  var _a, _b;
  let entityNames = ((_b = (_a = entity == null ? void 0 : entity.relations) == null ? void 0 : _a.filter((r) => r.type === relationType)) == null ? void 0 : _b.map((r) => r.target)) || [];
  if (filter == null ? void 0 : filter.kind) {
    entityNames = entityNames == null ? void 0 : entityNames.filter((e) => e.kind.toLowerCase() === filter.kind.toLowerCase());
  }
  return entityNames;
}

function isOwnerOf(owner, owned) {
  const possibleOwners = [
    ...getEntityRelations(owner, RELATION_MEMBER_OF, {kind: "group"}),
    ...owner ? [getEntityName(owner)] : []
  ];
  const owners = getEntityRelations(owned, RELATION_OWNED_BY);
  for (const ownerItem of owners) {
    if (possibleOwners.find((o) => ownerItem.kind.toLowerCase() === o.kind.toLowerCase() && ownerItem.namespace.toLowerCase() === o.namespace.toLowerCase() && ownerItem.name.toLowerCase() === o.name.toLowerCase()) !== void 0) {
      return true;
    }
  }
  return false;
}

const EntityListContext = createContext(void 0);
const EntityListProvider = ({
  children
}) => {
  const catalogApi = useApi(catalogApiRef);
  const [filters, setFilters] = useState({});
  const [entities, setEntities] = useState([]);
  const [backendEntities, setBackendEntities] = useState([]);
  const [backendFilters, setBackendFilters] = useState(reduceCatalogFilters(compact(Object.values(filters))));
  useEffect(() => {
    const newBackendFilters = reduceCatalogFilters(compact(Object.values(filters)));
    if (!isEqual(newBackendFilters, backendFilters)) {
      setBackendFilters(newBackendFilters);
    }
  }, [backendFilters, filters]);
  const [{loading, error}, refresh] = useAsyncFn(async () => {
    const items = await catalogApi.getEntities({
      filter: backendFilters
    }).then((response) => response.items);
    setBackendEntities(items);
  }, [backendFilters, catalogApi]);
  useDebounce(refresh, 10, [backendFilters]);
  useEffect(() => {
    const resolvedEntities = (backendEntities != null ? backendEntities : []).filter(reduceEntityFilters(compact(Object.values(filters))));
    setEntities(resolvedEntities);
  }, [backendEntities, filters]);
  const updateFilters = useCallback((update) => {
    if (typeof update === "function") {
      setFilters((prevFilters) => ({...prevFilters, ...update(prevFilters)}));
    } else {
      setFilters((prevFilters) => ({...prevFilters, ...update}));
    }
  }, []);
  return /* @__PURE__ */ React.createElement(EntityListContext.Provider, {
    value: {
      filters,
      entities,
      backendEntities,
      updateFilters,
      loading,
      error
    }
  }, children);
};
function useEntityListProvider() {
  const context = useContext(EntityListContext);
  if (!context)
    throw new Error("useEntityListProvider must be used within EntityListProvider");
  return context;
}

class EntityKindFilter {
  constructor(value) {
    this.value = value;
  }
  getCatalogFilters() {
    return {kind: this.value};
  }
}
class EntityTypeFilter {
  constructor(value) {
    this.value = value;
  }
  getCatalogFilters() {
    return {"spec.type": this.value};
  }
}
class EntityTagFilter {
  constructor(values) {
    this.values = values;
  }
  filterEntity(entity) {
    return this.values.every((v) => {
      var _a;
      return ((_a = entity.metadata.tags) != null ? _a : []).includes(v);
    });
  }
}
class UserListFilter {
  constructor(value, user, isStarredEntity) {
    this.value = value;
    this.user = user;
    this.isStarredEntity = isStarredEntity;
  }
  filterEntity(entity) {
    switch (this.value) {
      case "owned":
        return this.user !== void 0 && isOwnerOf(this.user, entity);
      case "starred":
        return this.isStarredEntity(entity);
      default:
        return true;
    }
  }
}

function useEntityTypeFilter() {
  const catalogApi = useApi(catalogApiRef);
  const {
    filters: {kind: kindFilter, type: typeFilter},
    updateFilters
  } = useEntityListProvider();
  const [types, setTypes] = useState([]);
  const kind = useMemo(() => kindFilter == null ? void 0 : kindFilter.value, [kindFilter]);
  const {error, loading, value: entities} = useAsync(async () => {
    if (kind) {
      const items = await catalogApi.getEntities({
        filter: {kind},
        fields: ["spec.type"]
      }).then((response) => response.items);
      return items;
    }
    return [];
  }, [kind, catalogApi]);
  useEffect(() => {
    const newTypes = [
      ...new Set((entities != null ? entities : []).map((e) => {
        var _a;
        return (_a = e.spec) == null ? void 0 : _a.type;
      }).filter(Boolean))
    ].sort();
    setTypes(newTypes);
    updateFilters((oldFilters) => oldFilters.type && !newTypes.includes(oldFilters.type.value) ? {type: void 0} : {});
  }, [updateFilters, entities]);
  const setType = useCallback((type) => updateFilters({
    type: type === void 0 ? void 0 : new EntityTypeFilter(type)
  }), [updateFilters]);
  return {
    loading,
    error,
    types,
    selectedType: typeFilter == null ? void 0 : typeFilter.value,
    setType
  };
}

function useOwnUser() {
  const catalogApi = useApi(catalogApiRef);
  const identityApi = useApi(identityApiRef);
  return useAsync(() => catalogApi.getEntityByName({
    kind: "User",
    namespace: "default",
    name: identityApi.getUserId()
  }), [catalogApi, identityApi]);
}

const BATCH_SIZE = 20;
function useRelatedEntities(entity, {type, kind}) {
  const catalogApi = useApi(catalogApiRef);
  const {loading, value: entities, error} = useAsync(async () => {
    const relations = entity.relations && entity.relations.filter((r) => (!type || r.type.toLowerCase() === type.toLowerCase()) && (!kind || r.target.kind.toLowerCase() === kind.toLowerCase()));
    if (!relations) {
      return [];
    }
    const relationsByKindAndNamespace = Object.values(groupBy(relations, ({target}) => {
      return `${target.kind}:${target.namespace}`.toLowerCase();
    }));
    const batchedRelationsByKindAndNamespace = [];
    for (const rs of relationsByKindAndNamespace) {
      batchedRelationsByKindAndNamespace.push({
        kind: rs[0].target.kind,
        namespace: rs[0].target.namespace,
        nameBatches: chunk(rs.map((r) => r.target.name), BATCH_SIZE)
      });
    }
    const results = await Promise.all(batchedRelationsByKindAndNamespace.flatMap((rs) => {
      return rs.nameBatches.map((names) => {
        return catalogApi.getEntities({
          filter: {
            kind: rs.kind,
            "metadata.namespace": rs.namespace,
            "metadata.name": names
          }
        });
      });
    }));
    return results.flatMap((r) => r.items);
  }, [entity, type]);
  return {
    entities,
    loading,
    error
  };
}

const buildEntityKey = (component) => {
  var _a;
  return `entity:${component.kind}:${(_a = component.metadata.namespace) != null ? _a : "default"}:${component.metadata.name}`;
};
const useStarredEntities = () => {
  var _a;
  const storageApi = useApi(storageApiRef);
  const settingsStore = storageApi.forBucket("settings");
  const rawStarredEntityKeys = (_a = settingsStore.get("starredEntities")) != null ? _a : [];
  const [starredEntities, setStarredEntities] = useState(new Set(rawStarredEntityKeys));
  const observedItems = useObservable(settingsStore.observe$("starredEntities"));
  useEffect(() => {
    var _a2;
    if (observedItems == null ? void 0 : observedItems.newValue) {
      const currentValue = (_a2 = observedItems == null ? void 0 : observedItems.newValue) != null ? _a2 : [];
      setStarredEntities(new Set(currentValue));
    }
  }, [observedItems == null ? void 0 : observedItems.newValue]);
  const toggleStarredEntity = useCallback((entity) => {
    const entityKey = buildEntityKey(entity);
    if (starredEntities.has(entityKey)) {
      starredEntities.delete(entityKey);
    } else {
      starredEntities.add(entityKey);
    }
    settingsStore.set("starredEntities", Array.from(starredEntities));
  }, [starredEntities, settingsStore]);
  const isStarredEntity = useCallback((entity) => {
    const entityKey = buildEntityKey(entity);
    return starredEntities.has(entityKey);
  }, [starredEntities]);
  return {
    starredEntities,
    toggleStarredEntity,
    isStarredEntity
  };
};

const EntityKindPicker = ({
  initialFilter,
  hidden
}) => {
  const [selectedKind] = useState(initialFilter);
  const {updateFilters} = useEntityListProvider();
  useEffect(() => {
    updateFilters({
      kind: selectedKind ? new EntityKindFilter(selectedKind) : void 0
    });
  }, [selectedKind, updateFilters]);
  if (hidden)
    return null;
  return /* @__PURE__ */ React.createElement(Alert, {
    severity: "warning"
  }, "Kind filter not yet available");
};

const EntityProvider = ({entity, children}) => /* @__PURE__ */ React.createElement(EntityContext.Provider, {
  value: {
    entity,
    loading: !Boolean(entity),
    error: void 0
  }
}, children);

function formatEntityRefTitle(entityRef, opts) {
  const defaultKind = opts == null ? void 0 : opts.defaultKind;
  let kind;
  let namespace;
  let name;
  if ("metadata" in entityRef) {
    kind = entityRef.kind;
    namespace = entityRef.metadata.namespace;
    name = entityRef.metadata.name;
  } else {
    kind = entityRef.kind;
    namespace = entityRef.namespace;
    name = entityRef.name;
  }
  if (namespace === ENTITY_DEFAULT_NAMESPACE) {
    namespace = void 0;
  }
  kind = kind.toLowerCase();
  return `${serializeEntityRef({
    kind: defaultKind && defaultKind.toLowerCase() === kind ? void 0 : kind,
    name,
    namespace
  })}`;
}

const EntityRefLink = forwardRef((props, ref) => {
  var _a;
  const {entityRef, defaultKind, children, ...linkProps} = props;
  let kind;
  let namespace;
  let name;
  if ("metadata" in entityRef) {
    kind = entityRef.kind;
    namespace = entityRef.metadata.namespace;
    name = entityRef.metadata.name;
  } else {
    kind = entityRef.kind;
    namespace = entityRef.namespace;
    name = entityRef.name;
  }
  kind = kind.toLocaleLowerCase("en-US");
  const routeParams = {
    kind,
    namespace: (_a = namespace == null ? void 0 : namespace.toLocaleLowerCase("en-US")) != null ? _a : ENTITY_DEFAULT_NAMESPACE,
    name
  };
  return /* @__PURE__ */ React.createElement(Link, {
    ...linkProps,
    ref,
    to: generatePath(`/catalog/${entityRoute.path}`, routeParams)
  }, children, !children && formatEntityRefTitle(entityRef, {defaultKind}));
});

const EntityRefLinks = ({
  entityRefs,
  defaultKind,
  ...linkProps
}) => /* @__PURE__ */ React.createElement(React.Fragment, null, entityRefs.map((r, i) => /* @__PURE__ */ React.createElement(React.Fragment, {
  key: i
}, i > 0 && ", ", /* @__PURE__ */ React.createElement(EntityRefLink, {
  ...linkProps,
  entityRef: r,
  defaultKind
}))));

function createEntityRefColumn({
  defaultKind
}) {
  function formatContent(entity) {
    return formatEntityRefTitle(entity, {
      defaultKind
    });
  }
  return {
    title: "Name",
    highlight: true,
    customFilterAndSearch(filter, entity) {
      return formatContent(entity).includes(filter);
    },
    customSort(entity1, entity2) {
      return formatContent(entity1).localeCompare(formatContent(entity2));
    },
    render: (entity) => /* @__PURE__ */ React.createElement(EntityRefLink, {
      entityRef: entity,
      defaultKind
    })
  };
}
function createEntityRelationColumn({
  title,
  relation,
  defaultKind,
  filter: entityFilter
}) {
  function getRelations(entity) {
    return getEntityRelations(entity, relation, entityFilter);
  }
  function formatContent(entity) {
    return getRelations(entity).map((r) => formatEntityRefTitle(r, {defaultKind})).join(", ");
  }
  return {
    title,
    customFilterAndSearch(filter, entity) {
      return formatContent(entity).includes(filter);
    },
    customSort(entity1, entity2) {
      return formatContent(entity1).localeCompare(formatContent(entity2));
    },
    render: (entity) => {
      return /* @__PURE__ */ React.createElement(EntityRefLinks, {
        entityRefs: getRelations(entity),
        defaultKind
      });
    }
  };
}
function createOwnerColumn() {
  return createEntityRelationColumn({
    title: "Owner",
    relation: RELATION_OWNED_BY,
    defaultKind: "group"
  });
}
function createDomainColumn() {
  return createEntityRelationColumn({
    title: "Domain",
    relation: RELATION_PART_OF,
    defaultKind: "domain",
    filter: {
      kind: "domain"
    }
  });
}
function createSystemColumn() {
  return createEntityRelationColumn({
    title: "System",
    relation: RELATION_PART_OF,
    defaultKind: "system",
    filter: {
      kind: "system"
    }
  });
}
function createMetadataDescriptionColumn() {
  return {
    title: "Description",
    field: "metadata.description",
    render: (entity) => /* @__PURE__ */ React.createElement(OverflowTooltip, {
      text: entity.metadata.description,
      placement: "bottom-start"
    }),
    width: "auto"
  };
}
function createSpecLifecycleColumn() {
  return {
    title: "Lifecycle",
    field: "spec.lifecycle"
  };
}
function createSpecTypeColumn() {
  return {
    title: "Type",
    field: "spec.type"
  };
}

var columnFactories = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createEntityRefColumn: createEntityRefColumn,
  createEntityRelationColumn: createEntityRelationColumn,
  createOwnerColumn: createOwnerColumn,
  createDomainColumn: createDomainColumn,
  createSystemColumn: createSystemColumn,
  createMetadataDescriptionColumn: createMetadataDescriptionColumn,
  createSpecLifecycleColumn: createSpecLifecycleColumn,
  createSpecTypeColumn: createSpecTypeColumn
});

const systemEntityColumns = [
  createEntityRefColumn({defaultKind: "system"}),
  createDomainColumn(),
  createOwnerColumn(),
  createMetadataDescriptionColumn()
];
const componentEntityColumns = [
  createEntityRefColumn({defaultKind: "component"}),
  createSystemColumn(),
  createOwnerColumn(),
  createSpecTypeColumn(),
  createSpecLifecycleColumn(),
  createMetadataDescriptionColumn()
];

const useStyles = makeStyles((theme) => ({
  empty: {
    padding: theme.spacing(2),
    display: "flex",
    justifyContent: "center"
  }
}));
function EntityTable({
  entities,
  title,
  emptyContent,
  variant = "gridItem",
  columns
}) {
  const classes = useStyles();
  const tableStyle = {
    minWidth: "0",
    width: "100%"
  };
  if (variant === "gridItem") {
    tableStyle.height = "calc(100% - 10px)";
  }
  return /* @__PURE__ */ React.createElement(Table, {
    columns,
    title,
    style: tableStyle,
    emptyContent: emptyContent && /* @__PURE__ */ React.createElement("div", {
      className: classes.empty
    }, emptyContent),
    options: {
      search: false,
      paging: false,
      actionsColumnIndex: -1,
      padding: "dense"
    },
    data: entities
  });
}
EntityTable.columns = columnFactories;
EntityTable.systemEntityColumns = systemEntityColumns;
EntityTable.componentEntityColumns = componentEntityColumns;

const icon = /* @__PURE__ */ React.createElement(CheckBoxOutlineBlankIcon, {
  fontSize: "small"
});
const checkedIcon = /* @__PURE__ */ React.createElement(CheckBoxIcon, {
  fontSize: "small"
});
const EntityTagPicker = () => {
  var _a, _b;
  const {updateFilters, backendEntities, filters} = useEntityListProvider();
  const availableTags = useMemo(() => [
    ...new Set(backendEntities.flatMap((e) => e.metadata.tags).filter(Boolean))
  ], [backendEntities]);
  if (!availableTags.length)
    return null;
  const onChange = (tags) => {
    updateFilters({
      tags: tags.length ? new EntityTagFilter(tags) : void 0
    });
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, {
    variant: "button"
  }, "Tags"), /* @__PURE__ */ React.createElement(Autocomplete, {
    multiple: true,
    options: availableTags,
    value: (_b = (_a = filters.tags) == null ? void 0 : _a.values) != null ? _b : [],
    onChange: (_, value) => onChange(value),
    renderOption: (option, {selected}) => /* @__PURE__ */ React.createElement(FormControlLabel, {
      control: /* @__PURE__ */ React.createElement(Checkbox, {
        icon,
        checkedIcon,
        checked: selected
      }),
      label: option
    }),
    size: "small",
    popupIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, {
      "data-testid": "tag-picker-expand"
    }),
    renderInput: (params) => /* @__PURE__ */ React.createElement(TextField, {
      ...params,
      variant: "outlined"
    })
  }));
};

const EntityTypePicker = () => {
  const alertApi = useApi(alertApiRef);
  const {error, types, selectedType, setType} = useEntityTypeFilter();
  if (!types)
    return null;
  if (error) {
    alertApi.post({
      message: `Failed to load entity types`,
      severity: "error"
    });
    return null;
  }
  const items = [
    {value: "all", label: "All"},
    ...types.map((type) => ({
      value: type,
      label: capitalize(type)
    }))
  ];
  return /* @__PURE__ */ React.createElement(Box, {
    pb: 1,
    pt: 1
  }, /* @__PURE__ */ React.createElement(Select, {
    label: "Type",
    items,
    selected: selectedType != null ? selectedType : "all",
    onChange: (value) => setType(value === "all" ? void 0 : String(value))
  }));
};

const useStyles$1 = makeStyles((theme) => ({
  root: {
    backgroundColor: "rgba(0, 0, 0, .11)",
    boxShadow: "none",
    margin: theme.spacing(1, 0, 1, 0)
  },
  title: {
    margin: theme.spacing(1, 0, 0, 1),
    textTransform: "uppercase",
    fontSize: 12,
    fontWeight: "bold"
  },
  listIcon: {
    minWidth: 30,
    color: theme.palette.text.primary
  },
  menuItem: {
    minHeight: theme.spacing(6)
  },
  groupWrapper: {
    margin: theme.spacing(1, 1, 2, 1)
  }
}));
function getFilterGroups(orgName) {
  return [
    {
      name: "Personal",
      items: [
        {
          id: "owned",
          label: "Owned",
          icon: SettingsIcon
        },
        {
          id: "starred",
          label: "Starred",
          icon: StarIcon
        }
      ]
    },
    {
      name: orgName != null ? orgName : "Company",
      items: [
        {
          id: "all",
          label: "All"
        }
      ]
    }
  ];
}
const UserListPicker = ({initialFilter}) => {
  var _a;
  const classes = useStyles$1();
  const configApi = useApi(configApiRef);
  const orgName = (_a = configApi.getOptionalString("organization.name")) != null ? _a : "Company";
  const filterGroups = getFilterGroups(orgName);
  const {value: user} = useOwnUser();
  const {isStarredEntity} = useStarredEntities();
  const [selectedUserFilter, setSelectedUserFilter] = useState(initialFilter);
  const ownedFilter = useMemo(() => new UserListFilter("owned", user, isStarredEntity), [user, isStarredEntity]);
  const starredFilter = useMemo(() => new UserListFilter("starred", user, isStarredEntity), [user, isStarredEntity]);
  const {filters, updateFilters, backendEntities} = useEntityListProvider();
  useEffect(() => {
    updateFilters({
      user: selectedUserFilter ? new UserListFilter(selectedUserFilter, user, isStarredEntity) : void 0
    });
  }, [selectedUserFilter, user, isStarredEntity, updateFilters]);
  const [entitiesWithoutUserFilter, setEntitiesWithoutUserFilter] = useState(backendEntities);
  useEffect(() => {
    const filterFn = reduceEntityFilters(compact(Object.values({...filters, user: void 0})));
    setEntitiesWithoutUserFilter(backendEntities.filter(filterFn));
  }, [filters, backendEntities]);
  function getFilterCount(id) {
    switch (id) {
      case "owned":
        return entitiesWithoutUserFilter.filter((entity) => ownedFilter.filterEntity(entity)).length;
      case "starred":
        return entitiesWithoutUserFilter.filter((entity) => starredFilter.filterEntity(entity)).length;
      default:
        return entitiesWithoutUserFilter.length;
    }
  }
  return /* @__PURE__ */ React.createElement(Card, {
    className: classes.root
  }, filterGroups.map((group) => /* @__PURE__ */ React.createElement(Fragment, {
    key: group.name
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    className: classes.title
  }, group.name), /* @__PURE__ */ React.createElement(Card, {
    className: classes.groupWrapper
  }, /* @__PURE__ */ React.createElement(List, {
    disablePadding: true,
    dense: true
  }, group.items.map((item) => {
    var _a2, _b;
    return /* @__PURE__ */ React.createElement(MenuItem, {
      key: item.id,
      button: true,
      divider: true,
      onClick: () => setSelectedUserFilter(item.id),
      selected: item.id === ((_a2 = filters.user) == null ? void 0 : _a2.value),
      className: classes.menuItem
    }, item.icon && /* @__PURE__ */ React.createElement(ListItemIcon, {
      className: classes.listIcon
    }, /* @__PURE__ */ React.createElement(item.icon, {
      fontSize: "small"
    })), /* @__PURE__ */ React.createElement(ListItemText, null, /* @__PURE__ */ React.createElement(Typography, {
      variant: "body1",
      "data-testid": `user-picker-${item.id}`
    }, item.label)), /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, (_b = getFilterCount(item.id)) != null ? _b : "-"));
  }))))));
};

const MockEntityListContextProvider = ({
  children,
  value
}) => {
  const defaultContext = {
    entities: [],
    backendEntities: [],
    updateFilters: jest.fn(),
    filters: {},
    loading: false
  };
  return /* @__PURE__ */ React.createElement(EntityListContext.Provider, {
    value: {...defaultContext, ...value}
  }, children);
};

export { EntityContext, EntityKindFilter, EntityKindPicker, EntityListContext, EntityListProvider, EntityProvider, EntityRefLink, EntityRefLinks, EntityTable, EntityTagFilter, EntityTagPicker, EntityTypeFilter, EntityTypePicker, MockEntityListContextProvider, UserListFilter, UserListPicker, catalogApiRef, catalogRouteRef, entityRoute, entityRouteParams, entityRouteRef, formatEntityRefTitle, getEntityRelations, isOwnerOf, reduceCatalogFilters, reduceEntityFilters, rootRoute, useEntity, useEntityCompoundName, useEntityFromUrl, useEntityListProvider, useEntityTypeFilter, useOwnUser, useRelatedEntities, useStarredEntities };
//# sourceMappingURL=index.esm.js.map
