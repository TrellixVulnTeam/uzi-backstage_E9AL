import ObservableImpl from 'zen-observable';
import { act } from '@testing-library/react';
import React from 'react';
import { MemoryRouter } from 'react-router';
import { Route } from 'react-router-dom';
import { lightTheme } from '@backstage/theme';
import privateExports, { createApiFactory, errorApiRef, storageApiRef, alertApiRef, AlertApiForwarder, defaultSystemIcons, createRouteRef, attachComponentData } from '@backstage/core-api';
import { renderWithEffects } from '@backstage/test-utils-core';
export * from '@backstage/test-utils-core';

const nullObservable = {
  subscribe: () => ({unsubscribe: () => {
  }, closed: true}),
  [Symbol.observable]() {
    return this;
  }
};
class MockErrorApi {
  constructor(options = {}) {
    this.options = options;
    this.errors = new Array();
    this.waiters = new Set();
  }
  post(error, context) {
    if (this.options.collect) {
      this.errors.push({error, context});
      for (const waiter of this.waiters) {
        if (waiter.pattern.test(error.message)) {
          this.waiters.delete(waiter);
          waiter.resolve({error, context});
        }
      }
      return;
    }
    throw new Error(`MockErrorApi received unexpected error, ${error}`);
  }
  error$() {
    return nullObservable;
  }
  getErrors() {
    return this.errors;
  }
  waitForError(pattern, timeoutMs = 2e3) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        reject(new Error("Timed out waiting for error"));
      }, timeoutMs);
      this.waiters.add({resolve, pattern});
    });
  }
}

class MockStorageApi {
  constructor(namespace, data) {
    this.subscribers = new Set();
    this.observable = new ObservableImpl((subscriber) => {
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    this.namespace = namespace;
    this.data = {...data};
  }
  static create(data) {
    return new MockStorageApi("", data);
  }
  forBucket(name) {
    return new MockStorageApi(`${this.namespace}/${name}`, this.data);
  }
  get(key) {
    return this.data[this.getKeyName(key)];
  }
  async set(key, data) {
    this.data[this.getKeyName(key)] = data;
    this.notifyChanges({key, newValue: data});
  }
  async remove(key) {
    delete this.data[this.getKeyName(key)];
    this.notifyChanges({key, newValue: void 0});
  }
  observe$(key) {
    return this.observable.filter(({key: messageKey}) => messageKey === key);
  }
  getKeyName(key) {
    return `${this.namespace}/${encodeURIComponent(key)}`;
  }
  notifyChanges(message) {
    for (const subscription of this.subscribers) {
      subscription.next(message);
    }
  }
}

const queryToBreakpoint = {
  "(min-width:1920px)": "xl",
  "(min-width:1280px)": "lg",
  "(min-width:960px)": "md",
  "(min-width:600px)": "sm",
  "(min-width:0px)": "xs"
};
function toBreakpoint(query) {
  const breakpoint = queryToBreakpoint[query];
  if (!breakpoint) {
    throw new Error(`received unknown media query in breakpoint mock: '${query}'`);
  }
  return breakpoint;
}
function mockBreakpoint(initialBreakpoint = "xl") {
  let currentBreakpoint = initialBreakpoint;
  const queries = Array();
  const previousMatchMedia = window.matchMedia;
  window.matchMedia = (query) => {
    const listeners = new Set();
    const queryList = {
      addListener(listener) {
        listeners.add(listener);
      },
      removeListener(listener) {
        listeners.delete(listener);
      },
      matches: toBreakpoint(query) === currentBreakpoint
    };
    queries.push({query, queryList, listeners});
    return queryList;
  };
  return {
    set(breakpoint) {
      currentBreakpoint = breakpoint;
      act(() => {
        queries.forEach(({query, queryList, listeners}) => {
          const matches = toBreakpoint(query) === breakpoint;
          queryList.matches = matches;
          listeners.forEach((listener) => listener({matches}));
        });
      });
    },
    remove() {
      window.matchMedia = previousMatchMedia;
    }
  };
}

const mockApis = [
  createApiFactory(errorApiRef, new MockErrorApi()),
  createApiFactory(storageApiRef, MockStorageApi.create()),
  createApiFactory(alertApiRef, new AlertApiForwarder())
];

const {PrivateAppImpl} = privateExports;
const NotFoundErrorPage = () => {
  throw new Error("Reached NotFound Page");
};
const BootErrorPage = ({step, error}) => {
  throw new Error(`Reached BootError Page at step ${step} with error ${error}`);
};
const Progress = () => /* @__PURE__ */ React.createElement("div", {
  "data-testid": "progress"
});
function isExternalRouteRef(routeRef) {
  return String(routeRef).includes("{type=external,");
}
function wrapInTestApp(Component, options = {}) {
  var _a;
  const {routeEntries = ["/"]} = options;
  const boundRoutes = new Map();
  const app = new PrivateAppImpl({
    apis: [],
    components: {
      NotFoundErrorPage,
      BootErrorPage,
      Progress,
      Router: ({children}) => /* @__PURE__ */ React.createElement(MemoryRouter, {
        initialEntries: routeEntries,
        children
      })
    },
    icons: defaultSystemIcons,
    plugins: [],
    themes: [
      {
        id: "light",
        theme: lightTheme,
        title: "Test App Theme",
        variant: "light"
      }
    ],
    defaultApis: mockApis,
    bindRoutes: ({bind}) => {
      for (const [externalRef, absoluteRef] of boundRoutes) {
        bind({ref: externalRef}, {
          ref: absoluteRef
        });
      }
    }
  });
  let wrappedElement;
  if (Component instanceof Function) {
    wrappedElement = /* @__PURE__ */ React.createElement(Component, null);
  } else {
    wrappedElement = Component;
  }
  const routeElements = Object.entries((_a = options.mountedRoutes) != null ? _a : {}).map(([path, routeRef]) => {
    const Page = () => /* @__PURE__ */ React.createElement("div", null, "Mounted at ", path);
    if (isExternalRouteRef(routeRef)) {
      const absoluteRef = createRouteRef({id: "id"});
      boundRoutes.set(routeRef, absoluteRef);
      attachComponentData(Page, "core.mountPoint", absoluteRef);
    } else {
      attachComponentData(Page, "core.mountPoint", routeRef);
    }
    return /* @__PURE__ */ React.createElement(Route, {
      key: path,
      path,
      element: /* @__PURE__ */ React.createElement(Page, null)
    });
  });
  const AppProvider = app.getProvider();
  const AppRouter = app.getRouter();
  return /* @__PURE__ */ React.createElement(AppProvider, null, /* @__PURE__ */ React.createElement(AppRouter, null, routeElements, /* @__PURE__ */ React.createElement(Route, {
    path: "*",
    element: wrappedElement
  })));
}
async function renderInTestApp(Component, options = {}) {
  return renderWithEffects(wrapInTestApp(Component, options));
}

const msw = {
  setupDefaultHandlers: (worker) => {
    beforeAll(() => worker.listen({onUnhandledRequest: "error"}));
    afterAll(() => worker.close());
    afterEach(() => worker.resetHandlers());
  }
};

export { MockErrorApi, MockStorageApi, mockBreakpoint, msw, renderInTestApp, wrapInTestApp };
//# sourceMappingURL=index.esm.js.map
