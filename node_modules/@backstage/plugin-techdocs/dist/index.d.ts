/// <reference types="react" />
import { ApiRef, DiscoveryApi, IdentityApi, BackstagePlugin, RouteRef } from '@backstage/core';
import { Entity, Location, EntityName } from '@backstage/catalog-model';
import { Config } from '@backstage/config';
import { CSSProperties } from '@material-ui/styles';

declare type TechDocsMetadata = {
    site_name: string;
    site_description: string;
};
declare type TechDocsEntityMetadata = Entity & {
    locationMetadata?: Location;
};

declare const techdocsStorageApiRef: ApiRef<TechDocsStorageApi>;
declare const techdocsApiRef: ApiRef<TechDocsApi>;
interface TechDocsStorageApi {
    getApiOrigin(): Promise<string>;
    getStorageUrl(): Promise<string>;
    getBuilder(): Promise<string>;
    getEntityDocs(entityId: EntityName, path: string): Promise<string>;
    syncEntityDocs(entityId: EntityName): Promise<boolean>;
    getBaseUrl(oldBaseUrl: string, entityId: EntityName, path: string): Promise<string>;
}
interface TechDocsApi {
    getApiOrigin(): Promise<string>;
    getTechDocsMetadata(entityId: EntityName): Promise<TechDocsMetadata>;
    getEntityMetadata(entityId: EntityName): Promise<TechDocsEntityMetadata>;
}

/**
 * API to talk to techdocs-backend.
 *
 * @property {string} apiOrigin Set to techdocs.requestUrl as the URL for techdocs-backend API
 */
declare class TechDocsClient implements TechDocsApi {
    configApi: Config;
    discoveryApi: DiscoveryApi;
    identityApi: IdentityApi;
    constructor({ configApi, discoveryApi, identityApi, }: {
        configApi: Config;
        discoveryApi: DiscoveryApi;
        identityApi: IdentityApi;
    });
    getApiOrigin(): Promise<string>;
    /**
     * Retrieve TechDocs metadata.
     *
     * When docs are built, we generate a techdocs_metadata.json and store it along with the generated
     * static files. It includes necessary data about the docs site. This method requests techdocs-backend
     * which retrieves the TechDocs metadata.
     *
     * @param {EntityName} entityId Object containing entity data like name, namespace, etc.
     */
    getTechDocsMetadata(entityId: EntityName): Promise<TechDocsMetadata>;
    /**
     * Retrieve metadata about an entity.
     *
     * This method requests techdocs-backend which uses the catalog APIs to respond with filtered
     * information required here.
     *
     * @param {EntityName} entityId Object containing entity data like name, namespace, etc.
     */
    getEntityMetadata(entityId: EntityName): Promise<TechDocsEntityMetadata>;
}
/**
 * API which talks to TechDocs storage to fetch files to render.
 *
 * @property {string} apiOrigin Set to techdocs.requestUrl as the URL for techdocs-backend API
 */
declare class TechDocsStorageClient implements TechDocsStorageApi {
    configApi: Config;
    discoveryApi: DiscoveryApi;
    identityApi: IdentityApi;
    constructor({ configApi, discoveryApi, identityApi, }: {
        configApi: Config;
        discoveryApi: DiscoveryApi;
        identityApi: IdentityApi;
    });
    getApiOrigin(): Promise<string>;
    getStorageUrl(): Promise<string>;
    getBuilder(): Promise<string>;
    /**
     * Fetch HTML content as text for an individual docs page in an entity's docs site.
     *
     * @param {EntityName} entityId Object containing entity data like name, namespace, etc.
     * @param {string} path The unique path to an individual docs page e.g. overview/what-is-new
     * @returns {string} HTML content of the docs page as string
     * @throws {Error} Throws error when the page is not found.
     */
    getEntityDocs(entityId: EntityName, path: string): Promise<string>;
    /**
     * Check if docs are on the latest version and trigger rebuild if not
     *
     * @param {EntityName} entityId Object containing entity data like name, namespace, etc.
     * @returns {boolean} Whether documents are currently synchronized to newest version
     * @throws {Error} Throws error on error from sync endpoint in Techdocs Backend
     */
    syncEntityDocs(entityId: EntityName): Promise<boolean>;
    getBaseUrl(oldBaseUrl: string, entityId: EntityName, path: string): Promise<string>;
}

declare type PanelType = 'DocsCardGrid' | 'DocsTable';
interface PanelConfig {
    title: string;
    description: string;
    panelType: PanelType;
    panelCSS?: CSSProperties;
    filterPredicate: (entity: Entity) => boolean;
}
interface TabConfig {
    label: string;
    panels: PanelConfig[];
}
declare type TabsConfig = TabConfig[];

declare const techdocsPlugin: BackstagePlugin<{
    root: RouteRef<undefined>;
    entityContent: RouteRef<undefined>;
}, {}>;
declare const TechdocsPage: () => JSX.Element;
declare const EntityTechdocsContent: (_props: {
    entity?: Entity | undefined;
}) => JSX.Element;
declare const DocsCardGrid: ({ entities, }: {
    entities: Entity[] | undefined;
}) => JSX.Element | null;
declare const DocsTable: ({ entities, title, }: {
    entities: Entity[] | undefined;
    title?: string | undefined;
}) => JSX.Element | null;
declare const TechDocsCustomHome: ({ tabsConfig, }: {
    tabsConfig: TabsConfig;
}) => JSX.Element;
declare const TechDocsReaderPage: () => JSX.Element;

declare type Props = {
    entityId: EntityName;
    onReady?: () => void;
};
declare const Reader: ({ entityId, onReady }: Props) => JSX.Element;

declare const Router: () => JSX.Element;
declare type Props$1 = {
    /** @deprecated The entity is now grabbed from context instead */
    entity?: Entity;
};
declare const EmbeddedDocsRouter: (_props: Props$1) => JSX.Element;

export { DocsCardGrid, DocsTable, EmbeddedDocsRouter, EntityTechdocsContent, PanelType, Reader, Router, TechDocsApi, TechDocsClient, TechDocsCustomHome, TechDocsReaderPage, TechDocsStorageApi, TechDocsStorageClient, TechdocsPage, techdocsPlugin as plugin, techdocsApiRef, techdocsPlugin, techdocsStorageApiRef };
