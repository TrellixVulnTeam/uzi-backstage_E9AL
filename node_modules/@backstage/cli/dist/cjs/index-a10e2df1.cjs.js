'use strict';

var index = require('./index-ce78e402.cjs.js');
var fs = require('fs-extra');
var path = require('path');
var run = require('./run-646af88e.cjs.js');
var os = require('os');
var tar = require('tar');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var tar__default = /*#__PURE__*/_interopDefaultLegacy(tar);

const UNSAFE_PACKAGES = [
  ...Object.keys(index.packageVersions),
  "@backstage/cli-common",
  "@backstage/config-loader"
];
async function createDistWorkspace(packageNames, options = {}) {
  var _a, _b, _c;
  const targetDir = (_a = options.targetDir) != null ? _a : await fs__default['default'].mkdtemp(path.resolve(os.tmpdir(), "dist-workspace"));
  const targets = await findTargetPackages(packageNames);
  if (options.buildDependencies) {
    const exclude = (_b = options.buildExcludes) != null ? _b : [];
    const scopeArgs = targets.filter((target) => !exclude.includes(target.name)).flatMap((target) => ["--scope", target.name]);
    const lernaArgs = options.parallel && Number.isInteger(options.parallel) ? ["--concurrency", options.parallel.toString()] : [];
    await run.run("yarn", ["lerna", ...lernaArgs, "run", ...scopeArgs, "build"], {
      cwd: index.paths.targetRoot
    });
  }
  await moveToDistWorkspace(targetDir, targets);
  const files = (_c = options.files) != null ? _c : ["yarn.lock", "package.json"];
  for (const file of files) {
    const src = typeof file === "string" ? file : file.src;
    const dest = typeof file === "string" ? file : file.dest;
    await fs__default['default'].copy(index.paths.resolveTargetRoot(src), path.resolve(targetDir, dest));
  }
  if (options.skeleton) {
    const skeletonFiles = targets.map((target) => {
      const dir = path.relative(index.paths.targetRoot, target.location);
      return path.join(dir, "package.json");
    });
    await tar__default['default'].create({
      file: path.resolve(targetDir, options.skeleton),
      cwd: targetDir,
      portable: true,
      noMtime: true,
      gzip: options.skeleton.endsWith(".gz")
    }, skeletonFiles);
  }
  return targetDir;
}
async function moveToDistWorkspace(workspaceDir, localPackages) {
  async function pack(target, archive) {
    console.log(`Repacking ${target.name} into dist workspace`);
    const archivePath = path.resolve(workspaceDir, archive);
    await run.run("yarn", ["pack", "--filename", archivePath], {
      cwd: target.location
    });
    if (target.scripts.postpack) {
      await run.run("yarn", ["postpack"], {cwd: target.location});
    }
    const outputDir = path.relative(index.paths.targetRoot, target.location);
    const absoluteOutputPath = path.resolve(workspaceDir, outputDir);
    await fs__default['default'].ensureDir(absoluteOutputPath);
    await tar__default['default'].extract({
      file: archivePath,
      cwd: absoluteOutputPath,
      strip: 1
    });
    await fs__default['default'].remove(archivePath);
    if (target.get("bundled")) {
      const pkgJson = await fs__default['default'].readJson(path.resolve(absoluteOutputPath, "package.json"));
      delete pkgJson.dependencies;
      delete pkgJson.devDependencies;
      delete pkgJson.peerDependencies;
      delete pkgJson.optionalDependencies;
      await fs__default['default'].writeJson(path.resolve(absoluteOutputPath, "package.json"), pkgJson, {
        spaces: 2
      });
    }
  }
  const unsafePackages = localPackages.filter((p) => UNSAFE_PACKAGES.includes(p.name));
  const safePackages = localPackages.filter((p) => !UNSAFE_PACKAGES.includes(p.name));
  for (const target of unsafePackages) {
    await pack(target, `temp-package.tgz`);
  }
  await Promise.all(safePackages.map(async (target, index) => pack(target, `temp-package-${index}.tgz`)));
}
async function findTargetPackages(pkgNames) {
  var _a;
  const {Project} = require("@lerna/project");
  const {PackageGraph} = require("@lerna/package-graph");
  const project = new Project(index.paths.targetDir);
  const packages = await project.getPackages();
  const graph = new PackageGraph(packages);
  const targets = new Map();
  const searchNames = pkgNames.slice();
  while (searchNames.length) {
    const name = searchNames.pop();
    if (targets.has(name)) {
      continue;
    }
    const node = graph.get(name);
    if (!node) {
      throw new Error(`Package '${name}' not found`);
    }
    if (!node.pkg.get("bundled")) {
      const pkgDeps = Object.keys((_a = node.pkg.dependencies) != null ? _a : {});
      const localDeps = Array.from(node.localDependencies.keys());
      const filteredDeps = localDeps.filter((dep) => pkgDeps.includes(dep));
      searchNames.push(...filteredDeps);
    }
    targets.set(name, node.pkg);
  }
  return Array.from(targets.values());
}

exports.createDistWorkspace = createDistWorkspace;
//# sourceMappingURL=index-a10e2df1.cjs.js.map
