'use strict';

require('commander');
var chalk = require('chalk');
var index = require('./index-ce78e402.cjs.js');
var fs = require('fs-extra');
require('@backstage/cli-common');
require('@backstage/config/package.json');
var path = require('path');
require('child_process');
require('util');
var run = require('./run-646af88e.cjs.js');
var semver = require('semver');
require('@yarnpkg/lockfile');
var lint = require('./lint-e7ba3595.cjs.js');
require('lodash/partition');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var semver__default = /*#__PURE__*/_interopDefaultLegacy(semver);

const PREFIX = "@backstage";
const DEP_TYPES = [
  "dependencies",
  "devDependencies",
  "peerDependencies",
  "optionalDependencies"
];
async function fetchPackageInfo(name) {
  const output = await run.runPlain("yarn", "info", "--json", name);
  if (!output) {
    throw new index.NotFoundError(`No package information found for package ${name}`);
  }
  const info = JSON.parse(output);
  if (info.type !== "inspect") {
    throw new Error(`Received unknown yarn info for ${name}, ${output}`);
  }
  return info.data;
}
async function mapDependencies(targetDir) {
  var _a;
  const {Project} = require("@lerna/project");
  const project = new Project(targetDir);
  const packages = await project.getPackages();
  const dependencyMap = new Map();
  for (const pkg of packages) {
    const deps = DEP_TYPES.flatMap((t) => {
      var _a2;
      return Object.entries((_a2 = pkg.get(t)) != null ? _a2 : {});
    });
    for (const [name, range] of deps) {
      if (name.startsWith(PREFIX)) {
        dependencyMap.set(name, ((_a = dependencyMap.get(name)) != null ? _a : []).concat({
          range,
          name: pkg.name,
          location: pkg.location
        }));
      }
    }
  }
  return dependencyMap;
}

const DEP_TYPES$1 = [
  "dependencies",
  "devDependencies",
  "peerDependencies",
  "optionalDependencies"
];
var bump = async () => {
  var _a;
  const lockfilePath = index.paths.resolveTargetRoot("yarn.lock");
  const lockfile = await lint.Lockfile.load(lockfilePath);
  const findTargetVersion = createVersionFinder();
  const dependencyMap = await mapDependencies(index.paths.targetDir);
  const versionBumps = new Map();
  const unlocked = Array();
  await workerThreads(16, dependencyMap.entries(), async ([name, pkgs]) => {
    var _a2, _b;
    let target;
    try {
      target = await findTargetVersion(name);
    } catch (error) {
      if (error.name === "NotFoundError") {
        console.log(`Package info not found, ignoring package ${name}`);
        return;
      }
      throw error;
    }
    for (const pkg of pkgs) {
      if (semver__default['default'].satisfies(target, pkg.range)) {
        if (((_a2 = semver__default['default'].minVersion(pkg.range)) == null ? void 0 : _a2.version) !== target) {
          unlocked.push({name, range: pkg.range, target});
        }
        continue;
      }
      versionBumps.set(pkg.name, ((_b = versionBumps.get(pkg.name)) != null ? _b : []).concat({
        name,
        location: pkg.location,
        range: `^${target}`,
        target
      }));
    }
  });
  await workerThreads(16, lockfile.keys(), async (name) => {
    var _a2;
    if (!lint.includedFilter(name)) {
      return;
    }
    let target;
    try {
      target = await findTargetVersion(name);
    } catch (error) {
      if (error.name === "NotFoundError") {
        console.log(`Package info not found, ignoring package ${name}`);
        return;
      }
      throw error;
    }
    for (const entry of (_a2 = lockfile.get(name)) != null ? _a2 : []) {
      if (!semver__default['default'].satisfies(target, entry.range)) {
        continue;
      }
      unlocked.push({name, range: entry.range, target});
    }
  });
  console.log();
  if (versionBumps.size === 0 && unlocked.length === 0) {
    console.log(chalk__default['default'].green("All Backstage packages are up to date!"));
  } else {
    console.log(chalk__default['default'].yellow("Some packages are outdated, updating"));
    console.log();
    if (unlocked.length > 0) {
      const removed = new Set();
      for (const {name, range, target} of unlocked) {
        const existingEntry = (_a = lockfile.get(name)) == null ? void 0 : _a.find((e) => e.range === range);
        if ((existingEntry == null ? void 0 : existingEntry.version) === target) {
          continue;
        }
        const key = JSON.stringify({name, range});
        if (!removed.has(key)) {
          removed.add(key);
          console.log(`${chalk__default['default'].magenta("unlocking")} ${name}@${chalk__default['default'].yellow(range)} ~> ${chalk__default['default'].yellow(target)}`);
          lockfile.remove(name, range);
        }
      }
      await lockfile.save();
    }
    const breakingUpdates = new Map();
    await workerThreads(16, versionBumps.entries(), async ([name, deps]) => {
      var _a2;
      const pkgPath = path.resolve(deps[0].location, "package.json");
      const pkgJson = await fs__default['default'].readJson(pkgPath);
      for (const dep of deps) {
        console.log(`${chalk__default['default'].cyan("bumping")} ${dep.name} in ${chalk__default['default'].cyan(name)} to ${chalk__default['default'].yellow(dep.range)}`);
        for (const depType of DEP_TYPES$1) {
          if (depType in pkgJson && dep.name in pkgJson[depType]) {
            const oldRange = pkgJson[depType][dep.name];
            pkgJson[depType][dep.name] = dep.range;
            const lockfileEntry = (_a2 = lockfile.get(dep.name)) == null ? void 0 : _a2.find((entry) => entry.range === oldRange);
            if (lockfileEntry) {
              const from = lockfileEntry.version;
              const to = dep.target;
              if (!semver__default['default'].satisfies(to, `^${from}`)) {
                breakingUpdates.set(dep.name, {from, to});
              }
            }
          }
        }
      }
      await fs__default['default'].writeJson(pkgPath, pkgJson, {spaces: 2});
    });
    console.log();
    console.log(`Running ${chalk__default['default'].blue("yarn install")} to install new versions`);
    console.log();
    await run.run("yarn", ["install"]);
    if (breakingUpdates.size > 0) {
      console.log();
      console.log(chalk__default['default'].yellow("\u26A0\uFE0F  The following packages may have breaking changes:"));
      console.log();
      for (const [name, {from, to}] of Array.from(breakingUpdates.entries()).sort()) {
        console.log(`  ${chalk__default['default'].yellow(name)} : ${chalk__default['default'].yellow(from)} ~> ${chalk__default['default'].yellow(to)}`);
        let path;
        if (name.startsWith("@backstage/plugin-")) {
          path = `plugins/${name.replace("@backstage/plugin-", "")}`;
        } else if (name.startsWith("@backstage/")) {
          path = `packages/${name.replace("@backstage/", "")}`;
        }
        if (path) {
          console.log(`    https://github.com/backstage/backstage/blob/master/${path}/CHANGELOG.md`);
        }
        console.log();
      }
    } else {
      console.log();
    }
    console.log(chalk__default['default'].green("Version bump complete!"));
  }
  console.log();
  const dedupLockfile = await lint.Lockfile.load(lockfilePath);
  const result = dedupLockfile.analyze({
    filter: lint.includedFilter
  });
  if (result.newVersions.length > 0) {
    throw new Error("Duplicate versions present after package bump");
  }
  const forbiddenNewRanges = result.newRanges.filter(({name}) => lint.forbiddenDuplicatesFilter(name));
  if (forbiddenNewRanges.length > 0) {
    throw new Error(`Version bump failed for ${forbiddenNewRanges.map((i) => i.name).join(", ")}`);
  }
};
function createVersionFinder() {
  const found = new Map();
  return async function findTargetVersion(name) {
    const existing = found.get(name);
    if (existing) {
      return existing;
    }
    console.log(`Checking for updates of ${name}`);
    const info = await fetchPackageInfo(name);
    const latest = info["dist-tags"].latest;
    if (!latest) {
      throw new Error(`No latest version found for ${name}`);
    }
    found.set(name, latest);
    return latest;
  };
}
async function workerThreads(count, items, fn) {
  const queue = Array.from(items);
  async function pop() {
    const item = queue.pop();
    if (!item) {
      return;
    }
    await fn(item);
    await pop();
  }
  return Promise.all(Array(count).fill(0).map(() => pop()));
}

exports.default = bump;
//# sourceMappingURL=bump-49d4f056.cjs.js.map
