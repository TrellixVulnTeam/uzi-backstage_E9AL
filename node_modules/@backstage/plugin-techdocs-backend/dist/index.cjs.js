'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var techdocsCommon = require('@backstage/techdocs-common');
var fetch = require('cross-fetch');
var Router = require('express-promise-router');
var fs = require('fs-extra');
var os = require('os');
var path = require('path');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

const lastUpdatedRecord = {};
class BuildMetadataStorage {
  constructor(entityUid) {
    this.entityUid = entityUid;
    this.lastUpdatedRecord = lastUpdatedRecord;
  }
  setLastUpdated() {
    this.lastUpdatedRecord[this.entityUid] = Date.now();
  }
  getLastUpdated() {
    return this.lastUpdatedRecord[this.entityUid];
  }
}
const shouldCheckForUpdate = (entityUid) => {
  const lastUpdated = new BuildMetadataStorage(entityUid).getLastUpdated();
  if (lastUpdated) {
    if (Date.now() - lastUpdated < 60 * 1e3) {
      return false;
    }
  }
  return true;
};

class DocsBuilder {
  constructor({
    preparers,
    generators,
    publisher,
    entity,
    logger
  }) {
    this.preparer = preparers.get(entity);
    this.generator = generators.get(entity);
    this.publisher = publisher;
    this.entity = entity;
    this.logger = logger;
  }
  async build() {
    var _a;
    if (!this.entity.metadata.uid) {
      throw new Error("Trying to build documentation for entity not in service catalog");
    }
    this.logger.info(`Step 1 of 3: Preparing docs for entity ${catalogModel.serializeEntityRef(this.entity)}`);
    let storedEtag;
    if (await this.publisher.hasDocsBeenGenerated(this.entity)) {
      try {
        storedEtag = (await this.publisher.fetchTechDocsMetadata({
          namespace: (_a = this.entity.metadata.namespace) != null ? _a : catalogModel.ENTITY_DEFAULT_NAMESPACE,
          kind: this.entity.kind,
          name: this.entity.metadata.name
        })).etag;
      } catch (err) {
        this.logger.warn(`Unable to read techdocs_metadata.json, proceeding with fresh build, error ${err}.`);
      }
    }
    let preparedDir;
    let newEtag;
    try {
      const preparerResponse = await this.preparer.prepare(this.entity, {
        etag: storedEtag
      });
      preparedDir = preparerResponse.preparedDir;
      newEtag = preparerResponse.etag;
    } catch (err) {
      if (err instanceof errors.NotModifiedError) {
        new BuildMetadataStorage(this.entity.metadata.uid).setLastUpdated();
        this.logger.debug(`Docs for ${catalogModel.serializeEntityRef(this.entity)} are unmodified. Using cache, skipping generate and prepare`);
        return;
      }
      throw new Error(err.message);
    }
    this.logger.info(`Prepare step completed for entity ${catalogModel.serializeEntityRef(this.entity)}, stored at ${preparedDir}`);
    this.logger.info(`Step 2 of 3: Generating docs for entity ${catalogModel.serializeEntityRef(this.entity)}`);
    const tmpdirPath = os__default['default'].tmpdir();
    const tmpdirResolvedPath = fs__default['default'].realpathSync(tmpdirPath);
    const outputDir = await fs__default['default'].mkdtemp(path__default['default'].join(tmpdirResolvedPath, "techdocs-tmp-"));
    const parsedLocationAnnotation = techdocsCommon.getLocationForEntity(this.entity);
    await this.generator.run({
      inputDir: preparedDir,
      outputDir,
      parsedLocationAnnotation,
      etag: newEtag
    });
    if (this.preparer instanceof techdocsCommon.UrlPreparer) {
      this.logger.debug(`Removing prepared directory ${preparedDir} since the site has been generated`);
      try {
        fs__default['default'].remove(preparedDir);
      } catch (error) {
        this.logger.debug(`Error removing prepared directory ${error.message}`);
      }
    }
    this.logger.info(`Step 3 of 3: Publishing docs for entity ${catalogModel.serializeEntityRef(this.entity)}`);
    await this.publisher.publish({
      entity: this.entity,
      directory: outputDir
    });
    try {
      fs__default['default'].remove(outputDir);
      this.logger.debug(`Removing generated directory ${outputDir} since the site has been published`);
    } catch (error) {
      this.logger.debug(`Error removing generated directory ${error.message}`);
    }
    new BuildMetadataStorage(this.entity.metadata.uid).setLastUpdated();
  }
}

async function createRouter({
  preparers,
  generators,
  publisher,
  config,
  logger,
  discovery
}) {
  const router = Router__default['default']();
  router.get("/metadata/techdocs/:namespace/:kind/:name", async (req, res) => {
    const {kind, namespace, name} = req.params;
    const entityName = {kind, namespace, name};
    try {
      const techdocsMetadata = await publisher.fetchTechDocsMetadata(entityName);
      res.json(techdocsMetadata);
    } catch (err) {
      logger.info(`Unable to get metadata for '${catalogModel.stringifyEntityRef(entityName)}' with error ${err}`);
      throw new errors.NotFoundError(`Unable to get metadata for '${catalogModel.stringifyEntityRef(entityName)}'`, err);
    }
  });
  router.get("/metadata/entity/:namespace/:kind/:name", async (req, res) => {
    const catalogUrl = await discovery.getBaseUrl("catalog");
    const {kind, namespace, name} = req.params;
    const entityName = {kind, namespace, name};
    try {
      const token = getBearerToken(req.headers.authorization);
      const entity = await (await fetch__default['default'](`${catalogUrl}/entities/by-name/${kind}/${namespace}/${name}`, {
        headers: token ? {Authorization: `Bearer ${token}`} : {}
      })).json();
      const locationMetadata = techdocsCommon.getLocationForEntity(entity);
      res.json({...entity, locationMetadata});
    } catch (err) {
      logger.info(`Unable to get metadata for '${catalogModel.stringifyEntityRef(entityName)}' with error ${err}`);
      throw new errors.NotFoundError(`Unable to get metadata for '${catalogModel.stringifyEntityRef(entityName)}'`, err);
    }
  });
  router.get("/sync/:namespace/:kind/:name", async (req, res) => {
    const {kind, namespace, name} = req.params;
    const catalogUrl = await discovery.getBaseUrl("catalog");
    const triple = [kind, namespace, name].map(encodeURIComponent).join("/");
    const token = getBearerToken(req.headers.authorization);
    const catalogRes = await fetch__default['default'](`${catalogUrl}/entities/by-name/${triple}`, {
      headers: token ? {Authorization: `Bearer ${token}`} : {}
    });
    if (!catalogRes.ok) {
      const catalogResText = await catalogRes.text();
      res.status(catalogRes.status);
      res.send(catalogResText);
      return;
    }
    const entity = await catalogRes.json();
    if (!entity.metadata.uid) {
      throw new errors.NotFoundError("Entity metadata UID missing");
    }
    if (!shouldCheckForUpdate(entity.metadata.uid)) {
      res.status(200).json({
        message: `Last check for documentation update is recent, did not retry.`
      });
      return;
    }
    let publisherType = "";
    try {
      publisherType = config.getString("techdocs.publisher.type");
    } catch (err) {
      throw new Error("Unable to get techdocs.publisher.type in your app config. Set it to either 'local', 'googleGcs' or other support storage providers. Read more here https://backstage.io/docs/features/techdocs/architecture");
    }
    if (config.getString("techdocs.builder") !== "local") {
      res.status(200).json({
        message: "`techdocs.builder` app config is not set to `local`, so docs will not be generated locally and sync is not required."
      });
      return;
    }
    const docsBuilder = new DocsBuilder({
      preparers,
      generators,
      publisher,
      logger,
      entity
    });
    let foundDocs = false;
    switch (publisherType) {
      case "local":
      case "awsS3":
      case "azureBlobStorage":
      case "openStackSwift":
      case "googleGcs":
        await docsBuilder.build();
        for (let attempt = 0; attempt < 5; attempt++) {
          if (await publisher.hasDocsBeenGenerated(entity)) {
            foundDocs = true;
            break;
          }
          await new Promise((r) => setTimeout(r, 1e3));
        }
        if (!foundDocs) {
          logger.error("Published files are taking longer to show up in storage. Something went wrong.");
          throw new errors.NotFoundError("Sorry! It took too long for the generated docs to show up in storage. Check back later.");
        }
        res.status(201).json({message: "Docs updated or did not need updating"});
        break;
      default:
        throw new errors.NotFoundError(`Publisher type ${publisherType} is not supported by techdocs-backend docs builder.`);
    }
  });
  router.use("/static/docs", publisher.docsRouter());
  return router;
}
function getBearerToken(header) {
  var _a;
  return (_a = header == null ? void 0 : header.match(/(?:Bearer)\s+(\S+)/i)) == null ? void 0 : _a[1];
}

Object.keys(techdocsCommon).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return techdocsCommon[k];
    }
  });
});
exports.createRouter = createRouter;
//# sourceMappingURL=index.cjs.js.map
