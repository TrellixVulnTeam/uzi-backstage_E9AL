import { createApiRef, createRouteRef, createPlugin, createApiFactory, discoveryApiRef, createRoutableExtension, createComponentExtension, StatusWarning, StatusAborted, StatusOK, StatusError, StatusRunning, StatusPending, useApi, errorApiRef, InfoCard, StructuredMetadataTable, WarningPanel, Content, useRouteRefParams, Breadcrumbs, Link as Link$1, Table as Table$1, MissingAnnotationEmptyState } from '@backstage/core';
import { makeStyles, LinearProgress, Link, Typography, Box, TableContainer, Paper, Table, TableBody, TableRow, TableCell, Tooltip, IconButton } from '@material-ui/core';
import ExternalLinkIcon from '@material-ui/icons/Launch';
import { DateTime, Duration } from 'luxon';
import React, { useState, useRef, useCallback } from 'react';
import { useAsyncRetry } from 'react-use';
import { useEntity } from '@backstage/plugin-catalog-react';
import { Routes, Route } from 'react-router';
import { makeStyles as makeStyles$1 } from '@material-ui/core/styles';
import RetryIcon from '@material-ui/icons/Replay';
import JenkinsLogo from './assets/JenkinsLogo.svg';
import { Link as Link$2, generatePath } from 'react-router-dom';

const jenkins = require("jenkins");
const jenkinsApiRef = createApiRef({
  id: "plugin.jenkins.service",
  description: "Used by the Jenkins plugin to make requests"
});
const DEFAULT_PROXY_PATH = "/jenkins/api";
class JenkinsApi {
  constructor(options) {
    var _a;
    this.discoveryApi = options.discoveryApi;
    this.proxyPath = (_a = options.proxyPath) != null ? _a : DEFAULT_PROXY_PATH;
  }
  async getClient() {
    const proxyUrl = await this.discoveryApi.getBaseUrl("proxy");
    return jenkins({baseUrl: proxyUrl + this.proxyPath, promisify: true});
  }
  async retry(buildName) {
    const client = await this.getClient();
    return await client.job.build(buildName);
  }
  async getLastBuild(jobName) {
    const client = await this.getClient();
    const job = await client.job.get(jobName);
    const lastBuild = await client.build.get(jobName, job.lastBuild.number);
    return lastBuild;
  }
  extractScmDetailsFromJob(jobDetails) {
    const scmInfo = jobDetails.actions.filter((action) => action._class === "jenkins.scm.api.metadata.ObjectMetadataAction").map((action) => {
      return {
        url: action == null ? void 0 : action.objectUrl,
        displayName: action == null ? void 0 : action.objectDisplayName
      };
    }).pop();
    if (!scmInfo) {
      return void 0;
    }
    const author = jobDetails.actions.filter((action) => action._class === "jenkins.scm.api.metadata.ContributorMetadataAction").map((action) => {
      return action.contributorDisplayName;
    }).pop();
    if (author) {
      scmInfo.author = author;
    }
    return scmInfo;
  }
  async getJob(jobName) {
    const client = await this.getClient();
    return client.job.get({
      name: jobName,
      depth: 1
    });
  }
  async getFolder(folderName) {
    const client = await this.getClient();
    const folder = await client.job.get({
      name: folderName,
      tree: `jobs[
               actions[*],
               builds[
                number,
                url,
                fullDisplayName,
                building,
                result,
                actions[
                  *[
                    *[
                      *[
                        *
                      ]
                    ]
                  ]
                ]
              ]{0,1},
              jobs{0,1},
              name
            ]{0,50}
            `.replace(/\s/g, "")
    });
    const results = [];
    for (const jobDetails of folder.jobs) {
      const jobScmInfo = this.extractScmDetailsFromJob(jobDetails);
      if (jobDetails == null ? void 0 : jobDetails.jobs) ; else {
        for (const buildDetails of jobDetails.builds) {
          const ciTable = this.mapJenkinsBuildToCITable(buildDetails, jobScmInfo);
          results.push(ciTable);
        }
      }
    }
    return results;
  }
  getTestReport(jenkinsResult) {
    return jenkinsResult.actions.filter((action) => action._class === "hudson.tasks.junit.TestResultAction").map((action) => {
      return {
        total: action.totalCount,
        passed: action.totalCount - action.failCount - action.skipCount,
        skipped: action.skipCount,
        failed: action.failCount,
        testUrl: `${jenkinsResult.url}${action.urlName}/`
      };
    }).pop();
  }
  mapJenkinsBuildToCITable(jenkinsResult, jobScmInfo) {
    const source = jenkinsResult.actions.filter((action) => action._class === "hudson.plugins.git.util.BuildData").map((action) => {
      const [first] = Object.values(action.buildsByBranchName);
      const branch = first.revision.branch[0];
      return {
        branchName: branch.name,
        commit: {
          hash: branch.SHA1.substring(0, 8)
        }
      };
    }).pop() || {};
    if (jobScmInfo) {
      source.url = jobScmInfo == null ? void 0 : jobScmInfo.url;
      source.displayName = jobScmInfo == null ? void 0 : jobScmInfo.displayName;
      source.author = jobScmInfo == null ? void 0 : jobScmInfo.author;
    }
    const path = new URL(jenkinsResult.url).pathname;
    return {
      id: path,
      buildNumber: jenkinsResult.number,
      buildUrl: jenkinsResult.url,
      buildName: jenkinsResult.fullDisplayName,
      status: jenkinsResult.building ? "running" : jenkinsResult.result,
      onRestartClick: () => {
        const {jobName} = this.extractJobDetailsFromBuildName(path);
        return this.retry(jobName);
      },
      source,
      tests: this.getTestReport(jenkinsResult)
    };
  }
  async getBuild(buildName) {
    const client = await this.getClient();
    const {jobName, buildNumber} = this.extractJobDetailsFromBuildName(buildName);
    const buildResult = await client.build.get(jobName, buildNumber);
    return buildResult;
  }
  extractJobDetailsFromBuildName(buildName) {
    const trimmedBuild = buildName.replace(/\/job/g, "").replace(/\/$/, "");
    const split = trimmedBuild.split("/");
    const buildNumber = parseInt(split[split.length - 1], 10);
    const jobName = trimmedBuild.slice(0, trimmedBuild.length - buildNumber.toString(10).length - 1);
    return {
      jobName,
      buildNumber
    };
  }
}

const rootRouteRef = createRouteRef({
  path: "",
  title: "Jenkins"
});
const buildRouteRef = createRouteRef({
  path: "run/:branch/:buildNumber",
  params: ["branch", "buildNumber"],
  title: "Jenkins run"
});
const jenkinsPlugin = createPlugin({
  id: "jenkins",
  apis: [
    createApiFactory({
      api: jenkinsApiRef,
      deps: {discoveryApi: discoveryApiRef},
      factory: ({discoveryApi}) => new JenkinsApi({discoveryApi})
    })
  ],
  routes: {
    entityContent: rootRouteRef
  }
});
const EntityJenkinsContent = jenkinsPlugin.provide(createRoutableExtension({
  component: () => Promise.resolve().then(function () { return Router$1; }).then((m) => m.Router),
  mountPoint: rootRouteRef
}));
const EntityLatestJenkinsRunCard = jenkinsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./esm/index-f777366c.esm.js').then((m) => m.LatestRunCard)
  }
}));

const JenkinsRunStatus = ({
  status
}) => {
  if (status === void 0)
    return null;
  switch (status.toLocaleLowerCase("en-US")) {
    case "queued":
    case "scheduled":
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusPending, null), " Queued");
    case "running":
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusRunning, null), " In progress");
    case "unstable":
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusWarning, null), " Unstable");
    case "failure":
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusError, null), " Failed");
    case "success":
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusOK, null), " Completed");
    case "aborted":
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusAborted, null), " Aborted");
    default:
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(StatusWarning, null), " ", status);
  }
};

var ErrorType;
(function(ErrorType2) {
  ErrorType2[ErrorType2["CONNECTION_ERROR"] = 0] = "CONNECTION_ERROR";
  ErrorType2[ErrorType2["NOT_FOUND"] = 1] = "NOT_FOUND";
})(ErrorType || (ErrorType = {}));
function useBuilds(projectName, branch) {
  const api = useApi(jenkinsApiRef);
  const errorApi = useApi(errorApiRef);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(0);
  const [pageSize, setPageSize] = useState(5);
  const [error, setError] = useState();
  const restartBuild = async (buildName) => {
    try {
      await api.retry(buildName);
    } catch (e) {
      errorApi.post(e);
    }
  };
  const {loading, value: builds, retry} = useAsyncRetry(async () => {
    try {
      let build;
      if (branch) {
        build = await api.getLastBuild(`${projectName}/${branch}`);
      } else {
        build = await api.getFolder(`${projectName}`);
      }
      const size = Array.isArray(build) ? build == null ? void 0 : build[0].build_num : 1;
      setTotal(size);
      return build || [];
    } catch (e) {
      const errorType = e.notFound ? 1 : 0;
      setError({message: e.message, errorType});
      throw e;
    }
  }, [api, errorApi, projectName, branch]);
  return [
    {
      page,
      pageSize,
      loading,
      builds,
      projectName,
      total,
      error
    },
    {
      builds,
      setPage,
      setPageSize,
      restartBuild,
      retry
    }
  ];
}

const JENKINS_ANNOTATION = "jenkins.io/github-folder";

const useProjectSlugFromEntity = () => {
  var _a, _b;
  const {entity} = useEntity();
  return (_b = (_a = entity.metadata.annotations) == null ? void 0 : _a[JENKINS_ANNOTATION]) != null ? _b : "";
};

const useStyles = makeStyles({
  externalLinkIcon: {
    fontSize: "inherit",
    verticalAlign: "bottom"
  }
});
const WidgetContent = ({
  loading,
  latestRun
}) => {
  var _a;
  const classes = useStyles();
  if (loading || !latestRun)
    return /* @__PURE__ */ React.createElement(LinearProgress, null);
  const displayDate = DateTime.fromMillis(latestRun.timestamp).toRelative();
  const displayDuration = (latestRun.building ? "Running for " : "") + ((_a = DateTime.local().minus(Duration.fromMillis(latestRun.duration)).toRelative({locale: "en"})) == null ? void 0 : _a.replace(" ago", ""));
  return /* @__PURE__ */ React.createElement(StructuredMetadataTable, {
    metadata: {
      status: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(JenkinsRunStatus, {
        status: latestRun.building ? "running" : latestRun.result
      })),
      build: latestRun.fullDisplayName,
      "latest run": displayDate,
      duration: displayDuration,
      link: /* @__PURE__ */ React.createElement(Link, {
        href: latestRun.url,
        target: "_blank"
      }, "See more on Jenkins", " ", /* @__PURE__ */ React.createElement(ExternalLinkIcon, {
        className: classes.externalLinkIcon
      }))
    }
  });
};
const JenkinsApiErrorPanel = ({
  message,
  errorType
}) => {
  let title = void 0;
  if (errorType === ErrorType.CONNECTION_ERROR) {
    title = "Can't connect to Jenkins";
  } else if (errorType === ErrorType.NOT_FOUND) {
    title = "Can't find Jenkins project";
  }
  return /* @__PURE__ */ React.createElement(WarningPanel, {
    severity: "error",
    title,
    message
  });
};
const LatestRunCard = ({
  branch = "master",
  variant
}) => {
  const projectName = useProjectSlugFromEntity();
  const [{builds, loading, error}] = useBuilds(projectName, branch);
  const latestRun = builds != null ? builds : {};
  return /* @__PURE__ */ React.createElement(InfoCard, {
    title: `Latest ${branch} build`,
    variant
  }, !error ? /* @__PURE__ */ React.createElement(WidgetContent, {
    loading,
    branch,
    latestRun
  }) : /* @__PURE__ */ React.createElement(JenkinsApiErrorPanel, {
    message: error.message,
    errorType: error.errorType
  }));
};

const useAsyncPolling = (pollingFn, interval) => {
  const isPolling = useRef(false);
  const startPolling = async () => {
    if (isPolling.current === true)
      return;
    isPolling.current = true;
    while (isPolling.current === true) {
      await pollingFn();
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
  };
  const stopPolling = () => {
    isPolling.current = false;
  };
  return {startPolling, stopPolling};
};

const INTERVAL_AMOUNT = 1500;
function useBuildWithSteps(buildName) {
  const api = useApi(jenkinsApiRef);
  const errorApi = useApi(errorApiRef);
  const getBuildWithSteps = useCallback(async () => {
    try {
      const build = await api.getBuild(buildName);
      const {jobName} = api.extractJobDetailsFromBuildName(buildName);
      const job = await api.getJob(jobName);
      const jobInfo = api.extractScmDetailsFromJob(job);
      return Promise.resolve(api.mapJenkinsBuildToCITable(build, jobInfo));
    } catch (e) {
      errorApi.post(e);
      return Promise.reject(e);
    }
  }, [buildName, api, errorApi]);
  const restartBuild = async () => {
    try {
      await api.retry(buildName);
    } catch (e) {
      errorApi.post(e);
    }
  };
  const {loading, value, retry} = useAsyncRetry(() => getBuildWithSteps(), [
    getBuildWithSteps
  ]);
  const {startPolling, stopPolling} = useAsyncPolling(getBuildWithSteps, INTERVAL_AMOUNT);
  return [
    {loading, value, retry},
    {
      restartBuild,
      getBuildWithSteps,
      startPolling,
      stopPolling
    }
  ];
}

const useStyles$1 = makeStyles$1((theme) => ({
  root: {
    maxWidth: 720
  },
  table: {
    padding: theme.spacing(1)
  },
  externalLinkIcon: {
    fontSize: "inherit",
    verticalAlign: "bottom"
  }
}));
const BuildWithStepsView = () => {
  var _a, _b, _c, _d, _e;
  const projectName = useProjectSlugFromEntity();
  const {branch, buildNumber} = useRouteRefParams(buildRouteRef);
  const classes = useStyles$1();
  const buildPath = `${projectName}/${branch}/${buildNumber}`;
  const [{value}] = useBuildWithSteps(buildPath);
  return /* @__PURE__ */ React.createElement("div", {
    className: classes.root
  }, /* @__PURE__ */ React.createElement(Breadcrumbs, {
    "aria-label": "breadcrumb"
  }, /* @__PURE__ */ React.createElement(Link$1, {
    to: "../../.."
  }, "Projects"), /* @__PURE__ */ React.createElement(Typography, null, "Run")), /* @__PURE__ */ React.createElement(Box, {
    m: 2
  }), /* @__PURE__ */ React.createElement(TableContainer, {
    component: Paper,
    className: classes.table
  }, /* @__PURE__ */ React.createElement(Table, null, /* @__PURE__ */ React.createElement(TableBody, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Branch")), /* @__PURE__ */ React.createElement(TableCell, null, (_a = value == null ? void 0 : value.source) == null ? void 0 : _a.branchName)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Message")), /* @__PURE__ */ React.createElement(TableCell, null, (_b = value == null ? void 0 : value.source) == null ? void 0 : _b.displayName)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Commit ID")), /* @__PURE__ */ React.createElement(TableCell, null, (_d = (_c = value == null ? void 0 : value.source) == null ? void 0 : _c.commit) == null ? void 0 : _d.hash)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Status")), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(JenkinsRunStatus, {
    status: value == null ? void 0 : value.status
  }))), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Author")), /* @__PURE__ */ React.createElement(TableCell, null, (_e = value == null ? void 0 : value.source) == null ? void 0 : _e.author)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "Jenkins")), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Link, {
    target: "_blank",
    href: value == null ? void 0 : value.buildUrl
  }, "View on Jenkins", " ", /* @__PURE__ */ React.createElement(ExternalLinkIcon, {
    className: classes.externalLinkIcon
  })))), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, {
    noWrap: true
  }, "GitHub")), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Link, {
    target: "_blank",
    href: value == null ? void 0 : value.source.url
  }, "View on GitHub", " ", /* @__PURE__ */ React.createElement(ExternalLinkIcon, {
    className: classes.externalLinkIcon
  }))))))));
};
const Page = () => /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(BuildWithStepsView, null));

const FailCount = ({count}) => {
  if (count !== 0) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, count, " failed");
  }
  return null;
};
const SkippedCount = ({count}) => {
  if (count !== 0) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, count, " skipped");
  }
  return null;
};
const FailSkippedWidget = ({
  skipped,
  failed
}) => {
  if (skipped === 0 && failed === 0) {
    return null;
  }
  if (skipped !== 0 && failed !== 0) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, " ", "(", /* @__PURE__ */ React.createElement(FailCount, {
      count: failed
    }), ", ", /* @__PURE__ */ React.createElement(SkippedCount, {
      count: skipped
    }), ")");
  }
  if (failed !== 0) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, " ", "(", /* @__PURE__ */ React.createElement(FailCount, {
      count: failed
    }), ")");
  }
  if (skipped !== 0) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, " ", "(", /* @__PURE__ */ React.createElement(SkippedCount, {
      count: skipped
    }), ")");
  }
  return null;
};
const generatedColumns = [
  {
    title: "Build",
    field: "buildName",
    highlight: true,
    render: (row) => {
      var _a;
      if (!((_a = row.source) == null ? void 0 : _a.branchName) || !row.buildNumber) {
        return /* @__PURE__ */ React.createElement(React.Fragment, null, row.buildName);
      }
      return /* @__PURE__ */ React.createElement(Link, {
        component: Link$2,
        to: generatePath(buildRouteRef.path, {
          branch: row.source.branchName,
          buildNumber: row.buildNumber.toString()
        })
      }, row.buildName);
    }
  },
  {
    title: "Source",
    field: "source.branchName",
    render: (row) => {
      var _a, _b, _c, _d;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", null, /* @__PURE__ */ React.createElement(Link, {
        href: ((_a = row.source) == null ? void 0 : _a.url) || "",
        target: "_blank"
      }, (_b = row.source) == null ? void 0 : _b.branchName)), /* @__PURE__ */ React.createElement("p", null, (_d = (_c = row.source) == null ? void 0 : _c.commit) == null ? void 0 : _d.hash));
    }
  },
  {
    title: "Status",
    field: "status",
    render: (row) => {
      return /* @__PURE__ */ React.createElement(Box, {
        display: "flex",
        alignItems: "center"
      }, /* @__PURE__ */ React.createElement(JenkinsRunStatus, {
        status: row.status
      }));
    }
  },
  {
    title: "Tests",
    sorting: false,
    render: (row) => {
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", null, row.tests && /* @__PURE__ */ React.createElement(Link, {
        href: row.tests.testUrl || "",
        target: "_blank"
      }, row.tests.passed, " / ", row.tests.total, " passed", /* @__PURE__ */ React.createElement(FailSkippedWidget, {
        skipped: row.tests.skipped,
        failed: row.tests.failed
      })), !row.tests && "n/a"));
    }
  },
  {
    title: "Actions",
    sorting: false,
    render: (row) => /* @__PURE__ */ React.createElement(Tooltip, {
      title: "Rerun build"
    }, /* @__PURE__ */ React.createElement(IconButton, {
      onClick: row.onRestartClick
    }, /* @__PURE__ */ React.createElement(RetryIcon, null))),
    width: "10%"
  }
];
const CITableView = ({
  projectName,
  loading,
  pageSize,
  page,
  retry,
  builds,
  onChangePage,
  onChangePageSize,
  total
}) => {
  return /* @__PURE__ */ React.createElement(Table$1, {
    isLoading: loading,
    options: {paging: true, pageSize, padding: "dense"},
    totalCount: total,
    page,
    actions: [
      {
        icon: () => /* @__PURE__ */ React.createElement(RetryIcon, null),
        tooltip: "Refresh Data",
        isFreeAction: true,
        onClick: () => retry()
      }
    ],
    data: builds != null ? builds : [],
    onChangePage,
    onChangeRowsPerPage: onChangePageSize,
    title: /* @__PURE__ */ React.createElement(Box, {
      display: "flex",
      alignItems: "center"
    }, /* @__PURE__ */ React.createElement("img", {
      src: JenkinsLogo,
      alt: "Jenkins logo",
      height: "50px"
    }), /* @__PURE__ */ React.createElement(Box, {
      mr: 2
    }), /* @__PURE__ */ React.createElement(Typography, {
      variant: "h6"
    }, "Project: ", projectName)),
    columns: generatedColumns
  });
};
const CITable = () => {
  const projectName = useProjectSlugFromEntity();
  const [tableProps, {setPage, retry, setPageSize}] = useBuilds(projectName);
  return /* @__PURE__ */ React.createElement(CITableView, {
    ...tableProps,
    retry,
    onChangePageSize: setPageSize,
    onChangePage: setPage
  });
};

const isJenkinsAvailable = (entity) => {
  var _a;
  return Boolean((_a = entity.metadata.annotations) == null ? void 0 : _a[JENKINS_ANNOTATION]);
};
const Router = (_props) => {
  const {entity} = useEntity();
  if (!isJenkinsAvailable(entity)) {
    return /* @__PURE__ */ React.createElement(MissingAnnotationEmptyState, {
      annotation: JENKINS_ANNOTATION
    });
  }
  return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
    path: `/${rootRouteRef.path}`,
    element: /* @__PURE__ */ React.createElement(CITable, null)
  }), /* @__PURE__ */ React.createElement(Route, {
    path: `/${buildRouteRef.path}`,
    element: /* @__PURE__ */ React.createElement(Page, null)
  }));
};

var Router$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isJenkinsAvailable: isJenkinsAvailable,
  Router: Router
});

export { EntityJenkinsContent, EntityLatestJenkinsRunCard, JENKINS_ANNOTATION, JenkinsApi, LatestRunCard, Router, isJenkinsAvailable, isJenkinsAvailable as isPluginApplicableToEntity, jenkinsApiRef, jenkinsPlugin, jenkinsPlugin as plugin };
//# sourceMappingURL=index.esm.js.map
