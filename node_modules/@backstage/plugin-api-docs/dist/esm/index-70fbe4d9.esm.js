import { createApiRef, CodeSnippet, useApi, TabbedCard, CardTab, Progress, InfoCard, WarningPanel, Link, createRouteRef, createExternalRouteRef, useQueryParamState, Table, OverflowTooltip, configApiRef, Page, Header, useRouteRef, Content, ContentHeader, SupportButton, createPlugin, createApiFactory, createRoutableExtension, createComponentExtension } from '@backstage/core';
import { useEntity, EntityTable, useRelatedEntities, getEntityRelations, formatEntityRefTitle, EntityRefLink, EntityRefLinks, catalogApiRef } from '@backstage/plugin-catalog-react';
import { Alert } from '@material-ui/lab';
import React, { Suspense, useState, useEffect } from 'react';
import AsyncApi from '@asyncapi/react-component';
import '@asyncapi/react-component/lib/styles/fiori.css';
import { makeStyles, fade } from '@material-ui/core/styles';
import 'graphiql/graphiql.css';
import { buildSchema } from 'graphql';
import SwaggerUI from 'swagger-ui-react';
import 'swagger-ui-react/swagger-ui.css';
import { RELATION_CONSUMES_API, RELATION_HAS_PART, RELATION_PROVIDES_API, RELATION_API_CONSUMED_BY, RELATION_API_PROVIDED_BY, RELATION_PART_OF, RELATION_OWNED_BY } from '@backstage/catalog-model';
import { Typography, Chip, Button } from '@material-ui/core';
import { Link as Link$1 } from 'react-router-dom';
import { useAsync } from 'react-use';

const apiDocsConfigRef = createApiRef({
  id: "plugin.api-docs.config",
  description: "Used to configure api-docs widgets"
});

const PlainApiDefinitionWidget = ({definition, language}) => {
  return /* @__PURE__ */ React.createElement(CodeSnippet, {
    text: definition,
    language,
    showCopyCodeButton: true
  });
};

const ApiDefinitionCard = (_) => {
  const {entity} = useEntity();
  const config = useApi(apiDocsConfigRef);
  const {getApiDefinitionWidget} = config;
  if (!entity) {
    return /* @__PURE__ */ React.createElement(Alert, {
      severity: "error"
    }, "Could not fetch the API");
  }
  const definitionWidget = getApiDefinitionWidget(entity);
  if (definitionWidget) {
    return /* @__PURE__ */ React.createElement(TabbedCard, {
      title: entity.metadata.name
    }, /* @__PURE__ */ React.createElement(CardTab, {
      label: definitionWidget.title,
      key: "widget"
    }, definitionWidget.component(entity.spec.definition)), /* @__PURE__ */ React.createElement(CardTab, {
      label: "Raw",
      key: "raw"
    }, /* @__PURE__ */ React.createElement(PlainApiDefinitionWidget, {
      definition: entity.spec.definition,
      language: definitionWidget.rawLanguage || entity.spec.type
    })));
  }
  return /* @__PURE__ */ React.createElement(TabbedCard, {
    title: entity.metadata.name,
    children: [
      /* @__PURE__ */ React.createElement(CardTab, {
        label: entity.spec.type,
        key: "raw"
      }, /* @__PURE__ */ React.createElement(PlainApiDefinitionWidget, {
        definition: entity.spec.definition,
        language: entity.spec.type
      }))
    ]
  });
};

const useStyles = makeStyles((theme) => ({
  root: {
    "& .asyncapi": {
      "font-family": "inherit",
      background: "none"
    },
    "& h2": {
      ...theme.typography.h6
    },
    "& .text-teal": {
      color: theme.palette.primary.main
    },
    "& button": {
      ...theme.typography.button,
      background: "none",
      boxSizing: "border-box",
      minWidth: 64,
      borderRadius: theme.shape.borderRadius,
      transition: theme.transitions.create(["background-color", "box-shadow", "border"], {
        duration: theme.transitions.duration.short
      }),
      padding: "5px 15px",
      color: theme.palette.primary.main,
      border: `1px solid ${fade(theme.palette.primary.main, 0.5)}`,
      "&:hover": {
        textDecoration: "none",
        "&.Mui-disabled": {
          backgroundColor: "transparent"
        },
        border: `1px solid ${theme.palette.primary.main}`,
        backgroundColor: fade(theme.palette.primary.main, theme.palette.action.hoverOpacity),
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      "&.Mui-disabled": {
        color: theme.palette.action.disabled
      }
    },
    "& .asyncapi__collapse-button:hover": {
      color: theme.palette.primary.main
    },
    "& button.asyncapi__toggle-button": {
      "min-width": "inherit"
    },
    "& .asyncapi__info-list li": {
      "border-color": theme.palette.primary.main,
      "&:hover": {
        color: theme.palette.text.primary,
        "border-color": theme.palette.primary.main,
        "background-color": theme.palette.primary.main
      }
    },
    "& .asyncapi__info-list li a": {
      color: theme.palette.primary.main,
      "&:hover": {
        color: theme.palette.getContrastText(theme.palette.primary.main)
      }
    },
    "& .asyncapi__enum": {
      color: theme.palette.secondary.main
    },
    "& .asyncapi__info, .asyncapi__channel, .asyncapi__channels > div, .asyncapi__schema, .asyncapi__channel-operations-list .asyncapi__messages-list-item .asyncapi__message, .asyncapi__message, .asyncapi__server, .asyncapi__servers > div, .asyncapi__messages > div, .asyncapi__schemas > div": {
      "background-color": "inherit"
    },
    "& .asyncapi__channel-parameters-header, .asyncapi__channel-operations-header, .asyncapi__channel-operation-oneOf-subscribe-header, .asyncapi__channel-operation-oneOf-publish-header, .asyncapi__channel-operation-message-header,  .asyncapi__message-header, .asyncapi__message-header-title, .asyncapi__message-header-title > h3, .asyncapi__bindings, .asyncapi__bindings-header, .asyncapi__bindings-header > h4": {
      "background-color": "inherit",
      color: theme.palette.text.primary
    },
    "& .asyncapi__additional-properties-notice": {
      color: theme.palette.text.hint
    },
    "& .asyncapi__code, .asyncapi__code-pre": {
      background: theme.palette.background.default
    },
    "& .asyncapi__schema-example-header-title": {
      color: theme.palette.text.secondary
    },
    "& .asyncapi__message-headers-header, .asyncapi__message-payload-header, .asyncapi__server-variables-header, .asyncapi__server-security-header": {
      "background-color": "inherit",
      color: theme.palette.text.secondary
    },
    "& .asyncapi__table-header": {
      background: theme.palette.background.default
    },
    "& .asyncapi__table-body": {
      color: theme.palette.text.primary
    },
    "& .asyncapi__server-security-flow": {
      background: theme.palette.background.default,
      border: "none"
    },
    "& .asyncapi__server-security-flows-list a": {
      color: theme.palette.primary.main
    },
    "& .asyncapi__table-row--nested": {
      color: theme.palette.text.secondary
    }
  }
}));
const AsyncApiDefinitionWidget = ({definition}) => {
  const classes = useStyles();
  return /* @__PURE__ */ React.createElement("div", {
    className: classes.root
  }, /* @__PURE__ */ React.createElement(AsyncApi, {
    schema: definition
  }));
};

const GraphiQL = React.lazy(() => import('graphiql'));
const useStyles$1 = makeStyles(() => ({
  root: {
    height: "100%",
    display: "flex",
    flexFlow: "column nowrap"
  },
  graphiQlWrapper: {
    flex: 1,
    "@global": {
      ".graphiql-container": {
        boxSizing: "initial",
        height: "100%",
        minHeight: "600px",
        flex: "1 1 auto"
      }
    }
  }
}));
const GraphQlDefinitionWidget = ({definition}) => {
  const classes = useStyles$1();
  const schema = buildSchema(definition);
  return /* @__PURE__ */ React.createElement(Suspense, {
    fallback: /* @__PURE__ */ React.createElement(Progress, null)
  }, /* @__PURE__ */ React.createElement("div", {
    className: classes.root
  }, /* @__PURE__ */ React.createElement("div", {
    className: classes.graphiQlWrapper
  }, /* @__PURE__ */ React.createElement(GraphiQL, {
    fetcher: () => Promise.resolve(null),
    schema,
    docExplorerOpen: true,
    defaultSecondaryEditorOpen: false
  }))));
};

const useStyles$2 = makeStyles((theme) => ({
  root: {
    "& .swagger-ui, .info h1, .info h2, .info h3, .info h4, .info h": {
      "font-family": "inherit",
      color: theme.palette.text.primary
    },
    "& .scheme-container": {
      "background-color": theme.palette.background.default
    },
    "& .opblock-tag, .opblock-tag small, table thead tr td, table thead tr th": {
      color: theme.palette.text.primary,
      "border-color": theme.palette.divider
    },
    "& section.models, section.models.is-open h4": {
      "border-color": theme.palette.divider
    },
    "& .opblock .opblock-summary-description, .parameter__type, table.headers td, .model-title, .model .property.primitive, section h3": {
      color: theme.palette.text.secondary
    },
    "& .opblock .opblock-summary-operation-id, .opblock .opblock-summary-path, .opblock .opblock-summary-path__deprecated, .opblock .opblock-section-header h4, .parameter__name, .response-col_status, .response-col_links, .responses-inner h4, .swagger-ui .responses-inner h5, .opblock-section-header .btn, .tab li, .info li, .info p, .info table, section.models h4, .info .title, table.model tr.description, .property-row": {
      color: theme.palette.text.primary
    },
    "& .opblock .opblock-section-header, .model-box, section.models .model-container": {
      background: theme.palette.background.default
    },
    "& .prop-format, .parameter__in": {
      color: theme.palette.text.disabled
    },
    "& ": {
      color: theme.palette.text.primary,
      "border-color": theme.palette.divider
    },
    "& .opblock-description-wrapper p, .opblock-external-docs-wrapper p, .opblock-title_normal p, .response-control-media-type__accept-message, .opblock .opblock-section-header>label, .scheme-container .schemes>label, .info .base-url, .model": {
      color: theme.palette.text.hint
    },
    "& .parameter__name.required:after": {
      color: theme.palette.warning.dark
    },
    "& .prop-type": {
      color: theme.palette.primary.main
    }
  }
}));
const OpenApiDefinitionWidget = ({definition}) => {
  const classes = useStyles$2();
  const [def, setDef] = useState("");
  useEffect(() => {
    const timer = setTimeout(() => setDef(definition), 0);
    return () => clearTimeout(timer);
  }, [definition, setDef]);
  return /* @__PURE__ */ React.createElement("div", {
    className: classes.root
  }, /* @__PURE__ */ React.createElement(SwaggerUI, {
    spec: def
  }));
};

function defaultDefinitionWidgets() {
  return [
    {
      type: "openapi",
      title: "OpenAPI",
      rawLanguage: "yaml",
      component: (definition) => /* @__PURE__ */ React.createElement(OpenApiDefinitionWidget, {
        definition
      })
    },
    {
      type: "asyncapi",
      title: "AsyncAPI",
      rawLanguage: "yaml",
      component: (definition) => /* @__PURE__ */ React.createElement(AsyncApiDefinitionWidget, {
        definition
      })
    },
    {
      type: "graphql",
      title: "GraphQL",
      rawLanguage: "graphql",
      component: (definition) => /* @__PURE__ */ React.createElement(GraphQlDefinitionWidget, {
        definition
      })
    }
  ];
}

const ApiTypeTitle = ({apiEntity}) => {
  const config = useApi(apiDocsConfigRef);
  const definition = config.getApiDefinitionWidget(apiEntity);
  const type = definition ? definition.title : apiEntity.spec.type;
  return /* @__PURE__ */ React.createElement("span", null, type);
};

function createSpecApiTypeColumn() {
  return {
    title: "Type",
    field: "spec.type",
    render: (entity) => /* @__PURE__ */ React.createElement(ApiTypeTitle, {
      apiEntity: entity
    })
  };
}
const apiEntityColumns = [
  EntityTable.columns.createEntityRefColumn({defaultKind: "API"}),
  EntityTable.columns.createSystemColumn(),
  EntityTable.columns.createOwnerColumn(),
  EntityTable.columns.createSpecLifecycleColumn(),
  createSpecApiTypeColumn(),
  EntityTable.columns.createMetadataDescriptionColumn()
];

const ConsumedApisCard = ({variant = "gridItem"}) => {
  const {entity} = useEntity();
  const {entities, loading, error} = useRelatedEntities(entity, {
    type: RELATION_CONSUMES_API
  });
  if (loading) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "Consumed APIs"
    }, /* @__PURE__ */ React.createElement(Progress, null));
  }
  if (error || !entities) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "Consumed APIs"
    }, /* @__PURE__ */ React.createElement(WarningPanel, {
      severity: "error",
      title: "Could not load APIs",
      message: /* @__PURE__ */ React.createElement(CodeSnippet, {
        text: `${error}`,
        language: "text"
      })
    }));
  }
  return /* @__PURE__ */ React.createElement(EntityTable, {
    title: "Consumed APIs",
    variant,
    emptyContent: /* @__PURE__ */ React.createElement("div", {
      style: {textAlign: "center"}
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "body1"
    }, "This ", entity.kind.toLocaleLowerCase("en-US"), " does not consume any APIs."), /* @__PURE__ */ React.createElement(Typography, {
      variant: "body2"
    }, /* @__PURE__ */ React.createElement(Link, {
      to: "https://backstage.io/docs/features/software-catalog/descriptor-format#specconsumesapis-optional"
    }, "Learn how to change this."))),
    columns: apiEntityColumns,
    entities
  });
};

const columns = [
  EntityTable.columns.createEntityRefColumn({defaultKind: "API"}),
  EntityTable.columns.createOwnerColumn(),
  EntityTable.columns.createSpecLifecycleColumn(),
  createSpecApiTypeColumn(),
  EntityTable.columns.createMetadataDescriptionColumn()
];
const HasApisCard = ({variant = "gridItem"}) => {
  const {entity} = useEntity();
  const {entities, loading, error} = useRelatedEntities(entity, {
    type: RELATION_HAS_PART,
    kind: "API"
  });
  if (loading) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "APIs"
    }, /* @__PURE__ */ React.createElement(Progress, null));
  }
  if (error || !entities) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "APIs"
    }, /* @__PURE__ */ React.createElement(WarningPanel, {
      severity: "error",
      title: "Could not load APIs",
      message: /* @__PURE__ */ React.createElement(CodeSnippet, {
        text: `${error}`,
        language: "text"
      })
    }));
  }
  return /* @__PURE__ */ React.createElement(EntityTable, {
    title: "APIs",
    variant,
    emptyContent: /* @__PURE__ */ React.createElement("div", {
      style: {textAlign: "center"}
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "body1"
    }, "This ", entity.kind.toLocaleLowerCase("en-US"), " does not contain any APIs."), /* @__PURE__ */ React.createElement(Typography, {
      variant: "body2"
    }, /* @__PURE__ */ React.createElement(Link, {
      to: "https://backstage.io/docs/features/software-catalog/descriptor-format#kind-api"
    }, "Learn how to change this."))),
    columns,
    entities
  });
};

const ProvidedApisCard = ({variant = "gridItem"}) => {
  const {entity} = useEntity();
  const {entities, loading, error} = useRelatedEntities(entity, {
    type: RELATION_PROVIDES_API
  });
  if (loading) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "Provided APIs"
    }, /* @__PURE__ */ React.createElement(Progress, null));
  }
  if (error || !entities) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "Provided APIs"
    }, /* @__PURE__ */ React.createElement(WarningPanel, {
      severity: "error",
      title: "Could not load APIs",
      message: /* @__PURE__ */ React.createElement(CodeSnippet, {
        text: `${error}`,
        language: "text"
      })
    }));
  }
  return /* @__PURE__ */ React.createElement(EntityTable, {
    title: "Provided APIs",
    variant,
    emptyContent: /* @__PURE__ */ React.createElement("div", {
      style: {textAlign: "center"}
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "body1"
    }, "This ", entity.kind.toLocaleLowerCase("en-US"), " does not provide any APIs."), /* @__PURE__ */ React.createElement(Typography, {
      variant: "body2"
    }, /* @__PURE__ */ React.createElement(Link, {
      to: "https://backstage.io/docs/features/software-catalog/descriptor-format#specprovidesapis-optional"
    }, "Learn how to change this."))),
    columns: apiEntityColumns,
    entities
  });
};

const ConsumingComponentsCard = ({variant = "gridItem"}) => {
  const {entity} = useEntity();
  const {entities, loading, error} = useRelatedEntities(entity, {
    type: RELATION_API_CONSUMED_BY
  });
  if (loading) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "Consumers"
    }, /* @__PURE__ */ React.createElement(Progress, null));
  }
  if (error || !entities) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "Consumers"
    }, /* @__PURE__ */ React.createElement(WarningPanel, {
      severity: "error",
      title: "Could not load components",
      message: /* @__PURE__ */ React.createElement(CodeSnippet, {
        text: `${error}`,
        language: "text"
      })
    }));
  }
  return /* @__PURE__ */ React.createElement(EntityTable, {
    title: "Consumers",
    variant,
    emptyContent: /* @__PURE__ */ React.createElement("div", {
      style: {textAlign: "center"}
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "body1"
    }, "No component consumes this API."), /* @__PURE__ */ React.createElement(Typography, {
      variant: "body2"
    }, /* @__PURE__ */ React.createElement(Link, {
      to: "https://backstage.io/docs/features/software-catalog/descriptor-format#specconsumesapis-optional"
    }, "Learn how to change this."))),
    columns: EntityTable.componentEntityColumns,
    entities
  });
};

const ProvidingComponentsCard = ({variant = "gridItem"}) => {
  const {entity} = useEntity();
  const {entities, loading, error} = useRelatedEntities(entity, {
    type: RELATION_API_PROVIDED_BY
  });
  if (loading) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "Providers"
    }, /* @__PURE__ */ React.createElement(Progress, null));
  }
  if (error || !entities) {
    return /* @__PURE__ */ React.createElement(InfoCard, {
      variant,
      title: "Providers"
    }, /* @__PURE__ */ React.createElement(WarningPanel, {
      severity: "error",
      title: "Could not load components",
      message: /* @__PURE__ */ React.createElement(CodeSnippet, {
        text: `${error}`,
        language: "text"
      })
    }));
  }
  return /* @__PURE__ */ React.createElement(EntityTable, {
    title: "Providers",
    variant,
    emptyContent: /* @__PURE__ */ React.createElement("div", {
      style: {textAlign: "center"}
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "body1"
    }, "No component provides this API."), /* @__PURE__ */ React.createElement(Typography, {
      variant: "body2"
    }, /* @__PURE__ */ React.createElement(Link, {
      to: "https://backstage.io/docs/features/software-catalog/descriptor-format#specprovidesapis-optional"
    }, "Learn how to change this."))),
    columns: EntityTable.componentEntityColumns,
    entities
  });
};

const NoIcon = () => null;
const rootRoute = createRouteRef({
  icon: NoIcon,
  path: "/api-docs",
  title: "APIs"
});
const createComponentRouteRef = createExternalRouteRef({
  id: "create-component",
  optional: true
});

const columns$1 = [
  {
    title: "Name",
    field: "resolved.name",
    highlight: true,
    render: ({entity}) => /* @__PURE__ */ React.createElement(EntityRefLink, {
      entityRef: entity,
      defaultKind: "API"
    })
  },
  {
    title: "System",
    field: "resolved.partOfSystemRelationTitle",
    render: ({resolved}) => /* @__PURE__ */ React.createElement(EntityRefLinks, {
      entityRefs: resolved.partOfSystemRelations,
      defaultKind: "system"
    })
  },
  {
    title: "Owner",
    field: "resolved.ownedByRelationsTitle",
    render: ({resolved}) => /* @__PURE__ */ React.createElement(EntityRefLinks, {
      entityRefs: resolved.ownedByRelations,
      defaultKind: "group"
    })
  },
  {
    title: "Lifecycle",
    field: "entity.spec.lifecycle"
  },
  {
    title: "Type",
    field: "entity.spec.type",
    render: ({entity}) => /* @__PURE__ */ React.createElement(ApiTypeTitle, {
      apiEntity: entity
    })
  },
  {
    title: "Description",
    field: "entity.metadata.description",
    render: ({entity}) => /* @__PURE__ */ React.createElement(OverflowTooltip, {
      text: entity.metadata.description,
      placement: "bottom-start"
    }),
    width: "auto"
  },
  {
    title: "Tags",
    field: "entity.metadata.tags",
    cellStyle: {
      padding: "0px 16px 0px 20px"
    },
    render: ({entity}) => /* @__PURE__ */ React.createElement(React.Fragment, null, entity.metadata.tags && entity.metadata.tags.map((t) => /* @__PURE__ */ React.createElement(Chip, {
      key: t,
      label: t,
      size: "small",
      variant: "outlined",
      style: {marginBottom: "0px"}
    })))
  }
];
const filters = [
  {
    column: "Owner",
    type: "select"
  },
  {
    column: "Type",
    type: "multiple-select"
  },
  {
    column: "Lifecycle",
    type: "multiple-select"
  },
  {
    column: "Tags",
    type: "checkbox-tree"
  }
];
const ApiExplorerTable = ({
  entities,
  loading,
  error
}) => {
  const [queryParamState, setQueryParamState] = useQueryParamState("apiTable");
  if (error) {
    return /* @__PURE__ */ React.createElement(WarningPanel, {
      severity: "error",
      title: "Could not fetch catalog entities."
    }, /* @__PURE__ */ React.createElement(CodeSnippet, {
      language: "text",
      text: error.toString()
    }));
  }
  const rows = entities.map((entity) => {
    const partOfSystemRelations = getEntityRelations(entity, RELATION_PART_OF, {
      kind: "system"
    });
    const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
    return {
      entity,
      resolved: {
        name: formatEntityRefTitle(entity, {
          defaultKind: "API"
        }),
        ownedByRelationsTitle: ownedByRelations.map((r) => formatEntityRefTitle(r, {defaultKind: "group"})).join(", "),
        ownedByRelations,
        partOfSystemRelationTitle: partOfSystemRelations.map((r) => formatEntityRefTitle(r, {
          defaultKind: "system"
        })).join(", "),
        partOfSystemRelations
      }
    };
  });
  return /* @__PURE__ */ React.createElement(Table, {
    isLoading: loading,
    columns: columns$1,
    options: {
      paging: false,
      actionsColumnIndex: -1,
      loadingType: "linear",
      padding: "dense",
      showEmptyDataSourceMessage: !loading
    },
    data: rows,
    filters,
    initialState: queryParamState,
    onStateChange: setQueryParamState
  });
};

const ApiExplorerLayout = ({children}) => {
  var _a;
  const configApi = useApi(configApiRef);
  const generatedSubtitle = `${(_a = configApi.getOptionalString("organization.name")) != null ? _a : "Backstage"} API Explorer`;
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "apis"
  }, /* @__PURE__ */ React.createElement(Header, {
    title: "APIs",
    subtitle: generatedSubtitle,
    pageTitleOverride: "APIs"
  }), children);
};

const ApiExplorerPage = () => {
  var _a;
  const createComponentLink = useRouteRef(createComponentRouteRef);
  const catalogApi = useApi(catalogApiRef);
  const {loading, error, value: catalogResponse} = useAsync(() => {
    return catalogApi.getEntities({
      filter: {kind: "API"},
      fields: [
        "apiVersion",
        "kind",
        "metadata",
        "relations",
        "spec.lifecycle",
        "spec.owner",
        "spec.type",
        "spec.system"
      ]
    });
  }, [catalogApi]);
  return /* @__PURE__ */ React.createElement(ApiExplorerLayout, null, /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ContentHeader, {
    title: ""
  }, createComponentLink && /* @__PURE__ */ React.createElement(Button, {
    variant: "contained",
    color: "primary",
    component: Link$1,
    to: createComponentLink()
  }, "Register Existing API"), /* @__PURE__ */ React.createElement(SupportButton, null, "All your APIs")), /* @__PURE__ */ React.createElement(ApiExplorerTable, {
    entities: (_a = catalogResponse == null ? void 0 : catalogResponse.items) != null ? _a : [],
    loading,
    error
  })));
};

const apiDocsPlugin = createPlugin({
  id: "api-docs",
  routes: {
    root: rootRoute
  },
  apis: [
    createApiFactory({
      api: apiDocsConfigRef,
      deps: {},
      factory: () => {
        const definitionWidgets = defaultDefinitionWidgets();
        return {
          getApiDefinitionWidget: (apiEntity) => {
            return definitionWidgets.find((d) => d.type === apiEntity.spec.type);
          }
        };
      }
    })
  ],
  externalRoutes: {
    createComponent: createComponentRouteRef
  },
  register({router}) {
    router.addRoute(rootRoute, ApiExplorerPage);
  }
});
const ApiExplorerPage$1 = apiDocsPlugin.provide(createRoutableExtension({
  component: () => import('./index-947d5b4c.esm.js').then((m) => m.ApiExplorerPage),
  mountPoint: rootRoute
}));
const EntityApiDefinitionCard = apiDocsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-44b03952.esm.js').then((m) => m.ApiDefinitionCard)
  }
}));
const EntityConsumedApisCard = apiDocsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-7c2f5135.esm.js').then((m) => m.ConsumedApisCard)
  }
}));
const EntityConsumingComponentsCard = apiDocsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-257abbe3.esm.js').then((m) => m.ConsumingComponentsCard)
  }
}));
const EntityProvidedApisCard = apiDocsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-7c2f5135.esm.js').then((m) => m.ProvidedApisCard)
  }
}));
const EntityProvidingComponentsCard = apiDocsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-257abbe3.esm.js').then((m) => m.ProvidingComponentsCard)
  }
}));
const EntityHasApisCard = apiDocsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => import('./index-7c2f5135.esm.js').then((m) => m.HasApisCard)
  }
}));

export { ApiExplorerPage as A, ConsumedApisCard as C, EntityApiDefinitionCard as E, HasApisCard as H, OpenApiDefinitionWidget as O, ProvidedApisCard as P, ApiDefinitionCard as a, ApiTypeTitle as b, ConsumingComponentsCard as c, defaultDefinitionWidgets as d, ProvidingComponentsCard as e, apiDocsConfigRef as f, apiDocsPlugin as g, ApiExplorerPage$1 as h, EntityConsumedApisCard as i, EntityConsumingComponentsCard as j, EntityHasApisCard as k, EntityProvidedApisCard as l, EntityProvidingComponentsCard as m, AsyncApiDefinitionWidget as n, PlainApiDefinitionWidget as o };
//# sourceMappingURL=index-70fbe4d9.esm.js.map
