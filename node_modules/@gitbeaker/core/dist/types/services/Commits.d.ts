import { BaseService } from '@gitbeaker/requester-utils';
import { BaseRequestOptions, PaginatedRequestOptions, Sudo } from '../infrastructure';
export interface CommitSchemaDefault {
    id: string;
    short_id: string;
    created_at: Date;
    parent_ids?: string[];
    title: string;
    message: string;
    author_name: string;
    author_email: string;
    authored_date?: Date;
    committer_name?: string;
    committer_email?: string;
    committed_date?: Date;
}
export interface CommitSchemaCamelized {
    id: string;
    shortId: string;
    createdAt: Date;
    parentIds?: string[];
    title: string;
    message: string;
    authorName: string;
    authorEmail: string;
    authoredDate?: Date;
    committerName?: string;
    committerEmail?: string;
    committedDate?: Date;
}
export declare type CommitSchema = CommitSchemaDefault | CommitSchemaCamelized;
export interface CommitAction {
    /** The action to perform */
    action: 'create' | 'delete' | 'move' | 'update';
    /** Full path to the file. Ex. lib/class.rb */
    filePath: string;
    /** Original full path to the file being moved.Ex.lib / class1.rb */
    previousPath?: string;
    /** File content, required for all except delete. Optional for move */
    content?: string;
    /** text or base64. text is default. */
    encoding?: string;
    /** Last known file commit id. Will be only considered in update, move and delete actions. */
    lastCommitId?: string;
}
export interface GPGSignature {
    signature_type: 'PGP';
    verification_status: 'verified' | 'unverified';
    gpg_key_id: number;
    gpg_key_primary_keyid: string;
    gpg_key_user_name: string;
    gpg_key_user_email: string;
    gpg_key_subkey_id: number | null;
    commit_source: string;
}
export interface X509Signature {
    signature_type: 'X509';
    verification_status: 'verified' | 'unverified';
    x509_certificate: {
        id: number;
        subject: string;
        subject_key_identifier: string;
        email: string;
        serial_number: string;
        certificate_status: string;
        x509_issuer: {
            id: number;
            subject: string;
            subject_key_identifier: string;
            crl_url: string;
        };
    };
    commit_source: string;
}
export interface MissingSignature {
    message: string;
}
export declare type CommitSignature = GPGSignature | X509Signature | MissingSignature;
export declare class Commits extends BaseService {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<Record<string, unknown> | Record<string, unknown>[]>;
    cherryPick(projectId: string | number, sha: string, branch: string, options?: Sudo): Promise<Record<string, unknown>>;
    comments(projectId: string | number, sha: string, options?: Sudo): Promise<Record<string, unknown> | Record<string, unknown>[]>;
    create(projectId: string | number, branch: string, message: string, actions?: CommitAction[], options?: BaseRequestOptions): Promise<Record<string, unknown>>;
    createComment(projectId: string | number, sha: string, note: string, options?: BaseRequestOptions): Promise<Record<string, unknown>>;
    diff(projectId: string | number, sha: string, options?: Sudo): Promise<Record<string, unknown> | Record<string, unknown>[]>;
    editStatus(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<Record<string, unknown>>;
    references(projectId: string | number, sha: string, options?: Sudo): Promise<Record<string, unknown> | Record<string, unknown>[]>;
    revert(projectId: string | number, sha: string, options?: Sudo): Promise<Record<string, unknown>>;
    show(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<Record<string, unknown> | Record<string, unknown>[]>;
    status(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<Record<string, unknown> | Record<string, unknown>[]>;
    mergeRequests(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<Record<string, unknown> | Record<string, unknown>[]>;
    signature(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<CommitSignature>;
}
