import { createApiRef, createRouteRef, createPlugin, createApiFactory, discoveryApiRef, githubAuthApiRef, identityApiRef, createRoutableExtension, Link, useApi, errorApiRef, CodeSnippet, MarkdownContent, configApiRef, InfoCard, Page, Header, Content, ContentHeader, SupportButton } from '@backstage/core';
import { scmIntegrationsApiRef } from '@backstage/integration-react';
import { catalogApiRef, formatEntityRefTitle, EntityRefLink } from '@backstage/plugin-catalog-react';
import { Base64 } from 'js-base64';
import { Octokit } from '@octokit/rest';
import parseGitUrl from 'git-url-parse';
import React, { useReducer, useState, useCallback, useMemo } from 'react';
import { Routes, Route } from 'react-router-dom';
import { Button, CircularProgress, List, ListItem, ListItemIcon, ListItemText, ListItemSecondaryAction, IconButton, Collapse, Typography, Grid, TextField, FormHelperText, Card, CardHeader, CardContent, Box, Checkbox, StepLabel, FormControlLabel, Stepper, Step, StepContent } from '@material-ui/core';
import { makeStyles } from '@material-ui/core/styles';
import LocationOnIcon from '@material-ui/icons/LocationOn';
import ApartmentIcon from '@material-ui/icons/Apartment';
import CategoryIcon from '@material-ui/icons/Category';
import ExpandLessIcon from '@material-ui/icons/ExpandLess';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import ExtensionIcon from '@material-ui/icons/Extension';
import GroupIcon from '@material-ui/icons/Group';
import MemoryIcon from '@material-ui/icons/Memory';
import PersonIcon from '@material-ui/icons/Person';
import WorkIcon from '@material-ui/icons/Work';
import { useForm, Controller } from 'react-hook-form';
import { Autocomplete } from '@material-ui/lab';
import YAML from 'yaml';
import { useAsync } from 'react-use';

const catalogImportApiRef = createApiRef({
  id: "plugin.catalog-import.service",
  description: "Used by the catalog import plugin to make requests"
});

const getGithubIntegrationConfig = (scmIntegrationsApi, location) => {
  const integration = scmIntegrationsApi.github.byUrl(location);
  if (!integration) {
    return void 0;
  }
  const {name: repo, owner} = parseGitUrl(location);
  return {
    repo,
    owner,
    githubIntegrationConfig: integration.config
  };
};

class CatalogImportClient {
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.githubAuthApi = options.githubAuthApi;
    this.identityApi = options.identityApi;
    this.scmIntegrationsApi = options.scmIntegrationsApi;
    this.catalogApi = options.catalogApi;
  }
  async analyzeUrl(url) {
    if (url.match(/\.ya?ml$/)) {
      const location = await this.catalogApi.addLocation({
        type: "url",
        target: url,
        dryRun: true
      });
      return {
        type: "locations",
        locations: [
          {
            target: location.location.target,
            entities: location.entities.map((e) => {
              var _a;
              return {
                kind: e.kind,
                namespace: (_a = e.metadata.namespace) != null ? _a : "default",
                name: e.metadata.name
              };
            })
          }
        ]
      };
    }
    const ghConfig = getGithubIntegrationConfig(this.scmIntegrationsApi, url);
    if (!ghConfig) {
      throw new Error("This URL was not recognized as a valid GitHub URL because there was no configured integration that matched the given host name. You could try to paste the full URL to a catalog-info.yaml file instead.");
    }
    const locations = await this.checkGitHubForExistingCatalogInfo({
      ...ghConfig,
      url
    });
    if (locations.length > 0) {
      return {
        type: "locations",
        locations
      };
    }
    return {
      type: "repository",
      integrationType: "github",
      url,
      generatedEntities: await this.generateEntityDefinitions({
        repo: url
      })
    };
  }
  async submitPullRequest({
    repositoryUrl,
    fileContent,
    title,
    body
  }) {
    const ghConfig = getGithubIntegrationConfig(this.scmIntegrationsApi, repositoryUrl);
    if (ghConfig) {
      return await this.submitGitHubPrToRepo({
        ...ghConfig,
        fileContent,
        title,
        body
      });
    }
    throw new Error("unimplemented!");
  }
  async generateEntityDefinitions({
    repo
  }) {
    const idToken = await this.identityApi.getIdToken();
    const response = await fetch(`${await this.discoveryApi.getBaseUrl("catalog")}/analyze-location`, {
      headers: {
        "Content-Type": "application/json",
        ...idToken && {Authorization: `Bearer ${idToken}`}
      },
      method: "POST",
      body: JSON.stringify({
        location: {type: "url", target: repo}
      })
    }).catch((e) => {
      throw new Error(`Failed to generate entity definitions, ${e.message}`);
    });
    if (!response.ok) {
      throw new Error(`Failed to generate entity definitions. Received http response ${response.status}: ${response.statusText}`);
    }
    const payload = await response.json();
    return payload.generateEntities.map((x) => x.entity);
  }
  async checkGitHubForExistingCatalogInfo({
    url,
    owner,
    repo,
    githubIntegrationConfig
  }) {
    const token = await this.githubAuthApi.getAccessToken(["repo"]);
    const octo = new Octokit({
      auth: token,
      baseUrl: githubIntegrationConfig.apiBaseUrl
    });
    const catalogFileName = "catalog-info.yaml";
    const query = `repo:${owner}/${repo}+filename:${catalogFileName}`;
    const searchResult = await octo.search.code({q: query}).catch((e) => {
      throw new Error(formatHttpErrorMessage("Couldn't search repository for metadata file.", e));
    });
    const exists = searchResult.data.total_count > 0;
    if (exists) {
      const repoInformation = await octo.repos.get({owner, repo}).catch((e) => {
        throw new Error(formatHttpErrorMessage("Couldn't fetch repo data", e));
      });
      const defaultBranch = repoInformation.data.default_branch;
      return await Promise.all(searchResult.data.items.map((i) => `${url.replace(/[\/]*$/, "")}/blob/${defaultBranch}/${i.path}`).map(async (i) => ({
        target: i,
        entities: (await this.catalogApi.addLocation({
          type: "url",
          target: i,
          dryRun: true
        })).entities.map((e) => {
          var _a;
          return {
            kind: e.kind,
            namespace: (_a = e.metadata.namespace) != null ? _a : "default",
            name: e.metadata.name
          };
        })
      })));
    }
    return [];
  }
  async submitGitHubPrToRepo({
    owner,
    repo,
    title,
    body,
    fileContent,
    githubIntegrationConfig
  }) {
    const token = await this.githubAuthApi.getAccessToken(["repo"]);
    const octo = new Octokit({
      auth: token,
      baseUrl: githubIntegrationConfig.apiBaseUrl
    });
    const branchName = "backstage-integration";
    const fileName = "catalog-info.yaml";
    const repoData = await octo.repos.get({
      owner,
      repo
    }).catch((e) => {
      throw new Error(formatHttpErrorMessage("Couldn't fetch repo data", e));
    });
    const parentRef = await octo.git.getRef({
      owner,
      repo,
      ref: `heads/${repoData.data.default_branch}`
    }).catch((e) => {
      throw new Error(formatHttpErrorMessage("Couldn't fetch default branch data", e));
    });
    await octo.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branchName}`,
      sha: parentRef.data.object.sha
    }).catch((e) => {
      throw new Error(formatHttpErrorMessage(`Couldn't create a new branch with name '${branchName}'`, e));
    });
    await octo.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: fileName,
      message: title,
      content: Base64.encode(fileContent),
      branch: branchName
    }).catch((e) => {
      throw new Error(formatHttpErrorMessage(`Couldn't create a commit with ${fileName} file added`, e));
    });
    const pullRequestResponse = await octo.pulls.create({
      owner,
      repo,
      title,
      head: branchName,
      body,
      base: repoData.data.default_branch
    }).catch((e) => {
      throw new Error(formatHttpErrorMessage(`Couldn't create a pull request for ${branchName} branch`, e));
    });
    return {
      link: pullRequestResponse.data.html_url,
      location: `https://${githubIntegrationConfig.host}/${owner}/${repo}/blob/${repoData.data.default_branch}/${fileName}`
    };
  }
}
function formatHttpErrorMessage(message, error) {
  return `${message}, received http response status code ${error.status}: ${error.message}`;
}

const rootRouteRef = createRouteRef({
  path: "",
  title: "catalog-import"
});
const catalogImportPlugin = createPlugin({
  id: "catalog-import",
  apis: [
    createApiFactory({
      api: catalogImportApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        githubAuthApi: githubAuthApiRef,
        identityApi: identityApiRef,
        scmIntegrationsApi: scmIntegrationsApiRef,
        catalogApi: catalogApiRef
      },
      factory: ({
        discoveryApi,
        githubAuthApi,
        identityApi,
        scmIntegrationsApi,
        catalogApi
      }) => new CatalogImportClient({
        discoveryApi,
        githubAuthApi,
        scmIntegrationsApi,
        identityApi,
        catalogApi
      })
    })
  ],
  routes: {
    importPage: rootRouteRef
  }
});
const CatalogImportPage = catalogImportPlugin.provide(createRoutableExtension({
  component: () => Promise.resolve().then(function () { return Router$1; }).then((m) => m.Router),
  mountPoint: rootRouteRef
}));

function init(initialUrl) {
  return {
    activeFlow: "unknown",
    activeState: "analyze",
    analysisUrl: initialUrl,
    previousStates: []
  };
}
function reducer(state, action) {
  switch (action.type) {
    case "onAnalysis": {
      if (state.activeState !== "analyze") {
        return state;
      }
      const {activeState, previousStates} = state;
      const [activeFlow, analysisUrl, analyzeResult, opts] = action.args;
      return {
        ...state,
        analysisUrl,
        activeFlow,
        analyzeResult,
        prepareResult: opts == null ? void 0 : opts.prepareResult,
        activeState: (opts == null ? void 0 : opts.prepareResult) === void 0 ? "prepare" : "review",
        previousStates: previousStates.concat(activeState)
      };
    }
    case "onPrepare": {
      if (state.activeState !== "prepare") {
        return state;
      }
      const {activeState, previousStates} = state;
      const [prepareResult, opts] = action.args;
      return {
        ...state,
        prepareResult,
        activeState: "review",
        previousStates: (opts == null ? void 0 : opts.notRepeatable) ? [] : previousStates.concat(activeState)
      };
    }
    case "onReview": {
      if (state.activeState !== "review") {
        return state;
      }
      const {activeState, previousStates} = state;
      const [reviewResult] = action.args;
      return {
        ...state,
        reviewResult,
        activeState: "finish",
        previousStates: previousStates.concat(activeState)
      };
    }
    case "onGoBack": {
      const {activeState, previousStates} = state;
      return {
        ...state,
        activeState: previousStates.length > 0 ? previousStates[previousStates.length - 1] : activeState,
        previousStates: previousStates.slice(0, previousStates.length - 1)
      };
    }
    case "onReset":
      return {
        ...init(action.initialUrl),
        reviewResult: state.reviewResult
      };
    default:
      throw new Error();
  }
}
const useImportState = (options) => {
  const [state, dispatch] = useReducer(reducer, options == null ? void 0 : options.initialUrl, init);
  const {activeFlow, activeState, analysisUrl, previousStates} = state;
  return {
    activeFlow,
    activeState,
    activeStepNumber: ["analyze", "prepare", "review", "finish"].indexOf(activeState),
    analysisUrl,
    analyzeResult: state.analyzeResult,
    prepareResult: state.prepareResult,
    reviewResult: state.reviewResult,
    onAnalysis: (flow, url, result, opts) => dispatch({
      type: "onAnalysis",
      args: [flow, url, result, opts]
    }),
    onPrepare: (result, opts) => dispatch({
      type: "onPrepare",
      args: [result, opts]
    }),
    onReview: (result) => dispatch({type: "onReview", args: [result]}),
    onGoBack: previousStates.length > 0 ? () => dispatch({type: "onGoBack"}) : void 0,
    onReset: () => dispatch({type: "onReset", initialUrl: options == null ? void 0 : options.initialUrl})
  };
};

const useStyles = makeStyles((theme) => ({
  wrapper: {
    marginTop: theme.spacing(1),
    marginRight: theme.spacing(1),
    position: "relative"
  },
  buttonProgress: {
    position: "absolute",
    top: "50%",
    left: "50%",
    marginTop: -12,
    marginLeft: -12
  },
  button: {
    marginTop: theme.spacing(1),
    marginRight: theme.spacing(1)
  }
}));
const NextButton = (props) => {
  const {loading, ...buttonProps} = props;
  const classes = useStyles();
  return /* @__PURE__ */ React.createElement("div", {
    className: classes.wrapper
  }, /* @__PURE__ */ React.createElement(Button, {
    color: "primary",
    variant: "contained",
    ...buttonProps,
    disabled: props.disabled || props.loading
  }), props.loading && /* @__PURE__ */ React.createElement(CircularProgress, {
    size: "1.5rem",
    className: classes.buttonProgress
  }), props.loading);
};
const BackButton = (props) => {
  const classes = useStyles();
  return /* @__PURE__ */ React.createElement(Button, {
    variant: "outlined",
    className: classes.button,
    ...props
  }, props.children || "Back");
};

const useStyles$1 = makeStyles((theme) => ({
  nested: {
    paddingLeft: theme.spacing(4)
  }
}));
function sortEntities(entities) {
  return entities.sort((a, b) => formatEntityRefTitle(a).localeCompare(formatEntityRefTitle(b)));
}
function getEntityIcon(entity) {
  switch (entity.kind.toLocaleLowerCase("en-US")) {
    case "api":
      return /* @__PURE__ */ React.createElement(ExtensionIcon, null);
    case "component":
      return /* @__PURE__ */ React.createElement(MemoryIcon, null);
    case "domain":
      return /* @__PURE__ */ React.createElement(ApartmentIcon, null);
    case "group":
      return /* @__PURE__ */ React.createElement(GroupIcon, null);
    case "location":
      return /* @__PURE__ */ React.createElement(LocationOnIcon, null);
    case "system":
      return /* @__PURE__ */ React.createElement(CategoryIcon, null);
    case "user":
      return /* @__PURE__ */ React.createElement(PersonIcon, null);
    default:
      return /* @__PURE__ */ React.createElement(WorkIcon, null);
  }
}
const EntityListComponent = ({
  locations,
  collapsed = false,
  locationListItemIcon,
  onItemClick,
  firstListItem,
  withLinks = false
}) => {
  const classes = useStyles$1();
  const [expandedUrls, setExpandedUrls] = useState([]);
  const handleClick = (url) => {
    setExpandedUrls((urls) => urls.includes(url) ? urls.filter((u) => u !== url) : urls.concat(url));
  };
  return /* @__PURE__ */ React.createElement(List, null, firstListItem, locations.map((r) => /* @__PURE__ */ React.createElement(React.Fragment, {
    key: r.target
  }, /* @__PURE__ */ React.createElement(ListItem, {
    dense: true,
    button: Boolean(onItemClick),
    onClick: () => onItemClick == null ? void 0 : onItemClick.call(undefined, r.target)
  }, /* @__PURE__ */ React.createElement(ListItemIcon, null, locationListItemIcon(r.target)), /* @__PURE__ */ React.createElement(ListItemText, {
    primary: r.target,
    secondary: `Entities: ${r.entities.length}`
  }), collapsed && /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, /* @__PURE__ */ React.createElement(IconButton, {
    edge: "end",
    onClick: () => handleClick(r.target)
  }, expandedUrls.includes(r.target) ? /* @__PURE__ */ React.createElement(ExpandLessIcon, null) : /* @__PURE__ */ React.createElement(ExpandMoreIcon, null)))), /* @__PURE__ */ React.createElement(Collapse, {
    in: !collapsed || expandedUrls.includes(r.target),
    timeout: "auto",
    unmountOnExit: true
  }, /* @__PURE__ */ React.createElement(List, {
    component: "div",
    disablePadding: true,
    dense: true
  }, sortEntities(r.entities).map((entity) => /* @__PURE__ */ React.createElement(ListItem, {
    component: withLinks ? EntityRefLink : "div",
    entityRef: withLinks ? entity : void 0,
    button: withLinks,
    key: formatEntityRefTitle(entity),
    className: classes.nested
  }, /* @__PURE__ */ React.createElement(ListItemIcon, null, getEntityIcon(entity)), /* @__PURE__ */ React.createElement(ListItemText, {
    primary: formatEntityRefTitle(entity)
  }))))))));
};

const StepFinishImportLocation = ({reviewResult, onReset}) => /* @__PURE__ */ React.createElement(React.Fragment, null, reviewResult.type === "repository" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, {
  paragraph: true
}, "The following Pull Request has been opened:", " ", /* @__PURE__ */ React.createElement(Link, {
  to: reviewResult.pullRequest.url,
  target: "_blank",
  rel: "noreferrer"
}, reviewResult.pullRequest.url)), /* @__PURE__ */ React.createElement(Typography, {
  paragraph: true
}, "Your entities will be imported as soon as the Pull Request is merged.")), /* @__PURE__ */ React.createElement(Typography, null, "The following entities have been added to the catalog:"), /* @__PURE__ */ React.createElement(EntityListComponent, {
  locations: reviewResult.locations,
  locationListItemIcon: () => /* @__PURE__ */ React.createElement(LocationOnIcon, null),
  withLinks: true
}), /* @__PURE__ */ React.createElement(Grid, {
  container: true,
  spacing: 0
}, /* @__PURE__ */ React.createElement(BackButton, {
  onClick: onReset
}, "Register another")));

const StepInitAnalyzeUrl = ({
  onAnalysis,
  analysisUrl = "",
  disablePullRequest = false
}) => {
  const errorApi = useApi(errorApiRef);
  const catalogImportApi = useApi(catalogImportApiRef);
  const {register, handleSubmit, errors, watch} = useForm({
    mode: "onTouched",
    defaultValues: {
      url: analysisUrl
    }
  });
  const [submitted, setSubmitted] = useState(false);
  const [error, setError] = useState(void 0);
  const handleResult = useCallback(async ({url}) => {
    var _a, _b, _c;
    setSubmitted(true);
    try {
      const analysisResult = await catalogImportApi.analyzeUrl(url);
      switch (analysisResult.type) {
        case "repository":
          if (!disablePullRequest && analysisResult.generatedEntities.length > 0) {
            onAnalysis("no-location", url, analysisResult);
          } else {
            setError("Couldn't generate entities for your repository");
            setSubmitted(false);
          }
          break;
        case "locations": {
          if (analysisResult.locations.length === 1) {
            onAnalysis("single-location", url, analysisResult, {
              prepareResult: analysisResult
            });
          } else if (analysisResult.locations.length > 1) {
            onAnalysis("multiple-locations", url, analysisResult);
          } else {
            setError("There are no entities at this location");
            setSubmitted(false);
          }
          break;
        }
        default: {
          const err = `Received unknown analysis result of type ${analysisResult.type}. Please contact the support team.`;
          setError(err);
          setSubmitted(false);
          errorApi.post(new Error(err));
          break;
        }
      }
    } catch (e) {
      setError((_c = (_b = (_a = e.data) == null ? void 0 : _a.error) == null ? void 0 : _b.message) != null ? _c : e.message);
      setSubmitted(false);
    }
  }, [catalogImportApi, disablePullRequest, errorApi, onAnalysis]);
  return /* @__PURE__ */ React.createElement("form", {
    onSubmit: handleSubmit(handleResult)
  }, /* @__PURE__ */ React.createElement(TextField, {
    fullWidth: true,
    id: "url",
    name: "url",
    label: "Repository URL",
    placeholder: "https://github.com/backstage/backstage/blob/master/catalog-info.yaml",
    helperText: "Enter the full path to your entity file to start tracking your component",
    margin: "normal",
    variant: "outlined",
    error: Boolean(errors.url),
    inputRef: register({
      required: true,
      validate: {
        httpsValidator: (value) => typeof value === "string" && value.match(/^http[s]?:\/\//) !== null || "Must start with http:// or https://."
      }
    }),
    required: true
  }), errors.url && /* @__PURE__ */ React.createElement(FormHelperText, {
    error: true
  }, errors.url.message), error && /* @__PURE__ */ React.createElement(FormHelperText, {
    error: true
  }, error), /* @__PURE__ */ React.createElement(Grid, {
    container: true,
    spacing: 0
  }, /* @__PURE__ */ React.createElement(NextButton, {
    disabled: Boolean(errors.url) || !watch("url"),
    loading: submitted,
    type: "submit"
  }, "Analyze")));
};

const AutocompleteTextField = ({
  name,
  options,
  required,
  control,
  errors,
  rules,
  loading = false,
  loadingText,
  helperText,
  errorHelperText,
  textFieldProps = {}
}) => {
  return /* @__PURE__ */ React.createElement(Controller, {
    name,
    control,
    rules,
    render: ({value, onChange, onBlur}) => /* @__PURE__ */ React.createElement(Autocomplete, {
      loading,
      loadingText,
      options: options || [],
      onChange: (_, v) => onChange(v || ""),
      onBlur,
      value,
      autoSelect: true,
      freeSolo: true,
      renderInput: (params) => /* @__PURE__ */ React.createElement(TextField, {
        ...params,
        helperText: (errors == null ? void 0 : errors[name]) && errorHelperText || helperText,
        error: Boolean(errors == null ? void 0 : errors[name]),
        margin: "normal",
        variant: "outlined",
        required,
        InputProps: {
          ...params.InputProps,
          endAdornment: /* @__PURE__ */ React.createElement(React.Fragment, null, loading ? /* @__PURE__ */ React.createElement(CircularProgress, {
            color: "inherit",
            size: "1em"
          }) : null, params.InputProps.endAdornment)
        },
        ...textFieldProps
      })
    })
  });
};

const PreparePullRequestForm = ({
  defaultValues,
  onSubmit,
  render
}) => {
  const {
    handleSubmit,
    watch,
    control,
    register,
    errors
  } = useForm({mode: "onTouched", defaultValues});
  return /* @__PURE__ */ React.createElement("form", {
    onSubmit: handleSubmit(onSubmit)
  }, render({values: watch(), errors, register, control}));
};

const PreviewCatalogInfoComponent = ({
  repositoryUrl,
  entities,
  classes
}) => {
  return /* @__PURE__ */ React.createElement(Card, {
    variant: "outlined",
    className: classes == null ? void 0 : classes.card
  }, /* @__PURE__ */ React.createElement(CardHeader, {
    title: /* @__PURE__ */ React.createElement("code", null, `${repositoryUrl.replace(/[\/]*$/, "")}/catalog-info.yaml`)
  }), /* @__PURE__ */ React.createElement(CardContent, {
    className: classes == null ? void 0 : classes.cardContent
  }, /* @__PURE__ */ React.createElement(CodeSnippet, {
    text: entities.map((e) => YAML.stringify(e)).join("---\n").trim(),
    language: "yaml"
  })));
};

const PreviewPullRequestComponent = ({
  title,
  description,
  classes
}) => {
  return /* @__PURE__ */ React.createElement(Card, {
    variant: "outlined",
    className: classes == null ? void 0 : classes.card
  }, /* @__PURE__ */ React.createElement(CardHeader, {
    title,
    subheader: "Create a new Pull Request"
  }), /* @__PURE__ */ React.createElement(CardContent, {
    className: classes == null ? void 0 : classes.cardContent
  }, /* @__PURE__ */ React.createElement(MarkdownContent, {
    content: description
  })));
};

const useStyles$2 = makeStyles((theme) => ({
  previewCard: {
    marginTop: theme.spacing(1)
  },
  previewCardContent: {
    paddingTop: 0
  }
}));
function generateEntities(entities, componentName, owner) {
  return entities.map((e) => ({
    ...e,
    apiVersion: e.apiVersion,
    kind: e.kind,
    metadata: {
      ...e.metadata,
      name: componentName
    },
    spec: {
      ...e.spec,
      ...owner ? {owner} : {}
    }
  }));
}
const StepPrepareCreatePullRequest = ({
  analyzeResult,
  onPrepare,
  onGoBack,
  renderFormFields,
  defaultTitle,
  defaultBody
}) => {
  var _a, _b, _c, _d;
  const classes = useStyles$2();
  const catalogApi = useApi(catalogApiRef);
  const catalogInfoApi = useApi(catalogImportApiRef);
  const [submitted, setSubmitted] = useState(false);
  const [error, setError] = useState();
  const {loading: groupsLoading, value: groups} = useAsync(async () => {
    const groupEntities = await catalogApi.getEntities({
      filter: {kind: "group"}
    });
    return groupEntities.items.map((e) => formatEntityRefTitle(e, {defaultKind: "group"})).sort();
  });
  const handleResult = useCallback(async (data) => {
    setSubmitted(true);
    try {
      const pr = await catalogInfoApi.submitPullRequest({
        repositoryUrl: analyzeResult.url,
        title: data.title,
        body: data.body,
        fileContent: generateEntities(analyzeResult.generatedEntities, data.componentName, data.owner).map((e) => YAML.stringify(e)).join("---\n")
      });
      onPrepare({
        type: "repository",
        url: analyzeResult.url,
        integrationType: analyzeResult.integrationType,
        pullRequest: {
          url: pr.link
        },
        locations: [
          {
            target: pr.location,
            entities: generateEntities(analyzeResult.generatedEntities, data.componentName, data.owner).map((e) => ({
              kind: e.kind,
              namespace: e.metadata.namespace,
              name: e.metadata.name
            }))
          }
        ]
      }, {notRepeatable: true});
    } catch (e) {
      setError(e.message);
      setSubmitted(false);
    }
  }, [
    analyzeResult.generatedEntities,
    analyzeResult.integrationType,
    analyzeResult.url,
    catalogInfoApi,
    onPrepare
  ]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, null, "You entered a link to a ", analyzeResult.integrationType, " repository but a", " ", /* @__PURE__ */ React.createElement("code", null, "catalog-info.yaml"), " could not be found. Use this form to open a Pull Request that creates one."), /* @__PURE__ */ React.createElement(PreparePullRequestForm, {
    onSubmit: handleResult,
    defaultValues: {
      title: defaultTitle,
      body: defaultBody,
      owner: ((_b = (_a = analyzeResult.generatedEntities[0]) == null ? void 0 : _a.spec) == null ? void 0 : _b.owner) || "",
      componentName: ((_d = (_c = analyzeResult.generatedEntities[0]) == null ? void 0 : _c.metadata) == null ? void 0 : _d.name) || "",
      useCodeowners: false
    },
    render: ({values, errors, control, register}) => /* @__PURE__ */ React.createElement(React.Fragment, null, renderFormFields({
      values,
      errors,
      register,
      control,
      groups: groups != null ? groups : [],
      groupsLoading
    }), /* @__PURE__ */ React.createElement(Box, {
      marginTop: 2
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "h6"
    }, "Preview Pull Request")), /* @__PURE__ */ React.createElement(PreviewPullRequestComponent, {
      title: values.title,
      description: values.body,
      classes: {
        card: classes.previewCard,
        cardContent: classes.previewCardContent
      }
    }), /* @__PURE__ */ React.createElement(Box, {
      marginTop: 2,
      marginBottom: 1
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "h6"
    }, "Preview Entities")), /* @__PURE__ */ React.createElement(PreviewCatalogInfoComponent, {
      entities: generateEntities(analyzeResult.generatedEntities, values.componentName, values.owner),
      repositoryUrl: analyzeResult.url,
      classes: {
        card: classes.previewCard,
        cardContent: classes.previewCardContent
      }
    }), error && /* @__PURE__ */ React.createElement(FormHelperText, {
      error: true
    }, error), /* @__PURE__ */ React.createElement(Grid, {
      container: true,
      spacing: 0
    }, onGoBack && /* @__PURE__ */ React.createElement(BackButton, {
      onClick: onGoBack,
      disabled: submitted
    }), /* @__PURE__ */ React.createElement(NextButton, {
      type: "submit",
      disabled: Boolean(errors.title || errors.body || errors.owner),
      loading: submitted
    }, "Create PR")))
  }));
};

const StepPrepareSelectLocations = ({
  analyzeResult,
  prepareResult,
  onPrepare,
  onGoBack
}) => {
  const [selectedUrls, setSelectedUrls] = useState((prepareResult == null ? void 0 : prepareResult.locations.map((l) => l.target)) || []);
  const handleResult = useCallback(async () => {
    onPrepare({
      type: "locations",
      locations: analyzeResult.locations.filter((l) => selectedUrls.includes(l.target))
    });
  }, [analyzeResult.locations, onPrepare, selectedUrls]);
  const onItemClick = (url) => {
    setSelectedUrls((urls) => urls.includes(url) ? urls.filter((u) => u !== url) : urls.concat(url));
  };
  const onSelectAll = () => {
    setSelectedUrls((urls) => urls.length < analyzeResult.locations.length ? analyzeResult.locations.map((l) => l.target) : []);
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, null, "Select one or more locations that are present in your git repository:"), /* @__PURE__ */ React.createElement(EntityListComponent, {
    firstListItem: /* @__PURE__ */ React.createElement(ListItem, {
      dense: true,
      button: true,
      onClick: onSelectAll
    }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Checkbox, {
      edge: "start",
      checked: selectedUrls.length === analyzeResult.locations.length,
      indeterminate: selectedUrls.length > 0 && selectedUrls.length < analyzeResult.locations.length,
      tabIndex: -1,
      disableRipple: true
    })), /* @__PURE__ */ React.createElement(ListItemText, {
      primary: "Select All"
    })),
    onItemClick,
    locations: analyzeResult.locations,
    locationListItemIcon: (target) => /* @__PURE__ */ React.createElement(Checkbox, {
      edge: "start",
      checked: selectedUrls.includes(target),
      tabIndex: -1,
      disableRipple: true
    }),
    collapsed: true
  }), /* @__PURE__ */ React.createElement(Grid, {
    container: true,
    spacing: 0
  }, onGoBack && /* @__PURE__ */ React.createElement(BackButton, {
    onClick: onGoBack
  }), /* @__PURE__ */ React.createElement(NextButton, {
    disabled: selectedUrls.length === 0,
    onClick: handleResult
  }, "Review")));
};

const StepReviewLocation = ({
  prepareResult,
  onReview,
  onGoBack
}) => {
  const catalogApi = useApi(catalogApiRef);
  const configApi = useApi(configApiRef);
  const appTitle = configApi.getOptional("app.title") || "Backstage";
  const [submitted, setSubmitted] = useState(false);
  const [error, setError] = useState();
  const handleImport = useCallback(async () => {
    setSubmitted(true);
    try {
      const result = await Promise.all(prepareResult.locations.map((l) => catalogApi.addLocation({
        type: "url",
        target: l.target,
        presence: prepareResult.type === "repository" ? "optional" : "required"
      })));
      onReview({
        ...prepareResult,
        locations: result.map((r) => ({
          target: r.location.target,
          entities: r.entities
        }))
      });
    } catch (e) {
      if (prepareResult.type === "repository" && e.message.startsWith("Location was added but has no entities specified yet")) {
        onReview({
          ...prepareResult,
          locations: prepareResult.locations.map((l) => ({
            target: l.target,
            entities: []
          }))
        });
      } else {
        setError(e.message);
        setSubmitted(false);
      }
    }
  }, [prepareResult, onReview, catalogApi]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, prepareResult.type === "repository" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "The following Pull Request has been opened:", " ", /* @__PURE__ */ React.createElement(Link, {
    to: prepareResult.pullRequest.url,
    target: "_blank",
    rel: "noopener noreferrer"
  }, prepareResult.pullRequest.url)), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "You can already import the location and ", appTitle, " will fetch the entities as soon as the Pull Request is merged.")), /* @__PURE__ */ React.createElement(Typography, null, "The following entities will be added to the catalog:"), /* @__PURE__ */ React.createElement(EntityListComponent, {
    locations: prepareResult.locations,
    locationListItemIcon: () => /* @__PURE__ */ React.createElement(LocationOnIcon, null)
  }), error && /* @__PURE__ */ React.createElement(FormHelperText, {
    error: true
  }, error), /* @__PURE__ */ React.createElement(Grid, {
    container: true,
    spacing: 0
  }, onGoBack && /* @__PURE__ */ React.createElement(BackButton, {
    onClick: onGoBack,
    disabled: submitted
  }), /* @__PURE__ */ React.createElement(NextButton, {
    disabled: submitted,
    loading: submitted,
    onClick: () => handleImport()
  }, "Import")));
};

function defaultPreparePullRequest(apis, {title, body} = {}) {
  var _a;
  const appTitle = (_a = apis.configApi.getOptionalString("app.title")) != null ? _a : "Backstage";
  const appBaseUrl = apis.configApi.getString("app.baseUrl");
  return {
    title: title != null ? title : "Add catalog-info.yaml config file",
    body: body != null ? body : `This pull request adds a **Backstage entity metadata file** to this repository so that the component can be added to the [${appTitle} software catalog](${appBaseUrl}).

After this pull request is merged, the component will become available.

For more information, read an [overview of the Backstage software catalog](https://backstage.io/docs/features/software-catalog/software-catalog-overview).`
  };
}
function defaultGenerateStepper(flow, defaults) {
  switch (flow) {
    case "single-location":
      return {
        ...defaults,
        prepare: () => ({
          stepLabel: /* @__PURE__ */ React.createElement(StepLabel, {
            optional: /* @__PURE__ */ React.createElement(Typography, {
              variant: "caption"
            }, "Discovered Locations: 1")
          }, "Select Locations"),
          content: /* @__PURE__ */ React.createElement(React.Fragment, null)
        })
      };
    case "multiple-locations":
      return {
        ...defaults,
        prepare: (state, opts) => {
          if (state.analyzeResult.type !== "locations") {
            return defaults.prepare(state, opts);
          }
          return {
            stepLabel: /* @__PURE__ */ React.createElement(StepLabel, {
              optional: /* @__PURE__ */ React.createElement(Typography, {
                variant: "caption"
              }, "Discovered Locations: ", state.analyzeResult.locations.length)
            }, "Select Locations"),
            content: /* @__PURE__ */ React.createElement(StepPrepareSelectLocations, {
              analyzeResult: state.analyzeResult,
              prepareResult: state.prepareResult,
              onPrepare: state.onPrepare,
              onGoBack: state.onGoBack
            })
          };
        }
      };
    case "no-location":
      return {
        ...defaults,
        prepare: (state, opts) => {
          var _a, _b;
          if (state.analyzeResult.type !== "repository") {
            return defaults.prepare(state, opts);
          }
          const preparePullRequest = (_b = (_a = opts == null ? void 0 : opts.opts) == null ? void 0 : _a.pullRequest) == null ? void 0 : _b.preparePullRequest;
          const {title, body} = defaultPreparePullRequest(opts.apis, preparePullRequest ? preparePullRequest(opts.apis) : {});
          return {
            stepLabel: /* @__PURE__ */ React.createElement(StepLabel, null, "Create Pull Request"),
            content: /* @__PURE__ */ React.createElement(StepPrepareCreatePullRequest, {
              analyzeResult: state.analyzeResult,
              onPrepare: state.onPrepare,
              onGoBack: state.onGoBack,
              defaultTitle: title,
              defaultBody: body,
              renderFormFields: ({
                values,
                control,
                errors,
                groupsLoading,
                groups,
                register
              }) => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Box, {
                marginTop: 2
              }, /* @__PURE__ */ React.createElement(Typography, {
                variant: "h6"
              }, "Pull Request Details")), /* @__PURE__ */ React.createElement(TextField, {
                name: "title",
                label: "Pull Request Title",
                placeholder: "Add Backstage catalog entity descriptor files",
                margin: "normal",
                variant: "outlined",
                fullWidth: true,
                inputRef: register({required: true}),
                error: Boolean(errors.title),
                required: true
              }), /* @__PURE__ */ React.createElement(TextField, {
                name: "body",
                label: "Pull Request Body",
                placeholder: "A describing text with Markdown support",
                margin: "normal",
                variant: "outlined",
                fullWidth: true,
                inputRef: register({required: true}),
                error: Boolean(errors.body),
                multiline: true,
                required: true
              }), /* @__PURE__ */ React.createElement(Box, {
                marginTop: 2
              }, /* @__PURE__ */ React.createElement(Typography, {
                variant: "h6"
              }, "Entity Configuration")), /* @__PURE__ */ React.createElement(TextField, {
                name: "componentName",
                label: "Name of the created component",
                placeholder: "my-component",
                margin: "normal",
                variant: "outlined",
                fullWidth: true,
                inputRef: register({required: true}),
                error: Boolean(errors.componentName),
                required: true
              }), !values.useCodeowners && /* @__PURE__ */ React.createElement(AutocompleteTextField, {
                name: "owner",
                control,
                errors,
                options: groups || [],
                loading: groupsLoading,
                loadingText: "Loading groups\u2026",
                helperText: "Select an owner from the list or enter a reference to a Group or a User",
                errorHelperText: "required value",
                textFieldProps: {
                  label: "Entity Owner",
                  placeholder: "my-group"
                },
                rules: {required: true},
                required: true
              }), /* @__PURE__ */ React.createElement(FormControlLabel, {
                control: /* @__PURE__ */ React.createElement(Checkbox, {
                  name: "useCodeowners",
                  inputRef: register,
                  onChange: (_, value) => {
                    if (value) {
                      control.setValue("owner", "");
                    }
                  }
                }),
                label: /* @__PURE__ */ React.createElement(React.Fragment, null, "Use ", /* @__PURE__ */ React.createElement("em", null, "CODEOWNERS"), " file as Entity Owner")
              }), /* @__PURE__ */ React.createElement(FormHelperText, null, "WARNING: This may fail if no CODEOWNERS file is found at the target location."))
            })
          };
        }
      };
    default:
      return defaults;
  }
}
const defaultStepper = {
  analyze: (state, {opts}) => {
    var _a;
    return {
      stepLabel: /* @__PURE__ */ React.createElement(StepLabel, null, "Select URL"),
      content: /* @__PURE__ */ React.createElement(StepInitAnalyzeUrl, {
        key: "analyze",
        analysisUrl: state.analysisUrl,
        onAnalysis: state.onAnalysis,
        disablePullRequest: (_a = opts == null ? void 0 : opts.pullRequest) == null ? void 0 : _a.disable
      })
    };
  },
  prepare: (state) => ({
    stepLabel: /* @__PURE__ */ React.createElement(StepLabel, {
      optional: /* @__PURE__ */ React.createElement(Typography, {
        variant: "caption"
      }, "Optional")
    }, "Import Actions"),
    content: /* @__PURE__ */ React.createElement(BackButton, {
      onClick: state.onGoBack
    })
  }),
  review: (state) => ({
    stepLabel: /* @__PURE__ */ React.createElement(StepLabel, null, "Review"),
    content: /* @__PURE__ */ React.createElement(StepReviewLocation, {
      prepareResult: state.prepareResult,
      onReview: state.onReview,
      onGoBack: state.onGoBack
    })
  }),
  finish: (state) => ({
    stepLabel: /* @__PURE__ */ React.createElement(StepLabel, null, "Finish"),
    content: /* @__PURE__ */ React.createElement(StepFinishImportLocation, {
      reviewResult: state.reviewResult,
      onReset: state.onReset
    })
  })
};

const useStyles$3 = makeStyles(() => ({
  stepperRoot: {
    padding: 0
  }
}));
const ImportStepper = ({
  initialUrl,
  generateStepper = defaultGenerateStepper,
  variant,
  opts
}) => {
  const configApi = useApi(configApiRef);
  const classes = useStyles$3();
  const state = useImportState({initialUrl});
  const states = useMemo(() => generateStepper(state.activeFlow, defaultStepper), [generateStepper, state.activeFlow]);
  const render = (step) => {
    return /* @__PURE__ */ React.createElement(Step, null, step.stepLabel, /* @__PURE__ */ React.createElement(StepContent, null, step.content));
  };
  return /* @__PURE__ */ React.createElement(InfoCard, {
    variant
  }, /* @__PURE__ */ React.createElement(Stepper, {
    classes: {root: classes.stepperRoot},
    activeStep: state.activeStepNumber,
    orientation: "vertical"
  }, render(states.analyze(state, {apis: {configApi}, opts})), render(states.prepare(state, {apis: {configApi}, opts})), render(states.review(state, {apis: {configApi}, opts})), render(states.finish(state, {apis: {configApi}, opts}))));
};

function repositories(configApi) {
  const integrations = configApi.getConfig("integrations");
  const repos = [];
  if (integrations.has("github")) {
    repos.push("GitHub");
  }
  if (integrations.has("bitbucket")) {
    repos.push("Bitbucket");
  }
  if (integrations.has("gitlab")) {
    repos.push("GitLab");
  }
  if (integrations.has("azure")) {
    repos.push("Azure");
  }
  return repos;
}
const ImportComponentPage = (opts) => {
  var _a;
  const configApi = useApi(configApiRef);
  const appTitle = configApi.getOptional("app.title") || "Backstage";
  const repos = repositories(configApi);
  const repositoryString = repos.join(", ").replace(/, (\w*)$/, " or $1");
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "home"
  }, /* @__PURE__ */ React.createElement(Header, {
    title: "Register an existing component"
  }), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ContentHeader, {
    title: `Start tracking your component in ${appTitle}`
  }, /* @__PURE__ */ React.createElement(SupportButton, null, "Start tracking your component in ", appTitle, " by adding it to the software catalog.")), /* @__PURE__ */ React.createElement(Grid, {
    container: true,
    spacing: 2,
    direction: "row-reverse"
  }, /* @__PURE__ */ React.createElement(Grid, {
    item: true,
    xs: 12,
    md: 4,
    lg: 6,
    xl: 8
  }, /* @__PURE__ */ React.createElement(InfoCard, {
    title: "Register an existing component",
    deepLink: {
      title: "Learn more about the Software Catalog",
      link: "https://backstage.io/docs/features/software-catalog/software-catalog-overview"
    }
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    paragraph: true
  }, "Enter the URL to your SCM repository to add it to ", appTitle, "."), /* @__PURE__ */ React.createElement(Typography, {
    variant: "h6"
  }, "Link to an existing entity file"), /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    color: "textSecondary",
    paragraph: true
  }, "Example:", " ", /* @__PURE__ */ React.createElement("code", null, "https://github.com/backstage/backstage/blob/master/catalog-info.yaml")), /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    paragraph: true
  }, "The wizard analyzes the file, previews the entities, and adds them to the ", appTitle, " catalog."), repos.length > 0 && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h6"
  }, "Link to a ", repositoryString, " repository"), /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    color: "textSecondary",
    paragraph: true
  }, "Example: ", /* @__PURE__ */ React.createElement("code", null, "https://github.com/backstage/backstage")), /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    paragraph: true
  }, "The wizard discovers all ", /* @__PURE__ */ React.createElement("code", null, "catalog-info.yaml"), " ", "files in the repository, previews the entities, and adds them to the ", appTitle, " catalog."), !((_a = opts == null ? void 0 : opts.pullRequest) == null ? void 0 : _a.disable) && /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    paragraph: true
  }, "If no entities are found, the wizard will prepare a Pull Request that adds an example", " ", /* @__PURE__ */ React.createElement("code", null, "catalog-info.yaml"), " and prepares the ", appTitle, " ", "catalog to load all entities as soon as the Pull Request is merged.")))), /* @__PURE__ */ React.createElement(Grid, {
    item: true,
    xs: 12,
    md: 8,
    lg: 6,
    xl: 4
  }, /* @__PURE__ */ React.createElement(ImportStepper, {
    opts
  })))));
};

const Router = (opts) => /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
  element: /* @__PURE__ */ React.createElement(ImportComponentPage, {
    ...opts
  })
}));

var Router$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Router: Router
});

export { AutocompleteTextField, CatalogImportClient, CatalogImportPage, EntityListComponent, ImportStepper, PreparePullRequestForm, PreviewCatalogInfoComponent, PreviewPullRequestComponent, Router, StepInitAnalyzeUrl, StepPrepareCreatePullRequest, catalogImportApiRef, catalogImportPlugin, defaultGenerateStepper, catalogImportPlugin as plugin };
//# sourceMappingURL=index.esm.js.map
