'use strict';

require('chalk');
var index = require('./index-ce78e402.cjs.js');
var fs = require('fs-extra');
require('./run-646af88e.cjs.js');
var semver = require('semver');
var lockfile = require('@yarnpkg/lockfile');
var partition = require('lodash/partition');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var semver__default = /*#__PURE__*/_interopDefaultLegacy(semver);
var partition__default = /*#__PURE__*/_interopDefaultLegacy(partition);

const ENTRY_PATTERN = /^((?:@[^/]+\/)?[^@/]+)@(.+)$/;
class Lockfile {
  constructor(path, packages, data) {
    this.path = path;
    this.packages = packages;
    this.data = data;
  }
  static async load(path) {
    var _a;
    const lockfileContents = await fs__default['default'].readFile(path, "utf8");
    const lockfile$1 = lockfile.parse(lockfileContents);
    if (lockfile$1.type !== "success") {
      throw new Error(`Failed yarn.lock parse with ${lockfile$1.type}`);
    }
    const data = lockfile$1.object;
    const packages = new Map();
    for (const [key, value] of Object.entries(data)) {
      const [, name, range] = (_a = ENTRY_PATTERN.exec(key)) != null ? _a : [];
      if (!name) {
        throw new Error(`Failed to parse yarn.lock entry '${key}'`);
      }
      let queries = packages.get(name);
      if (!queries) {
        queries = [];
        packages.set(name, queries);
      }
      queries.push({range, version: value.version});
    }
    return new Lockfile(path, packages, data);
  }
  get(name) {
    return this.packages.get(name);
  }
  keys() {
    return this.packages.keys();
  }
  analyze(options) {
    var _a;
    const {filter} = options != null ? options : {};
    const result = {
      invalidRanges: [],
      newVersions: [],
      newRanges: []
    };
    for (const [name, allEntries] of this.packages) {
      if (filter && !filter(name)) {
        continue;
      }
      const invalid = allEntries.filter((e) => !semver__default['default'].validRange(e.range));
      result.invalidRanges.push(...invalid.map(({range}) => ({name, range})));
      const entries = allEntries.filter((e) => semver__default['default'].validRange(e.range));
      if (entries.length < 2) {
        continue;
      }
      const versions = Array.from(new Set(entries.map((e) => e.version))).sort((v1, v2) => semver__default['default'].rcompare(v1, v2));
      if (versions.length < 2) {
        continue;
      }
      const acceptedVersions = new Set();
      for (const {version, range} of entries) {
        const acceptedVersion = versions.find((v) => semver__default['default'].satisfies(v, range));
        if (!acceptedVersion) {
          throw new Error(`No existing version was accepted for range ${range}, searching through ${versions}, for package ${name}`);
        }
        if (acceptedVersion !== version) {
          result.newVersions.push({
            name,
            range,
            newVersion: acceptedVersion,
            oldVersion: version
          });
        }
        acceptedVersions.add(acceptedVersion);
      }
      if (acceptedVersions.size === 1) {
        continue;
      }
      const maxVersion = Array.from(acceptedVersions).sort(semver__default['default'].rcompare)[0];
      const maxEntry = (_a = entries.filter((e) => semver__default['default'].satisfies(maxVersion, e.range)).map((e) => ({e, min: semver__default['default'].minVersion(e.range)})).filter((p) => p.min).sort((a, b) => semver__default['default'].rcompare(a.min, b.min))[0]) == null ? void 0 : _a.e;
      if (!maxEntry) {
        throw new Error(`No entry found that satisfies max version '${maxVersion}'`);
      }
      for (const {version, range} of entries) {
        if (semver__default['default'].satisfies(maxVersion, range)) {
          continue;
        }
        result.newRanges.push({
          name,
          oldRange: range,
          newRange: maxEntry.range,
          oldVersion: version,
          newVersion: maxVersion
        });
      }
    }
    return result;
  }
  remove(name, range) {
    var _a;
    const query = `${name}@${range}`;
    const existed = Boolean(this.data[query]);
    delete this.data[query];
    const newEntries = (_a = this.packages.get(name)) == null ? void 0 : _a.filter((e) => e.range !== range);
    if (newEntries) {
      this.packages.set(name, newEntries);
    }
    return existed;
  }
  replaceVersions(results) {
    var _a;
    for (const {name, range, oldVersion, newVersion} of results) {
      const query = `${name}@${range}`;
      const entryData = this.data[query];
      if (!entryData) {
        throw new Error(`No entry data for ${query}`);
      }
      if (entryData.version !== oldVersion) {
        throw new Error(`Expected existing version data for ${query} to be ${oldVersion}, was ${entryData.version}`);
      }
      const matchingEntry = Object.entries(this.data).find(([q, e]) => q.startsWith(`${name}@`) && e.version === newVersion);
      if (!matchingEntry) {
        throw new Error(`No matching entry found for ${name} at version ${newVersion}`);
      }
      this.data[query] = matchingEntry[1];
      const entry = (_a = this.packages.get(name)) == null ? void 0 : _a.find((e) => e.range === range);
      if (!entry) {
        throw new Error(`No entry data for ${query}`);
      }
      if (entry.version !== oldVersion) {
        throw new Error(`Expected existing version data for ${query} to be ${oldVersion}, was ${entryData.version}`);
      }
      entry.version = newVersion;
    }
  }
  async save() {
    await fs__default['default'].writeFile(this.path, this.toString(), "utf8");
  }
  toString() {
    return lockfile.stringify(this.data);
  }
}

const INCLUDED = [/^@backstage\//];
const includedFilter = (name) => INCLUDED.some((pattern) => pattern.test(name));
const FORBID_DUPLICATES = [
  /^@backstage\/core$/,
  /^@backstage\/core-api$/,
  /^@backstage\/plugin-/
];
const forbiddenDuplicatesFilter = (name) => FORBID_DUPLICATES.some((pattern) => pattern.test(name));
var lint = async (cmd) => {
  const fix = Boolean(cmd.fix);
  let success = true;
  const lockfile = await Lockfile.load(index.paths.resolveTargetRoot("yarn.lock"));
  const result = lockfile.analyze({
    filter: includedFilter
  });
  logArray(result.invalidRanges, "The following packages versions are invalid and can't be analyzed:", (e) => `  ${e.name} @ ${e.range}`);
  if (fix) {
    lockfile.replaceVersions(result.newVersions);
    await lockfile.save();
  } else {
    const [
      newVersionsForbidden,
      newVersionsAllowed
    ] = partition__default['default'](result.newVersions, ({name}) => forbiddenDuplicatesFilter(name));
    if (newVersionsForbidden.length && !fix) {
      success = false;
    }
    logArray(newVersionsForbidden, "The following packages must be deduplicated, this can be done automatically with --fix", (e) => `  ${e.name} @ ${e.range} bumped from ${e.oldVersion} to ${e.newVersion}`);
    logArray(newVersionsAllowed, "The following packages can be deduplicated, this can be done automatically with --fix", (e) => `  ${e.name} @ ${e.range} bumped from ${e.oldVersion} to ${e.newVersion}`);
  }
  const [newRangesForbidden, newRangesAllowed] = partition__default['default'](result.newRanges, ({name}) => forbiddenDuplicatesFilter(name));
  if (newRangesForbidden.length) {
    success = false;
  }
  logArray(newRangesForbidden, "The following packages must be deduplicated by updating dependencies in package.json", (e) => `  ${e.name} @ ${e.oldRange} should be changed to ${e.newRange}`);
  logArray(newRangesAllowed, "The following packages can be deduplicated by updating dependencies in package.json", (e) => `  ${e.name} @ ${e.oldRange} should be changed to ${e.newRange}`);
  if (!success) {
    throw new Error("Failed versioning check");
  }
};
function logArray(arr, header, each) {
  if (arr.length === 0) {
    return;
  }
  console.log(header);
  console.log();
  for (const e of arr) {
    console.log(each(e));
  }
  console.log();
}

var lint$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  includedFilter: includedFilter,
  forbiddenDuplicatesFilter: forbiddenDuplicatesFilter,
  'default': lint
});

exports.Lockfile = Lockfile;
exports.forbiddenDuplicatesFilter = forbiddenDuplicatesFilter;
exports.includedFilter = includedFilter;
exports.lint = lint$1;
//# sourceMappingURL=lint-e7ba3595.cjs.js.map
